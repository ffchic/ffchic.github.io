<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pm2部署nuxt项目</title>
      <link href="/posts/fedf65bb/"/>
      <url>/posts/fedf65bb/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>纯干货分享，没有任何夹带私货，在历经了两天一晚上的恶心部署后，我作为一个没什么运维经验的小白，终于是搞定了这个难缠的东西。</p></blockquote><h2 id="npm-run-start"><a href="#npm-run-start" class="headerlink" title="npm run start"></a>npm run start</h2><p>这是一个错误的启动方式，现在网上找到的启动步骤：<code>pm2 start npm --name "name" -- run start</code>其实也是同样的启动方式。这样启动的问题是，cluster部署时，程序可以正常启动，但是我们查看PM2的日志的时候，会发现每次启动 PM2 都会打印错误日志：</p><pre class="language-css" data-language="css"><code class="language-css">2020-07-10T14:49:46:  Failed at the ssr@1.0.0 start script.2020-07-10T14:49:46:  This is probably not a problem with npm. There is likely additional logging output above.2020-07-15T19:38:23:  ELIFECYCLE2020-07-15T19:38:23:  ssr@1.0.0 start: `nuxt start`2020-07-15T19:38:23:  Exit status 1</code></pre><p>而且在下一次执行<code>pm2 restart</code>或<code>pm2 reload</code>的时候，大概率会重启失败，需要再执行一次重启才能启动成功。一直不理解为什么程序启动了，但是每次都有错误日志，且每次重启都失败。</p><h2 id="正确的启动姿势"><a href="#正确的启动姿势" class="headerlink" title="正确的启动姿势"></a>正确的启动姿势</h2><p>经过一顿研究，才发现，不能直接在 PM2 执行 npm 指令，正确的启动方式应该是执行<code>npm run start</code>里面的指令：<code>nuxt start</code>：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">// package.json"scripts": {    "start": "nuxt start"  }</code></pre><p>而<code>nuxt start</code>的执行路径就在<code>/node_modules/nuxt/bin/nuxt.js</code>，所以正确的<code>ecosystem.config.js</code>启动配置应该是：</p><pre class="language-java" data-language="java"><code class="language-java">// ecosystem.config.jsmodule.exports = {  apps: [    {      name: 'NuxtAppName',      exec_mode: 'cluster',      instances: 'max', // Or a number of instances      script: './node_modules/nuxt/bin/nuxt.js',      args: 'start',    },  ],}</code></pre><p><a href="https://nuxtjs.org/deployments/pm2/">官方文档</a></p><p>不知道为什么当初在部署的时候就是没看到这片官方指引，看了其他人的博客误导了。在启动上就踩了坑。所以入门一个东西的时候，尽可能地阅读官方文档，要帮助理解的时候再去阅读博客加深理解！</p><h2 id="零停机部署"><a href="#零停机部署" class="headerlink" title="零停机部署"></a>零停机部署</h2><p>零停机部署就是使用 PM2 的 cluster模式，更新程序的时候用 <code>pm2 reload [appName]</code>，有多个集群(cluster)的时候，PM2会先重启一部分进程，这样就不会导致服务中断，等新的进程重启成功后再重启其他进程，实现零停机(zero-downtime)部署。</p><p>但是<code>reload</code>似乎在有时候会有代码更新后<code>reload</code>无法更新代码的问题。但只遇到了一次，实测在更新UI的时候，直接reload是可以更新成功的，等下次遇到了再解决吧。</p><h2 id="pm2常用命令"><a href="#pm2常用命令" class="headerlink" title="pm2常用命令"></a>pm2常用命令</h2><pre class="language-text" data-language="text"><code class="language-text"># 查看当前正在运行的进程pm2 list# 启动所有应用pm2 start id|name|all# 重启所有应用pm2 restart id|name|all# 停止所有的应用程序pm2 stop id|name|all# 关闭并删除所有应用pm2 delete id|name|all# 控制台显示所有日志pm2 logs# 控制台显示指定编号的日志pm2 logs id# 查看信息pm2 show id|name# 显示每个应用程序的CPU和内存占用情况pm2 monit</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GORM自定义结构</title>
      <link href="/posts/5994c9c6/"/>
      <url>/posts/5994c9c6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>GORM作为一个go语言里知名的orm，可谓是文档详细，功能强大，操作简单，集所有的优势于一体，几乎可以说是没什么缺点。但是吧，作为一个刚从python转语言过来的新人，在Gin+GORM映射结构体这一环节可谓是踩坑不少。首先就是，我要接收一个数组，数据库字段类型为<code>varchar</code>，如果结构体类型定义为<code>string</code>，则根本映射不到，如果是<code>[]string</code>，则又会出现各种各样的错误，为此我也走了不少弯路。以此篇文章来记录一下。</p></blockquote><h2 id="自定义结构体"><a href="#自定义结构体" class="headerlink" title="自定义结构体"></a>自定义结构体</h2><p>就先不说踩的坑了，先上解决办法，这其实也是一个坑，因为我没有认真看完文档，也没有联想起来解决办法，所以导致在此卡了很久。</p><p><a href="https://gorm.io/zh_CN/docs/data_types.html">自定义数据类型</a></p><p>我们无法通过<code>[]string</code>或者<code>[]map[string]interface{}</code>来进行入库。但是我们可以自定义结构，以此通过他的编译和入库，完成我们想要的功能。</p><pre class="language-go" data-language="go"><code class="language-go">type Front struct {Banner []string `gorm:"type:varchar(255);not null" json:"banner" label:"Banner图"`}</code></pre><p>像上面这样，我们完全无法存储一个列表，即便存了，也是各种bug不断，此时就需要我们自定义类型。根据文档得知，我们要实现<code>Value</code>和<code>Scan</code>方法。</p><pre class="language-go" data-language="go"><code class="language-go">type Node struct {List List `json:"list" `}type List []stringfunc (p List) Value() (driver.Value, error) {return json.Marshal(p)}func (p *List ) Scan(data interface{}) error {return json.Unmarshal(data.([]byte), &amp;p)}// 将其修改为List类型。type Front struct {Banner List `gorm:"type:varchar(255);not null" json:"banner" label:"Banner图"`}</code></pre><p>这样，我们就实现了我们想要的功能，接收<code>["1","2","3","4"]</code>这样的数据来存储到数据库了。</p><p>同样的，想列表嵌套数组的深层嵌套结构也可以通过自定义结构来完成。</p><pre class="language-go" data-language="go"><code class="language-go">type Hash struct {Name string `json:"name"`Link string `json:"link"`}type HashValue []Hashfunc (p HashValue) Value() (driver.Value, error) {return json.Marshal(p)}func (p *HashValue ) Scan(data interface{}) error {return json.Unmarshal(data.([]byte), &amp;p)}</code></pre><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>再来说说我踩过的坑，虽然没成功，但是呢，我觉得有教育意义，本来一开始定义的结构体类型为string，然后无法接收到数组数据，随后我又将其改为了空接口。虽然能够接收到数据了，但是，依旧无法入库。</p><p>然后最重要的地方来了，我的思想出现了问题，既然我无法存入空接口数组数据，那我干脆存成字符串吧，于是我使用<code>fmt.Sprintf</code>来将数据格式化为字符串，于是后边就针对字符串进行了各种操作，最终结果也是以失败告终。</p><p>此路不通之后，我就想着让字符串原封不动的入库，于是又将接收的结构体换成了map，通过这个终于成功的入库了，但是，问题又来了，既然是字符串，在进行序列化之后，前端会将字符串的符号进行自动的转义，针对转义问题我又进行了各种操作，从替换字符，到分割数组，卡在这里好几天。。。</p><blockquote><p>总之呢，就是，只要思想不滑坡，办法总比困难多。希望大家能以此为戒。思想不要出现问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python | golang实现公众号扫码登陆</title>
      <link href="/posts/a38bad63/"/>
      <url>/posts/a38bad63/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>微信公众号，已经是目前开发者不容错过的一个通道了，像是很多餐厅都通过微信扫码点餐，很多网站都是舍弃了原本的账号密码登陆，而改用微信公众号关注登陆。针对于这个场景，今天来使用python和golang来实现一下。</p></blockquote><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><blockquote><p>大致流程是这样：</p><ul><li>首先我们要获取二维码和场景值</li><li>通过配置公众号回调地址来将场景值和获取的open_id存到redis，同时获取新用户的信息</li><li>然后前端通过轮询或者websocket请求登陆接口来实现。查找场景值对应的open_id，通过数据库的数据生成自定义的登陆状态。</li></ul></blockquote><h2 id="1-配置公众号"><a href="#1-配置公众号" class="headerlink" title="1. 配置公众号"></a>1. 配置公众号</h2><p>没有服务号没有关系，微信推出了一个测试服务号接口的<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login">地址</a></p><img src="/posts/a38bad63/image-20211008160700052.png" alt style="zoom:80%;" loading="lazy"><p>我们需要配置URL和Token，URL要填写你能够收到信息的服务器地址，Token你可以用某些包来生成，也可以用脸在键盘上滚几圈。</p><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Access_Overview.html">文档地址</a></p><p>我这里用fastapi来做一下模拟，需要注意的是，文档上所需要的返回数据是text/plain而不是application/json，所以我们使用<code>PlainTextResponse</code></p><pre class="language-python" data-language="python"><code class="language-python">import hashlibfrom fastapi import FastAPI, Queryfrom fastapi.responses import JSONResponse, PlainTextResponseapp = FastAPI()@app.get('/wechat/')async def WeChat(        signature: str = Query(...),        timestamp: str = Query(...),        nonce: str = Query(...),        echostr: str = Query(...)                 ):    if not signature:        return JSONResponse("dasdfafd")    # token 微信公众平台自定义token    token = "fjklsdjfksdjkflsd"    # 将token、timestamp、nonce三个参数进行字典序排序    list1 = [token, timestamp, nonce]    list1.sort()    # 将三个参数字符串拼接成一个字符串进行sha1加密    info = "".join(list1)    sha1 = hashlib.sha1()    sha1.update(info.encode())    hashcode = sha1.hexdigest()    if hashcode == signature:        return PlainTextResponse(echostr)    else:        return ""if __name__ == '__main__':    import uvicorn    uvicorn.run(app='test_requests:app', host="0.0.0.0", port=8010, reload=True)</code></pre><p>点击一下就可以了。</p><h2 id="2-生成带参数的二维码"><a href="#2-生成带参数的二维码" class="headerlink" title="2. 生成带参数的二维码"></a>2. 生成带参数的二维码</h2><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Account_Management/Generating_a_Parametric_QR_Code.html">文档地址</a>，需要注意的是，公众号每天获取access_token的次数是2000次，而每个access_token的过期时间是两个小时，所以我们在生产中，可以将access_token存到缓存中。</p><pre class="language-python" data-language="python"><code class="language-python">class MyWeChatOAuth:    def __init__(self):        self.app_id = 'XXX'        self.secret = 'XXX'    def get_token(self):        """        获取access_token        """        url = f"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid={self.app_id}&amp;secret={self.secret}"        ret = requests.get(url=url)        content = (ret.content).decode("utf-8")        res = json.loads(content)        return res.get("access_token")    def get_ticket(self):        url = f"https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token={self.get_token()}"        scene_id = int(time.time() * 100000)        data = {            "expire_seconds": 300,            "action_name": "QR_SCENE",            "action_info": {                "scene": {                    "scene_id": scene_id                }            }        }        rep = requests.post(url, json=data)        content = (rep.content).decode("utf-8")        js = json.loads(content)        ticket = js.get("ticket")        ret_url = "https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket={}".format(ticket)        return ret_url</code></pre><p>ret_url就是二维码的地址，此时需要将场景值scene_id返回给前端。</p><h2 id="3-关注-取消事件"><a href="#3-关注-取消事件" class="headerlink" title="3. 关注/取消事件"></a>3. 关注/取消事件</h2><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_event_pushes.html">文档地址</a>，这个地址就要写你在配置的时候填写的url了。</p><p>判断Event，关注着的为SCAN，未关注为subscribe，取消关注为unsubscribe。这里的业务逻辑就要自己DIY了，我的选择是将获取到的用户信息入库，然后将场景值和open_id（也就是和Event同级的FromUserName）存入redis，将新关注的用户获取用户信息入库，这里就不放业务代码了。无非就是读库写库操作。</p><pre class="language-python" data-language="python"><code class="language-python">@app.post('/wechat/')async def create_wechat(        request: Request,                        ):    req = await request.body()    xmlmsg = xmltodict.parse(req)    if xmlmsg["xml"]["Event"] == "SCAN":        # 已经关注的        pass    elif xmlmsg["xml"]["Event"] == "subscribe":        # 没有关注的        pass    else:        # 其他        pass    return JSONResponse("ok")</code></pre><h2 id="4-获取用户信息"><a href="#4-获取用户信息" class="headerlink" title="4. 获取用户信息"></a>4. 获取用户信息</h2><p>通过access_token和open_id来获取该用户的信息。</p><pre class="language-python" data-language="python"><code class="language-python">url = "https://api.weixin.qq.com/cgi-bin/user/info?access_token={access_token}&amp;openid={open_id}&amp;lang=zh_CN"resp = requests.get(url.format(access_token=access_token, open_id=xmlmsg["xml"]["FromUserName"]))resp.encoding = 'utf-8'</code></pre><h2 id="Golang实现"><a href="#Golang实现" class="headerlink" title="Golang实现"></a>Golang实现</h2><p>由于最近在学习go语言，所以用python实现了一遍之后，还要再用go实现一遍，也为目前go的资料不多贡献一丢丢可以CV的代码。</p><pre class="language-go" data-language="go"><code class="language-go">// 获取access_tokenfunc GetAccessToken() (string) {var (AppId string = "XXX"Secret string = "XXX")// 拼接urlurl := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%s&amp;secret=%s",AppId,Secret)// 初始化mapresult := make(map[string]string)ret, _ := http.Get(url)// 读取结果content, _ := ioutil.ReadAll(ret.Body)// 赋值_ = json.Unmarshal([]byte(content), &amp;result)return result["access_token"]}// 获取二维码func GetTicket() map[string]interface{} {result := make(map[string]interface{})data := make(map[string]interface{})url := fmt.Sprintf("https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=%s", GetAccessToken())scene := fmt.Sprintf("%010v", rand.New(rand.NewSource(time.Now().UnixNano())).Int31n(100000000))scene_id,_ := strconv.ParseInt(scene, 10, 64)data["expire_seconds"] = 300data["action_name"] = "QR_SCENE"action_info := make(map[string]interface{})scene_ids := make(map[string]int64)scene_ids["scene_id"] = scene_idaction_info["scene"] = scene_idsdata["action_info"] = action_inforeq,_ := json.Marshal(data)//json_data := bytes.NewBuffer(req)resp, _ := http.Post(url, "application/json", bytes.NewBuffer(req))content, _ := ioutil.ReadAll(resp.Body)// 赋值var res = make(map[string]string)_ = json.Unmarshal([]byte(content), &amp;res)result["ticket"] = "https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket="+res["ticket"]result["scene_id"] = scene_idreturn result}</code></pre><p>回调的话需要启一个http服务，我没有使用go自带的包，而是使用了web框架<code>gin</code></p><pre class="language-go" data-language="go"><code class="language-go">type XmlData struct {FromUserName string `xml:"FromUserName"`Event string `xml:"Event"`EventKey string `xml:"EventKey"`}r := gin.New()r.POST("/wechat/", func(c *gin.Context) {    // 获取请求体res := c.Request    // 使用结构体来接收xml的数据var xml_data XmlData    // 转换content, _ := ioutil.ReadAll(res.Body)fmt.Println(string(content))    // 赋值到结构体_ = xml.Unmarshal([]byte(content), &amp;xml_data)//fmt.Println(xml_data.Event)//fmt.Println(xml_data.FromUserName)c.String(http.StatusOK, "hello Salmon!")})_ = r.Run(":8020")</code></pre><p>然后业务代码就DIY吧，ps：吐槽一下，go写业务是真的有些麻烦，也可能是python写习惯的原因吧。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> FastAPI </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐一款好用的python-web框架</title>
      <link href="/posts/4319cda8/"/>
      <url>/posts/4319cda8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p><a href="https://index-py.aber.sh/stable/">index.py</a>这是一个异步 web 框架，设计目的在于快速的构建需要的 web 服务，无论是 Templates 还是 API。</p><p>其非常相似于<a href="https://fastapi.tiangolo.com/">FastAPI</a>，但融合了<a href="https://www.djangoproject.com/">Django</a>的CBV，再加上极其灵活的路由，可以一架两用，无论是习惯了Falsk和Fastapi的FBV写法还是Django的CBV写法，都可以很快的适应这个框架。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>需要注意的是，index.py要求的Python版本至少是3.7，如果不愿意升级版本的话，可以使用 docker 来运行 Index.py。</p></blockquote><pre class="language-none"><code class="language-none">pip install -U index.pypip install uvicorn</code></pre><blockquote><p>由于是ASGI应用，使用uvicorn作为服务器。</p></blockquote><h2 id="性能测试及对比"><a href="#性能测试及对比" class="headerlink" title="性能测试及对比"></a>性能测试及对比</h2><blockquote><p>我挑选了Fastapi和django3.1作为性能对比对象。使用ApacheBench来进行压测</p><p>由于机器性能问题，总请求数5000，并发100</p><p><code>ab -n 5000 -c 100 http://127.0.0.1:4950/hello</code></p></blockquote><p>首先是FastAPI：</p><img src="/posts/4319cda8/image-20210926133041317.png" alt style="zoom:70%;" loading="lazy"><p>创建三个进程来进行测试。<code>uvicorn main:app --port=4950 --workers=3</code></p><img src="/posts/4319cda8/image-20210926133219707.png" alt style="zoom:70%;" loading="lazy"><p>可以看到，作为python的异步web框架，FastAPI傲视wsgi群雄，处理五千个请求花费0.38秒。每秒可处理1w3个请求。</p><hr><p>然后测一下django3：</p><img src="/posts/4319cda8/image-20210926134735462.png" alt style="zoom:50%;" loading="lazy"><p>由于django3已经支持asgi了，所以我们同样可以使用uvicorn来启动。</p><p><code>uvicorn test_django.asgi:application --workers=3</code></p><img src="/posts/4319cda8/image-20210926134904937.png" alt style="zoom:80%;" loading="lazy"><p>不知道是不是我的方式有误否，这个成绩着实差距很大，重来，我们使用gunicorn来配合uvicorn。写一个配置文件<code>gunicorn.conf.py</code></p><pre class="language-python" data-language="python"><code class="language-python">workers = 3threads = 3bind = ['127.0.0.1:8000']worker_class = 'uvicorn.workers.UvicornWorker'daemon = False</code></pre><p>然后通过gunicorn来启动</p><p><code>gunicorn test_django.asgi:application -c ./gunicorn.conf.py</code></p><img src="/posts/4319cda8/image-20210926135339210.png" alt style="zoom:80%;" loading="lazy"><p>好吧盖了帽了，看来作为重量级框架，Django其在速度方面还需要一些进化。</p><hr><p>接下来是主角：index.py</p><img src="/posts/4319cda8/image-20210926133937545.png" alt style="zoom:70%;" loading="lazy"><p><code>uvicorn main:app --port=4910 --workers=3</code></p><img src="/posts/4319cda8/image-20210926134037142.png" alt style="zoom:67%;" loading="lazy"><p>ohhhh，0.31秒完成，每秒处理1w5的请求量，比fastapi还快那么一丝。不过在构建应用时会对数据库有操作，所以这一丝也说明不了什么问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>index.py可以作为Django与FastAPI特性的桥梁，虽然它不像Django、Flask、FastAPI、tornado这些web框架这么出名，但是好用是真滴好用。</p></blockquote><blockquote><p>引用一位大佬的话：一项新技术的出现和应用，常常会给这个领域带来深刻的变革，古语有云：察势者智，顺势者赢，驭势者独步天下。所以，只有拥抱未来、拥抱新技术、顺应时代才是正确的、可持续发展的道路。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客添加音乐播放器</title>
      <link href="/posts/89a20069/"/>
      <url>/posts/89a20069/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>这是一个非常没用，而且没用的功能。谁会在逛博客的时候点开音乐呢，但是吧，虽然没用，但是聊胜于无嘛。</p><p>PenguinPlayer 是一个基于网易云音乐的轻量级迷你播放器。它使用 TypeScript 和 Sass 编写，可以通过引用 player.js 在你的任何网页上挂载。</p><p>移动/触控设备支持<br>Internet Explorer 10+ 支持<br>简洁，好看还好用<br>使用简单<br>使用它，你首先需要有一个网易云歌单。</p><p>推荐使用 pjax.js 以获得无缝的体验。</p></blockquote><h2 id="下载PenguinPlayer"><a href="#下载PenguinPlayer" class="headerlink" title="下载PenguinPlayer"></a>下载PenguinPlayer</h2><p>首先，你需要到<a href="https://github.com/M4TEC/PenguinPlayer/releases">这里</a>下载最新版的 PenguinPlayer。</p><p>如果没有特别的需求，下载 player.js 就够了。</p><h2 id="配置-PenguinPlayer"><a href="#配置-PenguinPlayer" class="headerlink" title="配置 PenguinPlayer"></a>配置 PenguinPlayer</h2><p>你有两种方案可供选择：</p><p>直接修改 player.js<br>通过调用 PenguinPlayer 进行初始化（进阶）<br>直接在 player.js 中配置<br>现在，打开下载下来的 JavaScript 文档，并在 window 上下文中设置你的歌单 ID。举个例子：window.penguinplayer_id = “6630417901”</p><img src="/posts/89a20069/image-20210922180823581.png" alt style="zoom:50%;" loading="lazy"><p>调用 windows.PPlayer.initialize() 以对播放器进行初始化<br>你也可以通过使用 windows.PPlayer.initialize()语句在其他地方对 PenguinPlayer 进行初始化操作。</p><h2 id="配置你的博客"><a href="#配置你的博客" class="headerlink" title="配置你的博客"></a>配置你的博客</h2><p>这里以我使用的博客 Hexo 为例，主题是 Yun。</p><p>首先，把修改后的 player.js 复制到 /source/js 文件夹。</p><p>在主题配置文件 yun.yml 中，找到这几行：</p><pre class="language-yml" data-language="yml"><code class="language-yml">pjax:  enable: true  src: /js/pjax.js  # stylesheets loaded in the &lt;head&gt;css:  - /css/hexo-theme-yun.css# scripts loaded in the end of the bodyjs:  - /js/utils.js  - /js/hexo-theme-yun.js</code></pre><p>然后在 js 部分添加：</p><p><code>- /js/player.js</code></p><p>这一步的目的是让网页在运行时加载 PenguinPlayer 的组件。</p><p>你也可以顺便就把 pjax 打开了。</p><h2 id="PenguinPlayer-的进阶操作"><a href="#PenguinPlayer-的进阶操作" class="headerlink" title="PenguinPlayer 的进阶操作"></a>PenguinPlayer 的进阶操作</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>事实上，PenguinPlayer 为你提供了更多的自定义参数。</p><p>你可以使用 window.PPlayer.initialize(options: PenguinPlayerOptions) 语句在对其初始化时对其进行配置。</p><p>所有可用的配置参数都在下表中展示：</p><img src="/posts/89a20069/image-20210922181550210.png" alt style="zoom:70%;" loading="lazy"><h3 id="不同的版本"><a href="#不同的版本" class="headerlink" title="不同的版本"></a>不同的版本</h3><img src="/posts/89a20069/image-20210922181631632.png" alt style="zoom:70%;" loading="lazy"><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><img src="/posts/89a20069/image-20210922181750793.png" alt style="zoom:95%;" loading="lazy"><blockquote><p>播放器的所有接口都暴露在window上下文的PPlayer对象中</p></blockquote><p>虽然说这个功能用处不大，但是，万一呢…</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信支付回调</title>
      <link href="/posts/793ca00e/"/>
      <url>/posts/793ca00e/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>直到今天，才终于想起了半年前的支付功能还没有完成，哈哈，其实当时的这篇<a href="https://www.godhearing.cn/posts/20031/">文章</a>已经属于是完成了预支付的逻辑了，只是差这最后一个回调处理。回调地址基于预支付的notify_url，是异步的通知回调。</p><p>一般来说，支付逻辑是生成预支付的订单，然后通过前端 or 小程序端来调起微信支付，然后通过回调的地址来处理业务逻辑，或者通过一个<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_2">查询订单接口</a>来处理，两者处理业务逻辑没有什么实质性的区别，因为结果基于支付完成的。</p><p>回调的地址<a href="https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_7&amp;index=8">在这</a>，上面写的不是太清楚，所以会导致走一点小弯路。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用的框架是fastapi</p><pre class="language-none"><code class="language-none">pip install fastapipip install uvicornpip install xmltodict</code></pre><pre class="language-python" data-language="python"><code class="language-python">import xmltodictimport uvicornfrom fastapi import FastAPI, Request, statusfrom fastapi.encoders import jsonable_encoderfrom starlette.responses import JSONResponseapp = FastAPI()'''测试支付结果回调'''@app.post('/')async def payment(        request: Request,                  ):    req = await request.body()    xmlmsg = xmltodict.parse(req)    print(xmlmsg)    return JSONResponse(        status_code=status.HTTP_200_OK,        content=jsonable_encoder({            'return_code': 'SUCCESS',            'return_msg': 'OK',        })    )if __name__ == '__main__':    uvicorn.run("test:app", host="0.0.0.0", port=8010, reload=True)</code></pre><p>需要注意的是，他的回调地址是post，并不是get，并且回调也不是json,而是xml,我们还是需要处理一下的.</p><p>在这个回调中,我们就可以处理自己的业务逻辑, 虽然微信出问题的可能性不大, 但是为了安全, 我们最好还是在这里跟自己的数据校验一下, 毕竟跟钱搭边了, 不得不谨慎一些. </p><p>END……</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin部署</title>
      <link href="/posts/8812/"/>
      <url>/posts/8812/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>使用gin开发完毕后，在服务器上运行(ps：也叫部署)，相关的资料比较少，因为呢，他实在是太方便了，简简单单啊，因为golang自动会利用多核，所以直接go build之后运行即可，不像python这种部署等于一个小手术了。但是需要注意的是，到时候更改啊或者配置什么，还得去找，分外的麻烦，所以最好统一的利用<code>linux</code>的服务去管理。</p></blockquote><p>简略流程如下：</p><ol><li><code>build</code>出一个可执行文件</li><li>写一个<code>sh</code>文件，用来执行这个文件</li><li>配置<code>service</code></li><li>启动</li><li>其他配置（反向代理、<code>ssl</code>证书等）</li></ol><h2 id="1、build-项目"><a href="#1、build-项目" class="headerlink" title="1、build 项目"></a>1、build 项目</h2><p>我的项目中，主文件为main.go，服务器主要使用的是linux系统，如果是其他请参考官方文档。<br>执行：</p><pre class="language-go" data-language="go"><code class="language-go">GOOS=linux GOARCH=amd64 go build</code></pre><p>则生成了一个新文件main<br>对其设置权限，这里用了777，因为有时候使用宝塔面板的时候，它的用户是www，正常情况下可以使用+x</p><pre class="language-go" data-language="go"><code class="language-go">chmod 777 main</code></pre><h2 id="2、写执行脚本-run-sh"><a href="#2、写执行脚本-run-sh" class="headerlink" title="2、写执行脚本 run.sh"></a>2、写执行脚本 run.sh</h2><p>新建一个文件</p><pre class="language-none"><code class="language-none">vim run.sh内容：#!/bin/bash# 设置为 release 生产模式export GIN_MODE=release# 切换到路径下，这样才能够使用和开发时候一样的相对路径cd main文件所在的绝对路径# 启动 build 后的可执行文件./main</code></pre><blockquote><p>如果项目内设置过生产模式就删掉GIN_MODE即可。</p></blockquote><p>里面路径自行替换。<br>这里有三点需要注意的地方：</p><ol><li>顶部的<code>#!/bin/bash</code><strong>必不可少</strong>，如果少了这个，服务会无法启动。</li><li>使用先<code>cd</code>后执行的方式，可以让程序能够找到相对路径下的文件。</li><li>run.sh也是需要权限的，可以``chmod +x run.sh`</li></ol><h2 id="3、创建一个-service-配置文件"><a href="#3、创建一个-service-配置文件" class="headerlink" title="3、创建一个 service 配置文件"></a>3、创建一个 service 配置文件</h2><pre class="language-go" data-language="go"><code class="language-go">vim /lib/systemd/system/mpgo.service</code></pre><p>其中<code>salmon</code>为服务名称，以后启动都是这个名称。</p><pre class="language-go" data-language="go"><code class="language-go">[Unit]Description=salmon[Service]Type=simpleRestart=alwaysRestartSec=3sExecStart=run.sh文件的完整路径[Install]WantedBy=multi-user.target</code></pre><ul><li><code>Description</code>是对这个服务的描述</li><li><code>Restart=always</code>服务异常退出时会重启</li><li><code>RestartSec=3s</code>设置重启间隔为<code>3</code>秒</li><li><code>ExecStart=run.sh文件的完整路径</code>这个服务会执行这个文件</li><li><code>WantedBy=multi-user.target</code>所有用户都可以执行</li></ul><h2 id="4、相关命令"><a href="#4、相关命令" class="headerlink" title="4、相关命令"></a>4、相关命令</h2><pre class="language-none"><code class="language-none">service salmon startservice salmon restartservice salmon stopservice salmon status</code></pre><p>当然也可以使用<code>systemctl</code></p><pre class="language-none"><code class="language-none">systemctl start salmonsystemctl restart salmonsystemctl stop salmonsystemctl status salmon</code></pre><h2 id="5、配置反向代理和ssl证书"><a href="#5、配置反向代理和ssl证书" class="headerlink" title="5、配置反向代理和ssl证书"></a>5、配置反向代理和ssl证书</h2><p>这里推荐直接安装宝塔，里面有图形化界面操作。也可以手动操作nginx，效果一样了。</p><ol><li><strong>反向代理：</strong><br> 新建静态网站 –&gt; 绑定域名 –&gt; 网站设置中的反向代理 –&gt; 代理<code>80</code>端口到<code>golang</code>的端口</li><li><strong><code>ssl</code>证书</strong><br> 宝塔面板中可以一键申请。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlalchemy异步操作</title>
      <link href="/posts/50945/"/>
      <url>/posts/50945/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>sqlalchemy在1.4版本也终于是支持了异步，同时他也是更新了很多2.0操作，本文就以异步orm的方式来操作mysql，感受一下异步的魅力。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>首先就是要保证你的sqlalchemy是1.4以上的，同时，pymysql等驱动也不支持异步，所以要改用新的驱动。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">pip install sqlalchemy==1.4.1pip install aiomysql</code></pre><p>连接方式与之前略有不同，主要是驱动的转换，不过有关异步的东西都在<code>sqlalchemy.ext.asyncio</code>里面，感兴趣的可以去看一下源码。<del>反正我是没兴趣了</del>。</p><p>创建会话的引擎，从create_engine改成了create_async_engine，配置上自己的参数即可。驱动我们用aiomysql代替pymysql</p><pre class="language-python" data-language="python"><code class="language-python">engine = create_async_engine(f"mysql+aiomysql://{MYSQL_USERNAME}:{MYSQL_PASSWORD}@{MYSQL_HOST}/{MYSQL_DATABASE}?charset=utf8mb4", pool_pre_ping=True)</code></pre><p>创建会话</p><pre class="language-python" data-language="python"><code class="language-python">SessionLocal = sessionmaker(class_=AsyncSession, autocommit=False, autoflush=False, bind=engine)</code></pre><p>简单封装一下使用，毕竟面向对象语言。</p><pre class="language-python" data-language="python"><code class="language-python">async def get_db() -&gt; Generator:    """    获取sqlalchemy    """    async with SessionLocal() as db:        yield db</code></pre><p>好了，那就简单查询一下。</p><pre class="language-python" data-language="python"><code class="language-python">async def get_series(db: AsyncSession):    res = await db.execute(select(User))    user = res.scalars().all()</code></pre><blockquote><p><em>scalars主要作用是把数据映射到orm类上去，不然得到的就是一行一行的查询结果</em></p></blockquote><p>可以分页，也可以获取单个结果，这都是基本操作了，有一些小变化，问题不大。</p><pre class="language-python" data-language="python"><code class="language-python">async def get_series(db: AsyncSession, size: int, page: int):    res = await db.execute(select(User).limit(size).offset((page - 1) * size))    user = res.scalars().all()'''series = res.scalars().first()'''</code></pre><h2 id="预加载字表"><a href="#预加载字表" class="headerlink" title="预加载字表"></a>预加载字表</h2><p>预加载主要有</p><h4 id="lazyload"><a href="#lazyload" class="headerlink" title="lazyload()"></a>lazyload()</h4><p>延迟加载 -可通过 lazy=‘select’ 或 lazyload() 选项实现。<br>这是默认的加载方式，当需要加载字表的时候再进行数据库访问，所以一对多的时候可能会出现多次访问数据库的问题。</p><h4 id="joinedload"><a href="#joinedload" class="headerlink" title="joinedload()"></a>joinedload()</h4><p>用于查询一对多，采用左加载left join。（如果要改为inner join ,则加参数**joinedload(User.addresses,innerjoin=True)**）<br>联合加载 -可通过 lazy=‘joined’ 或 joinedload() 选项，此加载形式将联接应用于给定的select语句，以便在同一结果集中加载相关行。联合预加载在 加入的热切装载 .</p><blockquote><p>注意：只能加载一个数据</p></blockquote><h4 id="subqueryload"><a href="#subqueryload" class="headerlink" title="subqueryload()"></a>subqueryload()</h4><p>子查询加载 -可通过 lazy=‘subquery’ 或 subqueryload() 选项，此加载形式发出第二个select语句，该语句重新声明嵌入在子查询中的原始查询，然后将该子查询联接到要加载的相关表，以一次加载相关集合/标量引用的所有成员。子查询预加载的详细信息位于 子查询预加载 .<br>多方关联数据集合很大时使用subqueryload，一次查询数量不超过500条则使用selectinload()更合适。<br>总共2条SQL语句，第1条查询user，第2条填充user.addresses，使用INNER JOIN，不改变一方查询结果，且子查询的字段仅为一方表主键<br>缺点：如果查询中使用了first、limit、offset，则必须同时使用order_by，否则可能产生错误结果</p><h4 id="selectinload"><a href="#selectinload" class="headerlink" title="selectinload()"></a>selectinload()</h4><p>用户查询多对一，加载时选择 -可通过 lazy=‘selectin’ 或 selectinload() 选项，此加载形式发出第二个（或更多）select语句，将父对象的主键标识符组装到in子句中，以便相关集合/标量引用的所有成员都按主键一次加载。加载中的选择详细信息位于 加载时选择 .<br>注意：可以加载多个数据<br>当要同时加载多个不同的多方关联表数据（及需要join多个表）时使用selectinload<br>总共1+（N / 500）条SQL语句，第1条查询user，第2条（及以后）填充user.addresses，不会产生笛卡尔积问题，不会多次join，无需order_by，性能高<br>缺点：一个SQL语句一次只能获取多方关联数据集合的500条数据，集合数据量超过500时，将每500个发出一个SQL<br>缺点：对于复合主键，selectin加载不是平台无关的，已知支持的DBAPI为PostgreSQL, MySQL, SQLite，对于不支持的DBAPI将抛异常</p><h4 id="raiseload"><a href="#raiseload" class="headerlink" title="raiseload()"></a>raiseload()</h4><p>如果进行了额外的加载查询，则报错。<br>加荷 -可通过 lazy=‘raise’ ， lazy=‘raise_on_sql’ ，或者 raiseload() 选项，此形式的加载在通常发生延迟加载的同时触发，除非它引发ORM异常以防止应用程序进行不需要的延迟加载。提升负载的介绍在 使用raiseload防止不需要的懒惰负载 .</p><h4 id="noload"><a href="#noload" class="headerlink" title="noload()"></a>noload()</h4><p>不进行加载，值直接赋值为空。<br>无负载 -可通过 lazy=‘noload’ ，或者 noload() 选项；此加载样式将属性转换为永远不会加载或具有任何加载效果的空属性。”“noload”是一个非常罕见的加载程序选项。</p><hr><p>鉴于异步方法，我建议要么使用立即加载要么就不要加载。<br>使用方法:</p><pre class="language-python" data-language="python"><code class="language-python">results = await db.execute(select(User).options(joinedload(Message.message_user)))user=results.scalars().all()</code></pre><blockquote><p>注意：记得配置relationship</p></blockquote><p>然后，测试一下连接查询</p><pre class="language-python" data-language="python"><code class="language-python">sql = select(Series.title, Suit.title).join(Series, Suit.series == Series.id, isouter=True).where(Series.id == 9).limit(size).offset((page - 1) * size)    res = await db.execute(sql)    series = res.all()</code></pre><p>注意一点，如果是连接查询的话，就不要用scalars了，否则只会取到一个<code>Series</code>对象。</p><p>查询函数func<br>对于count等查询方式，使用func进行查询，示例</p><pre class="language-python" data-language="python"><code class="language-python">from sqlalchemy import select, funcasync with db_session.begin():     total = (await db_session.execute(func.count(Message.id))).first()[0]</code></pre><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>修改只需要读取到相关的model，然后修改字段，然后执行flush即可，如下:</p><pre class="language-python" data-language="python"><code class="language-python">@t_route.get("/users")async def get_users(session: AsyncSession = Depends(get_db_session)):    async with session.begin():        result = await session.execute(            select(User)        )        f = result.scalars().first()        f.password=mininet        await session.flush()        return user_schema.from_orm(f)</code></pre><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><p>示例代码</p><pre class="language-python" data-language="python"><code class="language-python">@t_route.post("/group")async def create_group(name: str):    async with AsyncSession(engine) as session:        async with session.begin():            permission = Group(name=name)            session.add(permission)            await session.flush()    return True</code></pre><p>还有一种插入方式，也需要掌握（主要是orm的原生异步好像还缺了不少功能）</p><pre class="language-python" data-language="python"><code class="language-python">@t_route.post("/group")async def create_group(name: str):    async with AsyncSession(engine) as session:        async with session.begin():            await session.execute(Group.metadata.tables[Group.__tablename__],[{"name":name}]            )    return True</code></pre><h2 id="测试一下性能"><a href="#测试一下性能" class="headerlink" title="测试一下性能"></a>测试一下性能</h2><blockquote><p>既然费尽心力改成了异步，那自然是要试试他的性能的。就一张单表查询，做了分页查询，数据量不是很大的情况下。</p><p>测试使用的框架是fastapi，一个简单的查询，没有任何骚操作。我们继续使用鼎鼎有名的ApacheBench进行压测。</p></blockquote><img src="/posts/50945/image-20210816183238948.png" alt style="zoom:80%;" loading="lazy"><p>带数据库操作的情况下，qps100，消耗了二十秒，并且还有失败的。</p><blockquote><p>ps：就是因为看到了这个结果我才要励志要把他搞成异步的。</p></blockquote><p>好吧，虽然是单进程模式，但是这结果显然差劲。</p><p>用上了异步，我们再测一下</p><img src="/posts/50945/image-20210816183731230.png" alt style="zoom:80%;" loading="lazy"><p>尽管不是那么的正规压测，但是显而易见，在200qps的压测下，表现几乎要追上go了。<del>自我催眠</del></p><p>那，测一下go…，虽然python去找golang测速度有点找虐。</p><p>使用的gin框架，调整成生产模式单进程开始。</p><img src="/posts/50945/C838D920-F796-4E4E-9F56-1A80253362CE.png" alt style="zoom:80%;" loading="lazy"><p>额，好吧，差距还是巨大的，不找虐了。</p>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastAPI </tag>
            
            <tag> SQLAlchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin-vue搭建个人博客-10</title>
      <link href="/posts/52513/"/>
      <url>/posts/52513/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>后台页面写完，剩下的就是前端了，不过通过一个<a href="https://github.com/Groundhog-Chen/vue-material-admin">项目</a>发现了一个前端很好用的ui(ps:后悔用ant design了)，官方地址<a href="https://vuetifyjs.com/zh-Hans/getting-started/installation/#vue-cli-5b8988c5">在这</a>，<del>鬼知道我能写成什么样子</del></p></blockquote><p>创建好项目之后，直接使用<code>vue add vuetify</code>添加即可。</p><p>然后打开主页，看到主页已经成了这样，就是成功了。</p><img src="/posts/52513/image-20210723181229364.png" alt style="zoom:50%;" loading="lazy"><p>由于这个ui框架学起来有一定难度，在文档上即使有示例也不能像ant design这种开封即用，关于这个，还是需要一定的学习成本。不说了，先自闭一会儿。</p><p>N天后…</p><p>到此，推荐大家自己摸索，作为前端黑洞，我已经尽我所能了。<del>我就是懒啊</del>，我这个前端的技术着实有点吃力，再加上这个ui，哎，需要时间来巩固一下。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin-vue搭建个人博客-9</title>
      <link href="/posts/42530/"/>
      <url>/posts/42530/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>关于接口调用和页面的各种调优，都不必按部就班的按照这个样子来写。本来就是个小项目，作为一个前端菜鸟，我也在前进的路上，望知悉。</p></blockquote><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><blockquote><p>用来写文章的编辑器，写博客，我们都是使用的markdown，由于对前端的不熟悉，只能胡乱选一个。最终使用的是tinymce，文档<a href="http://tinymce.ax-z.cn/">在这</a>，这不是官方的。</p><p>⚠️！这是富文本编辑器，下面还有markdown编辑器， 两个都放出来了，可以按照个人喜好选择。</p></blockquote><ol><li><p>下载包<br> <a href="https://www.tiny.cloud/get-tiny/self-hosted/">网址</a>，从这里把<code>Download TinyMCE Community</code>下载下来，然后再下载一个<a href="https://www.tiny.cloud/get-tiny/language-packages/">语言包</a>，下载Chinese，不用说了</p></li><li><p>把tinymcew下的langs删了，替换成下载好的语言包，在couponents下新建一个文件夹<code>editor</code>，把这个文件夹放进去。</p></li><li><p>在editor下新建组件<code>index.vue</code></p> <pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;  &lt;div&gt;    &lt;Editor :init="init" v-model="content"&gt;&lt;/Editor&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Editor from '@tinymce/tinymce-vue'import './tinymce.min.js'import './icons/default/icons.min.js'import './themes/silver/theme.min.js'import './langs/zh_CN'// 注册插件import './plugins/preview/plugin.min.js'import './plugins/paste/plugin.min.js'import './plugins/wordcount/plugin.min.js'import './plugins/code/plugin.min.js'import './plugins/image/plugin.min.js'import './plugins/imagetools/plugin.min.js'import './plugins/media/plugin.min.js'import './plugins/codesample/plugin.min.js'import './plugins/lists/plugin.min.js'import './plugins/table/plugin.min.js'export default {  components: {Editor},  props: {    value: {      type: String,      default: '',    },  },  data() {    return {      init: {        language: 'zh_CN',        height: '600px',        plugins: 'preview paste wordcount code imagetools image media codesample lists table',        branding: false,        paste_data_images: true,        toolbar: [          'undo redo | styleselect |fontsizeselect| bold italic underline strikethrough |alignleft aligncenter alignright alignjustify |blockquote removeformat |numlist bullist table','preview paste code codesample |image media',        ],        //上传图片        images_upload_handler: async (blobInfo, succFun, failFun) =&gt; {          let formdata = new FormData()          formdata.append('file', blobInfo.blob(), blobInfo.name())          const { data: res } = await this.$http.post('api/admin/upload/', formdata)          succFun('http://localhost:8081/'+res.data)          failFun(this.$message.error('上传图片失败'))        },        imagetools_cors_hosts: ['*'],        imagetools_proxy: '',      },      content: this.value,    }  },  watch: {    value(newV) {      this.content = newV    },    content(newV) {      this.$emit('input', newV)    },  },}&lt;/script&gt;&lt;style scoped&gt;@import url('./skins/ui/oxide/skin.min.css');@import url('./skins/content/default/content.min.css');&lt;/style&gt;</code></pre></li></ol><p>在写完了富文本之后，我发现我搞错了一点。博客当然是要用markdown啊😭，我本以为没有markdown编辑器的，哎，怪我认知不好。于是在一顿搜罗之后，我找到了一个巨好用的markdown编辑器。<a href="https://github.com/hinesboy/mavonEditor">网址</a></p><pre class="language-none"><code class="language-none">npm install mavon-editor --save</code></pre><p>直接安装，安装完成之后，直接全局引入。在main.js中。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">import mavonEditor from "mavon-editor";import "mavon-editor/dist/css/index.css";Vue.use(mavonEditor);</code></pre><p>然后直接使用，github上提供了他很多方法，这里我们直接引用。再根据需要，修改一下上传文件的方法。就大功告成。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div&gt;&lt;a-card&gt;&lt;h3&gt;{{id?'编辑文章':'新增文章'}}&lt;/h3&gt;&lt;a-form-model :model="artInfo" ref="artInfoRef" :rules="artInfoRules" :hideRequiredMark="true"&gt;&lt;a-form-model-item label="文章标题" prop="title"&gt;&lt;a-input style="width:300px" v-model="artInfo.title"&gt;&lt;/a-input&gt;&lt;/a-form-model-item&gt;&lt;a-form-model-item style="width:200px"prop="cid"label="文章分类"&gt;&lt;a-select v-model="artInfo.cid" placeholder="请选择分类" @change="cateChange"&gt;&lt;a-select-option v-for="item in Catelist" :key="item.id" :value="item.id"&gt;{{item.name}}&lt;/a-select-option&gt;&lt;/a-select&gt;&lt;/a-form-model-item&gt;&lt;a-form-model-item label="文章描述" prop="desc"&gt;&lt;a-input type="textarea" v-model="artInfo.desc"&gt;&lt;/a-input&gt;&lt;/a-form-model-item&gt;&lt;a-form-model-item label="缩略图" prop="img"&gt; &lt;a-uploadname="file":multiple="false":action="uploadUrl":headers="headers"@change="upChange"listType="picture"&gt;&lt;a-button&gt; &lt;a-icon type="upload" /&gt; 上传图片 &lt;/a-button&gt;&lt;br/&gt;&lt;template v-if="id"&gt;&lt;img :src="artInfo.img" style="width:120px;height:100px"&gt;&lt;/template&gt;&lt;/a-upload&gt;&lt;/a-form-model-item&gt;&lt;a-form-model-item label="内容" prop="content"&gt;&lt;!-- &lt;Editor v-model="artInfo.content"&gt;&lt;/Editor&gt; --&gt;&lt;mavon-editor            ref="md"            placeholder="请输入文档内容..."            :boxShadow="false"            style="z-index:1;border: 1px solid #d9d9d9;height:50vh"            v-model="artInfo.content"            :toolbars="toolbars"@imgAdd="$imgAdd"          /&gt;&lt;/a-form-model-item&gt;&lt;a-form-model-item&gt;&lt;a-button type="primary" style="margin-right:15px" @click="artOk(artInfo.id)"&gt;{{artInfo.id?"更新":'提交'}}&lt;/a-button&gt;&lt;a-button type="danger" @click="addCancel"&gt;取消&lt;/a-button&gt;&lt;/a-form-model-item&gt;&lt;/a-form-model&gt;&lt;/a-card&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import {Url} from "../../plugins/http"import Editor from "../editor/index"export default {components:{Editor},props:['id'],data(){return{artInfo:{id:0,title:'',cid:undefined,desc:'',content:'',img:''},Catelist:[],uploadUrl:Url+'/api/admin/upload/',headers:{},artInfoRules: {        title: [{ required: true, message: '请输入文章标题', trigger: 'change' }],        cid: [{ required: true, message: '请选择文章分类', trigger: 'change' }],        desc: [          { required: true, message: '请输入文章描述', trigger: 'change' },          { max: 120, message: '描述最多可写120个字符', trigger: 'change' },        ],        content: [{ required: true, message: '请输入文章内容', trigger: 'change' }],      },// markdown对象toolbars: {        bold: true, // 粗体        italic: true, // 斜体        header: true, // 标题        underline: true, // 下划线        strikethrough: true, // 中划线        mark: true, // 标记        superscript: true, // 上角标        subscript: true, // 下角标        quote: true, // 引用        ol: true, // 有序列表        ul: true, // 无序列表        link: true, // 链接        imagelink: true, // 图片链接        code: true, // code        table: true, // 表格        fullscreen: true, // 全屏编辑        readmodel: true, // 沉浸式阅读        htmlcode: true, // 展示html源码        help: true, // 帮助        /* 1.3.5 */        undo: true, // 上一步        redo: true, // 下一步        trash: true, // 清空        save: false, // 保存（触发events中的save事件）        /* 1.4.2 */        navigation: true, // 导航目录        /* 2.1.8 */        alignleft: true, // 左对齐        aligncenter: true, // 居中        alignright: true, // 右对齐        /* 2.2.1 */        subfield: true, // 单双栏模式        preview: true // 预览      }}},created(){this.getCateList()this.headers = {Authorization:`Bearer ${window.sessionStorage.getItem('token')}`}if(this.id){this.getArtInfo(this.id)}},methods:{// 查询文章信息async getArtInfo(id){const {data: res} = await this.$http.get(`api/v1/article/${id}/`)if(res.code != 200) return this.$$message.error(res.msg)this.artInfo = res.datathis.artInfo.id = res.data.ID},// 获取分类    async getCateList() {      const { data: res } = await this.$http.get('api/v1/category/',{params: {          size: 100,          page: 1,        },})      if (res.code !== 200) return this.$message.error(res.msg)      this.Catelist = res.data    },cateChange(val){this.artInfo.cid = val},upChange(info){if (info.file.status !== 'uploading') {              }      if (info.file.status === 'done') {        this.$message.success('上传成功');const imgUrl = info.file.response.datathis.artInfo.img = imgUrl      } else if (info.file.status === 'error') {        this.$message.error(`上传失败`);      }},// 提交artOk(id){this.$refs.artInfoRef.validate(async (valid) =&gt; {if (!valid) return this.$message.error('参数验证未通过，请按要求录入文章内容')if (id === 0) {          const { data: res } = await this.$http.post('/api/admin/article/', this.artInfo)          if (res.code !== 200) return this.$message.error(res.msg)          this.$router.push('/admin/artlist')          this.$message.success('添加文章成功')        } else {          const { data: res } = await this.$http.put(`/api/admin/article/${id}/`, this.artInfo)          if (res.code !== 200) return this.$message.error(res.msg)          this.$router.push('/admin/artlist')          this.$message.success('更新文章成功')        }})},// 取消addCancel(){this.$refs.artInfoRef.resetFields()},// 上传图片方法    async $imgAdd(pos, $file) {var formdata = new FormData();formdata.append('file', $file);const {data: res} = await this.$http.post("/api/admin/upload/",formdata,{ 'Content-Type': 'multipart/form-data' })this.$refs.md.$imglst2Url([[pos, "http://localhost:8081/"+res.data]])    },}}&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>这样的话，我们以后修改起来也是很方便的，只是，在后台我们需要一个渲染库。</p><h2 id="渲染库"><a href="#渲染库" class="headerlink" title="渲染库"></a>渲染库</h2><blockquote><p>渲染库使用的是<a href="https://pkg.go.dev/github.com/gomarkdown/markdown#section-readme">这个</a></p></blockquote><p>安装</p><pre class="language-go" data-language="go"><code class="language-go">go get -u github.com/gomarkdown/markdown</code></pre><p>可以在utils下新建一个<code>Markdown.go</code>，写成工具函数。</p><pre class="language-go" data-language="go"><code class="language-go">package utilsimport ("github.com/gomarkdown/markdown""github.com/gomarkdown/markdown/html")// 渲染htmlfunc Render(data string) string {htmlFlags := html.CommonFlags | html.HrefTargetBlankopts := html.RendererOptions{Flags: htmlFlags}renderer := html.NewRenderer(opts)md := []byte(data)content := markdown.ToHTML(md, nil, renderer)return string(content)}</code></pre><p> 然后只需要在必要的地方来使用这个工具即可。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin-vue搭建个人博客-8</title>
      <link href="/posts/26339/"/>
      <url>/posts/26339/</url>
      
        <content type="html"><![CDATA[<h2 id="编辑新增等功能"><a href="#编辑新增等功能" class="headerlink" title="编辑新增等功能"></a>编辑新增等功能</h2><blockquote><p>使用ant-design的组件，关于引入和使用就不说了，把UserList.vue完整的代码放出来供大家参考，一些必要的地方也已经写好了注释，大部分代码都是重复的。和之前的有些许改变。后台也可以按照自己喜欢的风格来做。</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div&gt;&lt;a-card&gt;&lt;a-row :gutter="20"&gt;&lt;a-col :span="6"&gt;&lt;a-input-search v-model="queryParam.username"allowClear placeholder="请输入用户名" enter-button @search="getUserList" /&gt;&lt;/a-col&gt;&lt;a-col :span="4"&gt;&lt;a-button type="primary" @click="AddUserVisible = true"&gt;新增&lt;/a-button&gt;&lt;/a-col&gt;&lt;/a-row&gt;&lt;a-table:columns='columns' rowKey='ID':pagination="pagination":dataSource="userlist"bordered@change="handleTableChange"&gt;&lt;span slot="role" slot-scope="role"&gt;{{role == 1 ? "管理员":"订阅者"}}&lt;/span&gt;&lt;template slot="action" slot-scope="data"&gt;&lt;div class="actionSlot"&gt;&lt;a-button type="info" icon="info" style="margin-right:15px" @click="ChangePassword(data.ID)"&gt;修改密码&lt;/a-button&gt;&lt;a-button type="primary" icon="edit" style="margin-right:15px" @click="editUser(data.ID)"&gt;编辑&lt;/a-button&gt;&lt;a-popconfirm title="确认删除？删除后无法恢复" ok-text="确认" cancel-text="取消" @confirm="delUser(data.ID)"&gt;  &lt;a-button icon="delete" type="danger"&gt;删除&lt;/a-button&gt;&lt;/a-popconfirm&gt;&lt;/div&gt;&lt;/template&gt;&lt;/a-table&gt;&lt;/a-card&gt;&lt;!-- 新增用户对话框 --&gt;&lt;a-modal      title="新增用户"      :visible="AddUserVisible"      @ok="AddUserOk"      @cancel="addUserCanal"closable    &gt;      &lt;a-form-model :model="userinfo" :rules="userRules" ref="addUserRef"&gt;&lt;a-form-model-item label="用户名" prop="username"&gt;&lt;a-input v-model="userinfo.username"&gt;&lt;/a-input&gt;&lt;/a-form-model-item&gt;&lt;a-form-model-item label="密码" prop="password"&gt;&lt;a-input-password v-model="userinfo.password"&gt;&lt;/a-input-password&gt;&lt;/a-form-model-item&gt;&lt;a-form-model-item label="确认密码" prop="checkpass"&gt;&lt;a-input-password v-model="userinfo.checkpass"&gt;&lt;/a-input-password&gt;&lt;/a-form-model-item&gt;&lt;/a-form-model&gt;    &lt;/a-modal&gt;&lt;!-- 编辑用户 --&gt;&lt;a-modal      title="编辑用户"      :visible="editUserVisible"      @ok="editUserOk"width="60%"      @cancel="editUserCanal"closable    &gt;      &lt;a-form-model :model="userinfo" :rules="userRules" ref="addUserRef"&gt;&lt;a-form-model-item label="用户名" prop="username"&gt;&lt;a-input v-model="userinfo.username"&gt;&lt;/a-input&gt;&lt;/a-form-model-item&gt;&lt;a-form-model-item label="是否为管理员"&gt;          &lt;a-switch            :checked="IsAdmin"            checked-children="是"            un-checked-children="否"            @change="adminChange"          /&gt;        &lt;/a-form-model-item&gt;&lt;/a-form-model&gt;    &lt;/a-modal&gt;&lt;!-- 编辑密码 --&gt;&lt;a-modal      closable      title="修改密码"      :visible="changePasswordVisible"      width="60%"      @ok="changePasswordOk"      @cancel="changePasswordCancel"      destroyOnClose    &gt;      &lt;a-form-model :model="userinfo" :rules="userRules" ref="addUserRef"&gt;        &lt;a-form-model-item has-feedback label="密码" prop="password"&gt;          &lt;a-input-password v-model="userinfo.password"&gt;&lt;/a-input-password&gt;        &lt;/a-form-model-item&gt;        &lt;a-form-model-item has-feedback label="确认密码" prop="checkpass"&gt;          &lt;a-input-password v-model="userinfo.checkpass"&gt;&lt;/a-input-password&gt;        &lt;/a-form-model-item&gt;      &lt;/a-form-model&gt;    &lt;/a-modal&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;const columns = [{    title: 'ID',    dataIndex: 'ID',    key: 'id',    width: '10%',align:'center'  },{    title: '用户名',    dataIndex: 'username',    key: 'username',    width: '20%',align:'center'  },{    title: '角色',    dataIndex: 'role',    key: 'role',    width: '20%',scopedSlots:{customRender:'role'},align:'center'  },{    title: '操作',    key: 'action',    width: '30%',scopedSlots:{customRender:'action'},align:'center'  },]export default {data(){return{columns,changePasswordVisible: false,// 分页pagination: {        pageSizeOptions: ['5', '10', '20'],        pageSize: 5,        total: 0,        showSizeChanger: true,        showTotal: (total) =&gt; `共${total}条`,      },queryParam: {username:'',        pagesize: 5,        pagenum: 1,      },userlist:[],AddUserVisible:false,editUserVisible:false,userinfo:{id:0,username:'',password:'',checkpass:'',role:2},userRules:{username: [          {            validator: (rule, value, callback) =&gt; {              if (this.userinfo.username == '') {                callback(new Error('请输入用户名'))              }              if ([...this.userinfo.username].length &lt; 4 || [...this.userinfo.username].length &gt; 12) {                callback(new Error('用户名应当在4到12个字符之间'))              } else {                callback()              }            },            trigger: 'blur',          },        ],        password: [          {            validator: (rule, value, callback) =&gt; {              if (this.userinfo.password == '') {                callback(new Error('请输入密码'))              }              if ([...this.userinfo.password].length &lt; 6 || [...this.userinfo.password].length &gt; 20) {                callback(new Error('密码应当在6到20位之间'))              } else {                callback()              }            },            trigger: 'blur',          },        ],checkpass: [          {            validator: (rule, value, callback) =&gt; {              if (this.userinfo.checkpass == '') {                callback(new Error('请输入密码'))              }              if (this.userinfo.password !== this.userinfo.checkpass) {                callback(new Error('密码不一致，请重新输入'))              } else {                callback()              }            },            trigger: 'blur',          },        ],},}},created(){this.getUserList()},computed: {// 加载前布尔判断    IsAdmin: function () {      if (this.userinfo.role === 1) {        return true      } else {        return false      }    }},methods:{// 查询用户async getUserList(){const { data:res } = await this.$http.get('api/v1/user/', {params:{username: this.queryParam.username,size: this.queryParam.pagesize,page: this.queryParam.pagenum,},})if(res.code != 200)return this.$message.error(res.msg)this.userlist = res.datathis.pagination.total = res.total},// 分页handleTableChange(pagination, filters, sorter) {      var pager = { ...this.pagination }      pager.current = pagination.current      pager.pageSize = pagination.pageSize      this.queryParam.pagesize = pagination.pageSize      this.queryParam.pagenum = pagination.current      if (pagination.pageSize !== this.pagination.pageSize) {        this.queryParam.pagenum = 1        pager.current = 1      }      this.pagination = pager      this.getUserList()    },// 删除用户async delUser(id){  const { data: res } = await this.$http.delete(`api/admin/user/${id}/`)if(res.code != 200)return this.$message.error(res.msg)this.queryParam.pagenum = 1this.$message.success('删除成功')this.getUserList()},AddUserOk(){this.$refs.addUserRef.validate(async (vaild)=&gt;{if(!vaild)return this.$message.error("格式不正确")const { data: res } = await this.$http.post("api/v1/user/",{"username":this.userinfo.username,"password":this.userinfo.password,"role": this.userinfo.role,})if (res.code != 200) return this.$message.error(res.msg)// 清空搜索框this.$refs.addUserRef.resetFields()// 关闭弹窗        this.AddUserVisible = false        this.$message.success('添加用户成功')        this.getUserList()})},// role布尔值判断adminChange(checked){      if (checked) {        this.userinfo.role = 1      } else {        this.userinfo.role = 2      }},// 取消的方法addUserCanal(){this.$refs.addUserRef.resetFields()this.AddUserVisible = false},// 编辑框获取用户信息async editUser(id){this.editUserVisible = trueconst {data: res } = await this.$http.get(`/api/v1/user/${id}/`)this.userinfo = res.datathis.userinfo.id = id},// 编辑用户editUserOk(){this.$refs.addUserRef.validate(async (vaild)=&gt;{if(!vaild)return this.$message.error("格式不正确")const { data: res } = await this.$http.put(`/api/admin/user/${this.userinfo.id}/`,{"username":this.userinfo.username,"role": this.userinfo.role,})if (res.code != 200) return this.$message.error(res.msg)// 清空搜索框this.$refs.addUserRef.resetFields()// 关闭弹窗        this.editUserVisible = false        this.$message.success('编辑用户成功')        this.getUserList()})},// 取消编辑销毁数据editUserCanal(){this.$refs.addUserRef.resetFields()this.editUserVisible = false},// 修改密码获取信息ChangePassword(id){this.changePasswordVisible = true      this.userinfo.id = id},// 修改密码changePasswordOk() {      this.$refs.addUserRef.validate(async (valid) =&gt; {        if (!valid) return this.$message.error('参数不符合要求，请重新输入')        const { data: res } = await this.$http.put(`/api/admin/editpass/${this.userinfo.id}/`,{"password":this.userinfo.password})        if (res.code != 200) return this.$message.error(res.msg)        this.changePasswordVisible = false        this.$message.success('修改密码成功')        this.getUserList()      })    },// 修改密码取消changePasswordCancel() {      this.$refs.addUserRef.resetFields()      this.changePasswordVisible = false      this.$message.info('已取消')    },}}&lt;/script&gt;&lt;style&gt;.actionSlot{display: flex;justify-content: center;}&lt;/style&gt;</code></pre><h2 id="分类和文章列表页"><a href="#分类和文章列表页" class="headerlink" title="分类和文章列表页"></a>分类和文章列表页</h2><blockquote><p>CV大法好，只是在后端新增了一个搜索文章的功能。和搜索用户也是一样的啦。</p></blockquote><p><code>model/Article.go</code></p><pre class="language-go" data-language="go"><code class="language-go">// SearchArticle 搜索文章标题func SearchArticle(title string, pageSize int, pageNum int) ([]Article, int, int64) {var articleList []Articlevar err errorvar total int64err = Db.Select("article.id,title, img, created_at, updated_at, `desc`, comment_count, read_count, category.name").Limit(pageSize).Offset((pageNum-1)*pageSize).Order("Created_At DESC").Joins("Category").Where("title LIKE ?",title+"%",).Find(&amp;articleList).Error// 单独计数Db.Model(&amp;articleList).Count(&amp;total)if err != nil {return nil, errmsg.ERROR, 0}return articleList, errmsg.SUCCSE, total}</code></pre><p><code>/api/v1/article.go</code></p><pre class="language-go" data-language="go"><code class="language-go">// 查询文章列表func GetArticles(c *gin.Context)  {// 字符串转intSize,_ := strconv.Atoi(c.DefaultQuery("size","3"))Page,_ := strconv.Atoi(c.DefaultQuery("page","1"))title := c.Query("title")if len(title) == 0 {data, code, total := model.GetArticles(Size, Page)c.JSON(http.StatusOK, gin.H{"code":  code,"msg":   errmsg.GetErrorMsg(code),"data":  data,"total": total,})return}data, code, total := model.SearchArticle(title,Size,Page)c.JSON(http.StatusOK, gin.H{"code":  code,"data":    data,"total":   total,"msg": errmsg.GetErrorMsg(code),})}</code></pre><p>前端页面也放一下代码，闭着眼复制就可以了。</p><h3 id="components-article-ArtList-vue"><a href="#components-article-ArtList-vue" class="headerlink" title="components/article/ArtList.vue"></a><code>components/article/ArtList.vue</code></h3><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;  &lt;div&gt;    &lt;a-card&gt;      &lt;a-row :gutter="20"&gt;        &lt;a-col :span="6"&gt;          &lt;a-input-search            v-model="queryParam.title"            placeholder="输入文章名查找"            enter-button            allowClear            @search="getArtList"          /&gt;        &lt;/a-col&gt;        &lt;a-col :span="4"&gt;          &lt;a-button type="primary" @click="$router.push('addart')"&gt;新增&lt;/a-button&gt;        &lt;/a-col&gt;        &lt;a-col :span="3"&gt;          &lt;a-select placeholder="请选择分类" style="width: 200px" @change="CateChange"&gt;            &lt;a-select-option              v-for="item in Catelist"              :key="item.id"              :value="item.id"            &gt;{{ item.name }}&lt;/a-select-option&gt;          &lt;/a-select&gt;        &lt;/a-col&gt;        &lt;a-col :span="1"&gt;          &lt;a-button type="info" @click="getArtList()"&gt;显示全部&lt;/a-button&gt;        &lt;/a-col&gt;      &lt;/a-row&gt;      &lt;a-table        rowKey="ID"        :columns="columns"        :pagination="pagination"        :dataSource="Artlist"        bordered        @change="handleTableChange"      &gt;        &lt;span class="ArtImg" slot="img" slot-scope="img"&gt;          &lt;img :src="img" /&gt;        &lt;/span&gt;        &lt;template slot="action" slot-scope="data"&gt;          &lt;div class="actionSlot"&gt;            &lt;a-button              size="small"              type="primary"              icon="edit"              style="margin-right: 15px"              @click="$router.push(`addart/${data.ID}`)"            &gt;编辑&lt;/a-button&gt;&lt;a-popconfirm title="确认删除？删除后无法恢复" ok-text="确认" cancel-text="取消" @confirm="deleteArt(data.ID)"&gt;  &lt;a-button icon="delete" size="small" type="danger"&gt;删除&lt;/a-button&gt;&lt;/a-popconfirm&gt;          &lt;/div&gt;        &lt;/template&gt;      &lt;/a-table&gt;    &lt;/a-card&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import day from 'dayjs'const columns = [  {    title: 'ID',    dataIndex: 'ID',    width: '5%',    key: 'id',    align: 'center',  },  {    title: '更新日期',    dataIndex: 'UpdatedAt',    width: '10%',    key: 'UpdatedAt',    align: 'center',    customRender: (val) =&gt; {      return val ? day(val).format('YYYY年MM月DD日 HH:mm') : '暂无'    },  },  {    title: '分类',    dataIndex: 'Category.name',    width: '5%',    key: 'name',    align: 'center',  },  {    title: '文章标题',    dataIndex: 'title',    width: '15%',    key: 'title',    align: 'center',  },  {    title: '文章描述',    dataIndex: 'desc',    width: '20%',    key: 'desc',    align: 'center',  },  {    title: '缩略图',    dataIndex: 'img',    width: '20%',    key: 'img',    align: 'center',    scopedSlots: { customRender: 'img' },  },  {    title: '操作',    width: '15%',    key: 'action',    align: 'center',    scopedSlots: { customRender: 'action' },  },]export default {  data() {    return {      pagination: {        pageSizeOptions: ['5', '10', '20'],        pageSize: 5,        total: 0,        showSizeChanger: true,        showTotal: (total) =&gt; `共${total}条`,      },      Artlist: [],      Catelist: [],      columns,      queryParam: {        title: '',        pagesize: 5,        pagenum: 1,      },    }  },  created() {this.getCateList()    this.getArtList()  },  methods: {    // 获取文章列表    async getArtList() {      const { data: res } = await this.$http.get('api/v1/article/', {        params: {          title: this.queryParam.title,          size: this.queryParam.pagesize,          page: this.queryParam.pagenum,        },      })      if (res.code !== 200) {        if (res.code === 1004 || 1005 || 1006 || 1007) {          window.sessionStorage.clear()          this.$router.push('/login')        }        this.$message.error(res.message)      }      this.Artlist = res.data      this.pagination.total = res.total    },    // 获取分类    async getCateList() {      const { data: res } = await this.$http.get('api/v1/category/',{params: {          size: 100,          page: 1,        },})      if (res.code !== 200) return this.$message.error(res.msg)      this.Catelist = res.data      this.pagination.total = res.total    },    // 更改分页    handleTableChange(pagination, filters, sorter) {      var pager = { ...this.pagination }      pager.current = pagination.current      pager.pageSize = pagination.pageSize      this.queryParam.pagesize = pagination.pageSize      this.queryParam.pagenum = pagination.current      if (pagination.pageSize !== this.pagination.pageSize) {        this.queryParam.pagenum = 1        pager.current = 1      }      this.pagination = pager      this.getArtList()    },    // 删除文章    async deleteArt(id) {const { data: res } = await this.$http.delete(`api/admin/article/${id}/`)if (res.code != 200) return this.$message.error(res.msg)this.$message.success('删除成功')this.queryParam.pagenum = 1this.getArtList()    },    // 查询分类下的文章    CateChange(value) {      this.getCateArt(value)    },    async getCateArt(id) {      const { data: res } = await this.$http.get(`api/v1/catelist/${id}/`, {        params: { size: this.queryParam.pagesize, page: this.queryParam.pagenum },      })      if (res.code !== 200) return this.$message.error(res.msg)      this.Artlist = res.data      this.pagination.total = res.total    },  },}&lt;/script&gt;&lt;style scoped&gt;.actionSlot {  display: flex;  justify-content: center;}.ArtImg {  height: 100%;  width: 100%;}.ArtImg img {  width: 100px;  height: 80px;}&lt;/style&gt;</code></pre><h3 id="components-category-CateList-vue"><a href="#components-category-CateList-vue" class="headerlink" title="components/category/CateList.vue"></a><code>components/category/CateList.vue</code></h3><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div&gt;&lt;a-card&gt;&lt;a-row :gutter="20"&gt;&lt;a-col :span="4"&gt;&lt;a-button type="primary" @click="AddcateVisible = true"&gt;新增分类&lt;/a-button&gt;&lt;/a-col&gt;&lt;/a-row&gt;&lt;a-table:columns='columns' rowKey='id':pagination="pagination":dataSource="catelist"bordered@change="handleTableChange"&gt;&lt;template slot="action" slot-scope="data"&gt;&lt;div class="actionSlot"&gt;&lt;a-button type="primary" icon="edit" style="margin-right:15px" @click="editcate(data.id)"&gt;编辑&lt;/a-button&gt;&lt;a-popconfirm title="确认删除？删除后无法恢复" ok-text="确认" cancel-text="取消" @confirm="delcate(data.id)"&gt;  &lt;a-button icon="delete" type="danger"&gt;删除&lt;/a-button&gt;&lt;/a-popconfirm&gt;&lt;/div&gt;&lt;/template&gt;&lt;/a-table&gt;&lt;/a-card&gt;&lt;!-- 新增分类对话框 --&gt;&lt;a-modal      title="新增分类"      :visible="AddcateVisible"      @ok="AddcateOk"      @cancel="addcateCanal"closable    &gt;      &lt;a-form-model :model="cateinfo" ref="addcateRef"&gt;&lt;a-form-model-item label="分类名" prop="name"&gt;&lt;a-input v-model="cateinfo.name"&gt;&lt;/a-input&gt;&lt;/a-form-model-item&gt;&lt;/a-form-model&gt;    &lt;/a-modal&gt;&lt;!-- 编辑分类 --&gt;&lt;a-modal      title="编辑分类"      :visible="editcateVisible"      @ok="editcateOk"width="60%"      @cancel="editcateCanal"closable    &gt;      &lt;a-form-model :model="cateinfo" ref="addcateRef"&gt;&lt;a-form-model-item label="分类名" prop="name"&gt;&lt;a-input v-model="cateinfo.name"&gt;&lt;/a-input&gt;&lt;/a-form-model-item&gt;&lt;/a-form-model&gt;    &lt;/a-modal&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;const columns = [{    title: 'ID',    dataIndex: 'id',    key: 'id',    width: '10%',align:'center'  },{    title: '分类名',    dataIndex: 'name',    key: 'name',    width: '20%',align:'center'  },{    title: '操作',    key: 'action',    width: '30%',scopedSlots:{customRender:'action'},align:'center'  },]export default {data(){return{columns,changePasswordVisible: false,// 分页pagination: {        pageSizeOptions: ['5', '10', '20'],        pageSize: 5,        total: 0,        showSizeChanger: true,        showTotal: (total) =&gt; `共${total}条`,      },queryParam: {name:'',        pagesize: 5,        pagenum: 1,      },catelist:[],AddcateVisible:false,editcateVisible:false,cateinfo:{id:0,name:'',},}},created(){this.getcateList()},methods:{// 查询分类async getcateList(){const { data:res } = await this.$http.get('api/v1/category/', {params:{size: this.queryParam.pagesize,page: this.queryParam.pagenum,},})if(res.code != 200)return this.$message.error(res.msg)this.catelist = res.datathis.pagination.total = res.total},// 分页handleTableChange(pagination, filters, sorter) {      var pager = { ...this.pagination }      pager.current = pagination.current      pager.pageSize = pagination.pageSize      this.queryParam.pagesize = pagination.pageSize      this.queryParam.pagenum = pagination.current      if (pagination.pageSize !== this.pagination.pageSize) {        this.queryParam.pagenum = 1        pager.current = 1      }      this.pagination = pager      this.getcateList()    },// 删除分类async delcate(id){  const { data: res } = await this.$http.delete(`api/admin/category/${id}/`)if(res.code != 200)return this.$message.error(res.msg)this.$message.success('删除成功')this.queryParam.pagenum = 1this.getcateList()},async AddcateOk(){const { data: res } = await this.$http.post("api/admin/category/",{"name":this.cateinfo.name,})if (res.code != 200) return this.$message.error(res.msg)// 清空搜索框this.$refs.addcateRef.resetFields()// 关闭弹窗        this.AddcateVisible = false        this.$message.success('添加成功')        this.getcateList()},// 取消的方法addcateCanal(){this.$refs.addcateRef.resetFields()this.AddcateVisible = false},// 编辑框获取分类信息async editcate(id){this.editcateVisible = trueconst {data: res } = await this.$http.get(`/api/v1/category/${id}/`)this.cateinfo = res.datathis.cateinfo.id = id},// 编辑分类async editcateOk(){const { data: res } = await this.$http.put(`/api/admin/category/${this.cateinfo.id}/`,{"name":this.cateinfo.name,})if (res.code != 200) return this.$message.error(res.msg)// 清空搜索框this.$refs.addcateRef.resetFields()// 关闭弹窗        this.editcateVisible = false        this.$message.success('编辑成功')        this.getcateList()},// 取消编辑销毁数据editcateCanal(){this.$refs.addcateRef.resetFields()this.editcateVisible = false},}}&lt;/script&gt;&lt;style&gt;.actionSlot{display: flex;justify-content: center;}&lt;/style&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin-vue搭建个人博客-7</title>
      <link href="/posts/25251/"/>
      <url>/posts/25251/</url>
      
        <content type="html"><![CDATA[<h2 id="公共子组件编写"><a href="#公共子组件编写" class="headerlink" title="公共子组件编写"></a>公共子组件编写</h2><blockquote><p>头部组件</p></blockquote><p><code>components/admin/Header.vue</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;a-popconfirm title="确认退出？" ok-text="是" cancel-text="否" @confirm="loginout"&gt;&lt;a-button type="danger"&gt;登出&lt;/a-button&gt;&lt;!-- &lt;a href="#"&gt;Delete&lt;/a&gt; --&gt;&lt;/a-popconfirm&gt;&lt;/template&gt;&lt;script&gt;export default {methods:{loginout(){window.sessionStorage.clear('token')this.$router.push('/login')this.$message.success("感谢您的使用")}}}&lt;/script&gt;</code></pre><p>侧边栏组件</p><p><code>components/admin/Nav.vue</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;a-layout-sider breakpoint="lg" v-model="collapsed"&gt;&lt;div class="log"&gt;&lt;span&gt;{{collapsed? "blog":"Salmon Blog"}}&lt;/span&gt;&lt;/div&gt;&lt;a-menu theme="dark" mode="inline" @click="gotopage"&gt;&lt;a-menu-item key="index"&gt;&lt;a-icon type="dashboard"&gt;&lt;/a-icon&gt;&lt;span&gt;仪表盘&lt;/span&gt;&lt;/a-menu-item&gt;&lt;a-sub-menu&gt;&lt;span slot="title"&gt;&lt;a-icon type="file" /&gt;&lt;span&gt;文章管理&lt;/span&gt;&lt;/span&gt;&lt;a-menu-item key="addart"&gt; &lt;a-icon type="form"&gt;&lt;/a-icon&gt;&lt;span&gt;新增文章&lt;/span&gt;&lt;/a-menu-item&gt;&lt;a-menu-item key="artlist"&gt;&lt;a-icon type="snippets"&gt;&lt;/a-icon&gt;&lt;span&gt;文章列表&lt;/span&gt;&lt;/a-menu-item&gt;&lt;/a-sub-menu&gt;&lt;a-menu-item key="catelist"&gt;&lt;a-icon type="book"&gt;&lt;/a-icon&gt;&lt;span&gt;分类列表&lt;/span&gt;&lt;/a-menu-item&gt;&lt;a-menu-item key="userlist"&gt;&lt;a-icon type="user"&gt;&lt;/a-icon&gt;&lt;span&gt;用户列表&lt;/span&gt;&lt;/a-menu-item&gt;&lt;/a-menu&gt;&lt;/a-layout-sider&gt;&lt;/template&gt;&lt;script&gt;export default {data(){return{collapsed: false}},methods:{gotopage(item){this.$router.push('/admin/'+item.key).catch((err)=&gt;err)}}}&lt;/script&gt;&lt;style&gt;.log{height: 32px;margin: 16px;background-color: #fff;display: flex;justify-content: center;align-items: center;font-size: 17px;}&lt;/style&gt;</code></pre><p>页脚组件</p><p><code>components/admin/Footer.vue</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div class="footer"&gt;&lt;span&gt; -------Salmon------- &lt;/span&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {}&lt;/script&gt;&lt;style scoped&gt;.footer{background-color: aliceblue;text-align: center;height: 100%;}  .footer span{height: 100%;font-size: 20px;}&lt;/style&gt;</code></pre><h2 id="用户列表页编写"><a href="#用户列表页编写" class="headerlink" title="用户列表页编写"></a>用户列表页编写</h2><p><code>components/user/UserList.vue</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div&gt;&lt;h3&gt;用户列表页&lt;/h3&gt;&lt;a-card&gt;&lt;a-row :gutter="20"&gt;&lt;a-col :span="6"&gt;&lt;a-input-search placeholder="请输入用户名" enter-button /&gt;&lt;/a-col&gt;&lt;a-col :span="4"&gt;&lt;a-button type="primary"&gt;新增&lt;/a-button&gt;&lt;/a-col&gt;&lt;/a-row&gt;&lt;a-table :columns='columns' rowKey='username' :pagination="PaginationOption" :dataSource="userlist"bordered&gt;&lt;span slot="role" slot-scope="role"&gt;{{role == 1 ? "管理员":"订阅者"}}&lt;/span&gt;&lt;template slot="action"&gt;&lt;div class="actionSlot"&gt;&lt;a-button type="primary" style="margin-right:15px"&gt;编辑&lt;/a-button&gt;&lt;a-button type="danger"&gt;删除&lt;/a-button&gt;&lt;/div&gt;&lt;/template&gt;&lt;/a-table&gt;&lt;/a-card&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;const columns = [{    title: 'ID',    dataIndex: 'ID',    key: 'id',    width: '10%',align:'center'  },{    title: '用户名',    dataIndex: 'username',    key: 'username',    width: '20%',align:'center'  },{    title: '角色',    dataIndex: 'role',    key: 'role',    width: '20%',scopedSlots:{customRender:'role'},align:'center'  },{    title: '操作',    key: 'action',    width: '30%',scopedSlots:{customRender:'action'},align:'center'  },]export default {data(){return{columns,PaginationOption:{pageSizeOptions:['5','10','20'],defaultCurrent:1,defaultPageSize:5,total:0,showSizeChanger:true,showTotal:(total)=&gt;`共${total}条`,onChage:(page, pageSize)=&gt;{this.PaginationOption.defaultCurrent = pagethis.PaginationOption.defaultPageSize = pageSizethis.getUserList()},onshowSizeChange:(current, size)=&gt;{this.PaginationOption.defaultCurrent = currentthis.PaginationOption.defaultPageSize = sizethis.getUserList()}},userlist:[],}},created(){this.getUserList()},methods:{async getUserList(){const { data:res } = await this.$http.get('api/v1/user/', {params:{size:this.PaginationOption.defaultPageSize, page:this.PaginationOption.defaultCurrent},})if(res.code != 200)return this.$message.error(res.msg)this.userlist = res.datathis.PaginationOption.total = res.total}}}&lt;/script&gt;&lt;style&gt;.actionSlot{display: flex;justify-content: center;}&lt;/style&gt;</code></pre><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><blockquote><p>这里和之前的查看全部用户功能大部分是重复的，重构一下后端函数<code>model/User.go</code></p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func GetUsers(username string, Size int, Page int)([]User,int64)  {var users []Uservar total int64if username != ""{if username != "" {db.Select("id,username,role").Where("username LIKE ?", username+"%",).Limit(Size).Offset((Page - 1) * Size).Find(&amp;users)db.Model(&amp;users).Where("username LIKE ?", username+"%",).Count(&amp;total)return users, total}}// 分页err = db.Select("id,username,role").Offset((Page - 1) * Size).Limit(Size).Find(&amp;users).Errordb.Model(&amp;users).Count(&amp;total)if err != nil{return users,0}// 返回用户的列表return users,total}</code></pre><p>在接收的时候，接收一个username，绑定事件即可。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;a-col :span="6"&gt;  &lt;a-input-search v-model="queryParam.username"allowClear placeholder="请输入用户名" enter-button @search="getUserList" /&gt;&lt;/a-col&gt;</code></pre><h2 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h2><p>在删除按钮处添加弹窗和绑定事件</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template slot="action" slot-scope="data"&gt;&lt;div class="actionSlot"&gt;&lt;a-button type="primary" style="margin-right:15px"&gt;编辑&lt;/a-button&gt;&lt;a-popconfirm title="确认删除？删除后无法恢复" ok-text="确认" cancel-text="取消" @confirm="delUser(data.ID)"&gt;  &lt;a-button type="danger"&gt;删除&lt;/a-button&gt;&lt;/a-popconfirm&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;async delUser(id){  const { data: res } = await this.$http.delete(`api/admin/user/${id}/`)if(res.code != 200)return this.$message.error(res.msg)this.queryParam.pagenum = 1this.getUserList()}&lt;/script&gt;</code></pre><p>然后测试一下，ok，果然不行，忘了加权限的验证了。在main.js中，添加一个请求拦截器</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">// 请求拦截器axios.interceptors.request.use(config =&gt; {  config.headers.Authorization = `Bearer ${window.sessionStorage.getItem('token')}`  return config})</code></pre><p>这样的话，每次都会携带上这个token，用来验证。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin-vue搭建个人博客-6</title>
      <link href="/posts/1/"/>
      <url>/posts/1/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化前端项目"><a href="#初始化前端项目" class="headerlink" title="初始化前端项目"></a>初始化前端项目</h2><blockquote><p>前端项目分为后台管理和前端页面，先搞后台，毕竟没有后台写前台页面也不好受，安装node和vue就不用说了。直接初始化项目，在目录web下。</p><p>使用的UI是<a href="https://antdv.com/docs/vue/getting-started-cn/">ant-design</a></p></blockquote><pre class="language-none"><code class="language-none">vue create admincnpm install --save ant-design-vuecnpm install axios</code></pre><p>然后引入，在babel.config.js中：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">module.exports = {  presets: [    '@vue/cli-plugin-babel/preset'  ],plugins: [    [      "import",      { libraryName: "ant-design-vue", libraryDirectory: "es", style: 'css' }    ]  ]}</code></pre><p>可能引入会报错，如果报错<code>Error: Cannot find module 'babel-plugin-import'</code>，就执行<code>npm install antd babel-plugin-import --save</code>。</p><p>然后，最重要的一点！！！！大佬可以跳过，如果前端技术不是特别的强，一定要如此，在<code>package.json</code>文件中，把特喵的所有eslint有关的东西干掉！全都干掉！干掉他！！</p><p>或者找到<code>.eslintrc.js</code>的文件中,直接删除里边全部内容就可以了,但不要删除这个文件,否则会报错<code>Error: No ESLint configuration found.</code></p><p>写页面就没有这么多花里胡哨了，按照自己的想法来即可。</p><p>把该引入的引入，该注册的注册，剩下的就是慢慢码了。</p><p><code>login.vue</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;    &lt;div class="container"&gt;        &lt;div class="loginBox"&gt;            &lt;a-form-model ref="loginFormRef" :rules="rules" :model="formdata" class="loginForm"&gt;                &lt;a-form-model-item prop="username"&gt;                    &lt;a-input placeholder="账号" v-model="formdata.username"&gt;                        &lt;a-icon slot="prefix" type="user" style="color:rgba(0,0,0,.25)" /&gt;                    &lt;/a-input&gt;                &lt;/a-form-model-item&gt;                &lt;a-form-model-item prop="password"&gt;                    &lt;a-input placeholder="密码" type="password" v-model="formdata.password"&gt;                        &lt;a-icon slot="prefix" type="lock" style="color:rgba(0,0,0,.25)" /&gt;                    &lt;/a-input&gt;                &lt;/a-form-model-item&gt;                &lt;a-form-model-item class="loginButton"&gt;                    &lt;a-button type="primary" style="margin:10px" @click="login"&gt;登陆&lt;/a-button&gt;                    &lt;a-button type="info" style="margin:10px" @click="resetform"&gt;取消&lt;/a-button&gt;                &lt;/a-form-model-item&gt;            &lt;/a-form-model&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  data () {return {      formdata: {          username: '',          password: ''      },    rules: {          username: [              { required: true, message: '请输入管理员账号', trigger: 'blur' },              { min: 4, max: 12, message: '用户名长度为4-12个字符', trigger: 'blur' },          ],password: [              { required: true, message: '请输入密码', trigger: 'blur' },              { min: 6, max: 20, message: '密码长度为6-20个字符', trigger: 'blur' },          ],      }    }  },methods:{ resetform:function(){this.$refs.loginFormRef.resetFields() }, login:function(){ this.$refs.loginFormRef.validate(async valid=&gt;{ if(!valid) return this.$message.error("非法输入") const { data:res } = await this.$http.post('api/v1/login/', this.formdata) if(res.status != 200) return this.$message.error(res.message) window.sessionStorage.setItem("token", res.token) this.$router.push('admin') }) }}}&lt;/script&gt;&lt;style scoped&gt;    .container{        height: 100%;        background-color: aliceblue;    }    .loginBox{        width: 450px;        height: 300px;        background-color: white;        /* 绝对定位 */position: absolute;        top: 50%;        left: 70%;/* 旋转 */        transform: translate(-50%, -50%);/* 圆角 */        border-radius: 9px;    }    .loginForm{        width: 100%;        position: absolute;/* 距离底部边缘 */        bottom: 10%;        /* 设置内边距 */padding: 0 20px;        box-sizing: border-box;    }    .loginButton{        display: flex;/* 中央对齐 */        justify-content: flex-end;    }&lt;/style&gt;&gt;</code></pre><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>我们使用token来做验证，也要根据token来进行路由的守卫与拦截。</p><pre class="language-js" data-language="js"><code class="language-js">router.beforeEach((to, from , next)=&gt;{const token = window.sessionStorage.getItem('token')if(to.name == 'login') return next()if(!token &amp;&amp; to.name == 'admin'){next('login')}else{next()}})</code></pre><p> 解释一下这个路由守卫，由于后台管理页面我就只打算做两个页面，然后通过子页面的方式来进行各种操作，所以我们只拦截admin，如果没有token的话，访问admin直接拦截到login。</p><p>在compose下新建三个vue文件<code>Footer.vue</code>和<code>Nav.vue</code>和<code>Header.vue</code>来作为子组件进行解藕。</p><p>在views下新建admin.vue父组件</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;a-layout class="container"&gt;      &lt;a-layout-sider&gt;&lt;div class="log"&gt;&lt;span&gt;Salmon blog&lt;/span&gt;&lt;/div&gt;&lt;Nav&gt;&lt;/Nav&gt;&lt;/a-layout-sider&gt;      &lt;a-layout&gt;        &lt;a-layout-header class="headerBtn"&gt;&lt;a-button type="danger" @click="loginout"&gt;登出&lt;/a-button&gt;&lt;/a-layout-header&gt;        &lt;a-layout-content&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/a-layout-content&gt;        &lt;a-layout-footer&gt;&lt;Footer&gt;&lt;/Footer&gt;&lt;/a-layout-footer&gt;      &lt;/a-layout&gt;    &lt;/a-layout&gt;&lt;/template&gt;&lt;script&gt;import Footer from '../components/admin/Footer.vue'import Nav from '../components/admin/Nav.vue'export default {components:{Footer, Nav},methods:{loginout(){window.sessionStorage.clear('token')this.$router.push('/login')}}}&lt;/script&gt;&lt;style&gt;  .container {height: 100%;}.headerBtn{display: flex;justify-content: flex-end;align-items: center;}.log{height: 32px;margin: 16px;background-color: aliceblue;display: flex;justify-content: center;align-items: center;font-size: 17px;}&lt;/style&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin-vue搭建个人博客-5</title>
      <link href="/posts/25571/"/>
      <url>/posts/25571/</url>
      
        <content type="html"><![CDATA[<h2 id="日志的处理"><a href="#日志的处理" class="headerlink" title="日志的处理"></a>日志的处理</h2><p>使用的并不是gin框架自带的logger包，而是<code>logrus</code>，还用到了分割日志的包</p><pre class="language-none"><code class="language-none">go get github.com/sirupsen/logrus// 分割日志go get github.com/lestrrat-go/file-rotatelogs// 分段记录go get github.com/rifflock/lfshook</code></pre><p><a href="https://pkg.go.dev/github.com/sirupsen/logrus">文档</a></p><p><a href="https://zhuanlan.zhihu.com/p/78263242">资料</a></p><p>在根目录下新建一个log文件夹，然后在middleware下新建一个<code>logger.go</code>文件，来写日志中间件。</p><pre class="language-go" data-language="go"><code class="language-go">package middlewareimport ("fmt""github.com/gin-gonic/gin"retalog "github.com/lestrrat-go/file-rotatelogs""github.com/rifflock/lfshook""github.com/sirupsen/logrus""math""os""time")func Logger() gin.HandlerFunc {// 定义文件路径filePath := "log/blog.log"// 软连接路径(可以根据运维来进行调整)// linkName := "latest_log.log"// 初始化logger := logrus.New()// 定位到log文件夹(路径，os新建文件，赋值权限)src,err := os.OpenFile(filePath, os.O_RDWR|os.O_CREATE, 0755)if err!=nil {fmt.Println(err)}// 输出到日志文件中logger.Out = srclogger.SetLevel(logrus.DebugLevel)logWriter, _ := retalog.New(filePath+"%Y%m%d.log",retalog.WithMaxAge(7*24*time.Hour),retalog.WithRotationTime(24*time.Hour),// retalog.WithLinkName(linkName),)  // 日志级别writeMap := lfshook.WriterMap{logrus.InfoLevel:  logWriter,logrus.FatalLevel: logWriter,logrus.DebugLevel: logWriter,logrus.WarnLevel:  logWriter,logrus.ErrorLevel: logWriter,logrus.PanicLevel: logWriter,}  // 时间格式化分割Hook := lfshook.NewHook(writeMap, &amp;logrus.TextFormatter{TimestampFormat: "2006-01-02 15:04:05",})logger.AddHook(Hook)return func(c *gin.Context) {// 输出开始时间startTime := time.Now()c.Next()// 结束时间运行时间stopTime := time.Since(startTime)spendTime := fmt.Sprintf("%d ms", int(math.Ceil(float64(stopTime.Nanoseconds())/1000000.0)))// 主机名hostName, err := os.Hostname()if err != nil {hostName = "unKnown"}// 状态码statusCode := c.Writer.Status()// 客户端ipclientIP := c.ClientIP()// 客户端信息userAgent := c.Request.UserAgent()// 请求大小dataSize := c.Writer.Size()if dataSize &lt; 0{dataSize = 0}// 请求方法和路径method := c.Request.Methodpath := c.Request.RequestURI// 组合数据entry := logger.WithFields(logrus.Fields{"HostName":hostName,"Status":statusCode,"SpendTime":spendTime,"IP":clientIP,"Method":method,"Path":path,"DataSize":dataSize,"Agent": userAgent,})// 分级别if len(c.Errors) &gt; 0{entry.Error(c.Errors.ByType(gin.ErrorTypePrivate).String())}if statusCode &gt;= 500{entry.Error()}else if statusCode &gt;= 400{entry.Warn()}else {entry.Info()}}}</code></pre><p>然后将<code>router.go</code>下实例的r改为New方法</p><pre class="language-go" data-language="go"><code class="language-go">func InitRouter()  {gin.SetMode(utils.AppMode)r := gin.New()r.Use(middleware.Logger())r.Use(gin.Recovery())Auth := r.Group("api/admin")Auth.Use(middleware.JwtToken()){// User模块的路由接口Auth.PUT("user/:id/", v1.EditUser)Auth.DELETE("user/:id/", v1.DeleteUser)// Category模块的路由接口Auth.POST("category/", v1.AddCategory)Auth.PUT("category/:id/", v1.EditCategory)Auth.DELETE("category/:id/", v1.DeleteCategory)// Article模块的路由接口Auth.POST("article/", v1.AddArticle)Auth.PUT("article/:id/", v1.EditArticle)Auth.DELETE("article/:id/", v1.DeleteArticle)Auth.POST("upload/", v1.UploadFile)}router := r.Group("api/v1"){router.GET("user/", v1.GetUsers)Auth.POST("user/", v1.AddUser)router.POST("login/", v1.Login)router.GET("category/", v1.GetCategorys)router.GET("category/:id/", v1.GetCateInfo)router.GET("article/", v1.GetArticles)router.GET("article/:id/", v1.GetArticleInfo)router.GET("catelist/:id/", v1.GetCateArt)}_ = r.Run(utils.HttpPort)}</code></pre><h2 id="跨域配置与数据限制"><a href="#跨域配置与数据限制" class="headerlink" title="跨域配置与数据限制"></a>跨域配置与数据限制</h2><h4 id="数据限制"><a href="#数据限制" class="headerlink" title="数据限制"></a>数据限制</h4><pre class="language-go" data-language="go"><code class="language-go">go get github.com/go-playground/locales/zh_Hans_CN@v0.13.0go get github.com/gin-contrib/cors</code></pre><p>数据限制，改造<code>model/User.go</code>,添加validate。</p><pre class="language-go" data-language="go"><code class="language-go">type User struct {gorm.ModelUsername string `gorm:"type:varchar(20);not null " json:"username" validate:"required,min=4,max=12" label:"用户名"`Password string `gorm:"type:varchar(500);not null" json:"password" validate:"required,min=6,max=120" label:"密码"`Avatar string `gorm:"type:varchar(40);not null" json:"avatar" label:"头像"`Role     int    `gorm:"type:int;DEFAULT:2" json:"role" validate:"required,gte=2" label:"角色"`}</code></pre><p>在utils下，新建validator文件夹和文件</p><pre class="language-go" data-language="go"><code class="language-go">package validatorimport ("blog/utils/errmsg""fmt""github.com/go-playground/locales/zh_Hans_CN"unTrans "github.com/go-playground/universal-translator""github.com/go-playground/validator/v10"zhTrans "github.com/go-playground/validator/v10/translations/zh""reflect")func Validate(data interface{}) (string, int) {validate := validator.New()uni := unTrans.New(zh_Hans_CN.New())trans, _ := uni.GetTranslator("zh_Hans_CN")err := zhTrans.RegisterDefaultTranslations(validate, trans)if err != nil {fmt.Println("err:", err)}validate.RegisterTagNameFunc(func(field reflect.StructField) string {label := field.Tag.Get("label")return label})err = validate.Struct(data)if err != nil {for _, v := range err.(validator.ValidationErrors) {return v.Translate(trans), errmsg.ERROR}}return "", errmsg.SUCCSE}</code></pre><p>工具写好后，在<code>api/user.go</code>使用验证，保证添加的数据是正确的。</p><pre class="language-go" data-language="go"><code class="language-go">func AddUser(c *gin.Context)  {var data model.Uservar msg string_ = c.ShouldBindJSON(&amp;data)msg, code = validator.Validate(&amp;data)if code != errmsg.SUCCSE {c.JSON(http.StatusOK, gin.H{"status":  code,"message": msg,},)c.Abort()return}code = model.CheckUser(data.Username)if code == errmsg.SUCCSE {model.CreateUser(&amp;data)}if code == errmsg.ERROR_USERNAME_USED {code = errmsg.ERROR_USERNAME_USED}c.JSON(http.StatusOK,gin.H{"code":code,"msg":errmsg.GetErrorMsg(code),"data":data,})}</code></pre><h4 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h4><p>在middleware下，新建cors.go文件，编写跨域中间件</p><pre class="language-go" data-language="go"><code class="language-go">package middlewareimport ("github.com/gin-contrib/cors""github.com/gin-gonic/gin""time")func Cors() gin.HandlerFunc {return cors.New(cors.Config{AllowAllOrigins:  true,AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},AllowHeaders:     []string{"*"},ExposeHeaders:    []string{"Content-Length", "text/plain", "Authorization", "Content-Type"},AllowCredentials: true,MaxAge:           12 * time.Hour,},)}</code></pre><p>和之前的中间件一样在router中配置即可。</p><p>大体功能基本实现，在后期可能会加一些新的，不断的完善，不过目前这种程度就已经能够做一个博客了，后期项目先到此为止，然后前端的话，使用vue来做，未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seaweedfs详解+部署生产</title>
      <link href="/posts/44921/"/>
      <url>/posts/44921/</url>
      
        <content type="html"><![CDATA[<h2 id="seaweedfs架构"><a href="#seaweedfs架构" class="headerlink" title="seaweedfs架构"></a>seaweedfs架构</h2><p>SeaweedFS是一个分布式存储系统，用于存储blob、对象、文件和数据仓库。具有可预测的低延迟，具有O(1)磁盘寻道和灵活的数据。</p><img src="/posts/44921/image-20210701162215710.png" alt style="zoom:100%;" loading="lazy"><ul><li>Blob Storage 由主服务器、卷服务器和云层组成。</li><li>File Storage 由Blob存储和文件服务器组成。</li><li>Object Storage 由文件存储和S3服务器组成。</li><li>由File Storage和Hadoop兼容的库组成，由HDFS、Hadoop、Spark、Flink、Presto、HBA等使用。</li><li>FUSE Mount由装载到客户机上用户空间的文件存储组成，用于普通FUSE Mount、Kubernetes持久卷等。</li></ul><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>它代表一个由 1 个（或 3 个或更多服务器）组成的集群，这些服务器拥有整个 SeaweedFS 集群的一致视图，并通过 Raft 协议选出的 Leader 将其传达给所有参与节点。</p><p>主服务中的服务器数量必须始终为奇数，以确保可以形成多数共识。您最好保持这个数字不变，少量稳定的服务器比大量的 flakey 盒要好。1 或 3 是典型的。</p><p>通过定期的 raft 选举，从所有可用的主服务器中任意选择领导者。它分配文件 ID，指定存储对象的卷，并决定哪些节点是集群的一部分。</p><p>SeaweedFS 中的所有其他卷服务器都会向领导者发送心跳，领导者使用它们来决定将流量路由到哪里以及如何处理复制。</p><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>它将许多对象（文件和文件块）有效地打包到更大的单个卷中，这些卷可以是磁盘上的任意大块。数据的冗余和复制在卷级别进行管理，而不是在每个对象级别进行管理。</p><p>每个卷服务器通过主服务器将带有状态和卷信息的周期性心跳发送回领导者。</p><h3 id="Filer"><a href="#Filer" class="headerlink" title="Filer"></a>Filer</h3><p>它通过 HTTP 或 UNIX FUSE 挂载将 SeaweedFS 卷和对象组织到用户可见的路径（如 URL 或文件系统）中。</p><p>Filer 提供了一种方便且通用的抽象，可用于向现有应用程序提供正常外观的文件系统或用于下载/上传的 Web API，无需修改。</p><h3 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h3><p>此可选服务提供 AWS 风格的 S3 存储桶，类似于文件管理器服务。它可以单独启动，也可以与文件管理器一起启动。</p><h2 id="搭建服务"><a href="#搭建服务" class="headerlink" title="搭建服务"></a>搭建服务</h2><blockquote><p>这里还是使用docker，另外，如果要使用它官方自带的compose文件，需要再拉取一个普罗米修斯服务。不用的可以不拉取</p></blockquote><pre class="language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">docker pull chrislusf/seaweedfsdocker pull prom/prometheus</code></pre><p>然后，新建一个<code>docker-compose.yml</code>文件</p><pre class="language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">version: '2'services:  master:    image: chrislusf/seaweedfs # use a remote image    ports:      - 9333:9333      - 19333:19333    command: "master -ip=master"  volume:    image: chrislusf/seaweedfs # use a remote image    ports:      - 8080:8080      - 18080:18080      - 9325:9325    command: 'volume -mserver="master:9333" -port=8080  -metricsPort=9325'    depends_on:      - master  filer:    image: chrislusf/seaweedfs # use a remote image    ports:      - 8888:8888      - 18888:18888      - 9326:9326    command: 'filer -master="master:9333"  -metricsPort=9326'    tty: true    stdin_open: true    depends_on:      - master      - volume  cronjob:    image: chrislusf/seaweedfs # use a remote image    command: 'cronjob'    environment:      # Run re-replication every 2 minutes      CRON_SCHEDULE: '*/2 * * * * *' # Default: '*/5 * * * * *'      WEED_MASTER: master:9333 # Default: localhost:9333    depends_on:      - master      - volume  s3:    image: chrislusf/seaweedfs # use a remote image    ports:      - 8333:8333      - 9327:9327    command: 's3 -filer="filer:8888" -metricsPort=9327'    depends_on:      - master      - volume      - filer  webdav:    image: chrislusf/seaweedfs # use a remote image    ports:      - 7333:7333    command: 'webdav -filer="filer:8888"'    depends_on:      - master      - volume      - filer  prometheus:    image: prom/prometheus    ports:      - 9000:9090    volumes:      - ./prometheus:/etc/prometheus    command: --web.enable-lifecycle  --config.file=/etc/prometheus/prometheus.yml    depends_on:      - s3</code></pre><p>启动命令：</p><pre class="language-text" data-language="text"><code class="language-text">docker-compose -p seaweedfs up -d</code></pre><p>访问<code>localhost:9333</code>，就可以看到你的集群了，不过这样做的话，感觉还是在搞事情，文件没有持久化储存。emmmm….那我们还是挂载一下吧</p><pre class="language-text" data-language="text"><code class="language-text">docker run --name weed -d -p 9333:9333 -p 8080:8080 -p 18080:8080 -v /自己持久化文件路径/data:/data chrislusf/seaweedfs server -dir="/data"</code></pre><p>注意，此时是绝对路径。</p><p>这样一来，可以直接上生产了，compose是太过于完整了，实际上用的也无非就是上传文件和读取文件。emmmm。。。纠结怪，不知道该用compose还是直接用命令挂载，哎，都放出来吧。</p><pre class="language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">version: '2'services:  master:    image: chrislusf/seaweedfs # use a remote image    ports:      - 9333:9333      - 19333:19333    command: "master -ip=master "  volume:    image: chrislusf/seaweedfs # use a remote image    ports:      - 8080:8080      - 18080:18080      - 9325:9325    volumes:    - /挂载文件的地址/data:/data    command: 'volume -mserver="master:9333" -dir="./data" -port=8080  -metricsPort=9325'    depends_on:      - master</code></pre><pre class="language-none"><code class="language-none">docker rm $(sudo docker ps -a -q)把无用的容器清理一下</code></pre><p>ok，那么，剩下的就是客户端来连接了，不过seaweed是用go写的，那我们也使用go来连接。首先在<code>config.ini</code>下添加一个配置，如法炮制将其初始化。</p><pre class="language-none"><code class="language-none">SeaweedAddress = http://127.0.0.1:9333</code></pre><p>新建文件夹<code>goseaweed</code>，新建<code>interface.go</code>和<code>seaweed.go</code>。</p><p><code>seaweed.go</code></p><pre class="language-go" data-language="go"><code class="language-go">type seaweedFS struct {serverURL stringtimeout   time.Duration}type Res struct {Fid string `json:"fid"`}func NewSeaweedFs(serverURL string, timeout time.Duration) Seaweed {if timeout &lt;= 100 {timeout = time.Second * 10}return &amp;seaweedFS{serverURL: serverURL, timeout: timeout}}func (s *seaweedFS) UploadFile(objectName string, content []byte) (string, error) {// 拼接urlurl := fmt.Sprintf("%s/%s", s.serverURL, objectName)method := "POST"payload := &amp;bytes.Buffer{}writer := multipart.NewWriter(payload)err := writer.WriteField("file", bytes.NewBuffer(content).String())if err != nil {return "",errors.WithStack(err)}err = writer.Close()if err != nil {return "",errors.WithStack(err)}client := &amp;http.Client{Timeout: s.timeout}req, err := http.NewRequest(method, url, payload)if err != nil {return "",errors.WithStack(err)}req.Header.Set("Content-Type", writer.FormDataContentType())// 返回值res, _ := client.Do(req)// 将数据转换为jsonbody, err := ioutil.ReadAll(res.Body)result := string(body)var fid Res_ = json.Unmarshal([]byte(result),&amp;fid)if err != nil {return "",errors.WithStack(err)}if res.StatusCode != http.StatusCreated {defer res.Body.Close()body, err := ioutil.ReadAll(res.Body)if err != nil {return "",errors.WithStack(err)}return "",fmt.Errorf("create failed, response:%s", string(body))}return fid.Fid,nil}func (s *seaweedFS) GetFile(objectName string) ([]byte, error) {body, err := http.Get(fmt.Sprintf("%s/%s", s.serverURL, objectName))if err != nil {return nil, errors.WithStack(err)}defer body.Body.Close()return ioutil.ReadAll(body.Body)}func (s *seaweedFS) RemoveFile(objectName string) error {url := fmt.Sprintf("%s/%s", s.serverURL, objectName)method := "DELETE"client := &amp;http.Client{Timeout: s.timeout}req, err := http.NewRequest(method, url, nil)if err != nil {return errors.WithStack(err)}res, err := client.Do(req)if err != nil {return errors.WithStack(err)}if res.StatusCode != http.StatusNoContent {defer res.Body.Close()body, err := ioutil.ReadAll(res.Body)if err != nil {return errors.WithStack(err)}return fmt.Errorf("delete failed, response:%s", string(body))}return nil}</code></pre><p><code>interface.go</code></p><pre class="language-go" data-language="go"><code class="language-go">package goseaweedtype Seaweed interface {UploadFile(objectName string, content []byte)(string, error)GetFile(objectName string) ([]byte, error)RemoveFile(objectName string) error}</code></pre><p>可以用本地读文件的方式</p><pre class="language-go" data-language="go"><code class="language-go">func TestSeaweed() {log.SetFlags(log.Llongfile | log.LstdFlags)fs := NewSeaweedFs(utils.SeaweedAddress, time.Second*10)file, err := ioutil.ReadFile("/Users/salmon/demo/themes/hexo-theme-matery-develop/source/medias/logo.png")if err != nil {log.Fatalln(err)}if fid,err := fs.UploadFile("submit", file); err != nil {log.Fatalln(err)}else {fmt.Println(fid)}</code></pre><p>测试一下，ok，没有问题。文件服务器，没有必要非得用网络云盘等存储，自己搭建也是一个很好的方案，不仅可以磨练心态，更可以增进自己的技术。</p>]]></content>
      
      
      <categories>
          
          <category> 文件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin-vue搭建个人博客-4</title>
      <link href="/posts/c65d9901/"/>
      <url>/posts/c65d9901/</url>
      
        <content type="html"><![CDATA[<h2 id="登陆接口"><a href="#登陆接口" class="headerlink" title="登陆接口"></a>登陆接口</h2><blockquote><p>登陆验证，在web开发中算是很常见的东西了，关于这个东西，也不做过多解释了，我这里并没有使用cookie和session，使用了jwt，关于这个，在go官方的<a href="https://pkg.go.dev/golang.org/x/oauth2/jwt">网址</a>，下载即可</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">go get github.com/dgrijalva/jwt-go</code></pre><p>步骤也很简单，用密钥加密，然后返回给前端，前端访问其他接口的时候，通过中间件验证此token来确定用户身份。</p><p>所以，我们需要写一个加密函数。在<code>middleware/jwt.go</code>。首先去随便写一个jwt的key，也就是加密密钥，在config.ini中添加即可。然后和其他参数一样，在settings中解析。</p><pre class="language-go" data-language="go"><code class="language-go">/*config.ini*/[server]JwtKey = +d0(4=-$hy(cdl$tu^@509r#t$e60-1&amp;v$</code></pre><pre class="language-go" data-language="go"><code class="language-go">var JwtKey = []byte(utils.JwtKey)var code inttype MyClaims struct {Username string `json:"username"`jwt.StandardClaims}// 生成tokenfunc SetToken(username string) (string, int) {// 过期时间expirTime := time.Now().Add(10 * time.Hour)SetClaims := MyClaims{username,jwt.StandardClaims{// 过期时间ExpiresAt: expirTime.Unix(),// 签发人Issuer: "Salmon",},}// 参数：签发方法，签发命令reClaim := jwt.NewWithClaims(jwt.SigningMethodHS256, SetClaims)// 加签token,err := reClaim.SignedString(JwtKey)if err != nil{return "",errmsg.ERROR}return token,errmsg.SUCCSE}</code></pre><p>然后就是解密函数</p><pre class="language-go" data-language="go"><code class="language-go">// 验证tokenfunc CheckToken(token string) (*MyClaims, int) {settoken,_ := jwt.ParseWithClaims(token, &amp;MyClaims{}, func(token *jwt.Token) (interface{}, error) {return JwtKey,nil})if key,_ := settoken.Claims.(*MyClaims); settoken.Valid{return key,errmsg.SUCCSE}else {return nil,errmsg.ERROR}}</code></pre><p>最后把他写成一个中间件。</p><pre class="language-go" data-language="go"><code class="language-go">// jwt中间件func JwtToken() gin.HandlerFunc{return func(c *gin.Context) {    // 固定格式tokenHeader := c.Request.Header.Get("Authorizathion")    // 如果没有带token，则返回一个错误。if tokenHeader == ""{code = errmsg.ERROR_TOKEN_EXIST//c.Abort()}    // 分割参数checkToken := strings.SplitN(tokenHeader, " ", 2)if len(checkToken) != 2 &amp;&amp; checkToken[0] != "Bearer" {code = errmsg.ERROR_TOKEN_TYPE_WRONGc.Abort()}    // 解析token方法key,Tcode := CheckToken(checkToken[1])if Tcode == errmsg.ERROR {code = errmsg.ERROR_TOKEN_WRONGc.Abort()}    // 如果过期，则返回错误if time.Now().Unix() &gt; key.ExpiresAt{code = errmsg.ERROR_TOKEN_RUNTIMEc.Abort()}c.JSON(http.StatusOK, gin.H{"code":code,"msg":errmsg.GetErrorMsg(code),})c.Set("username", key.Username)c.Next()}}</code></pre><p>API接口：</p><pre class="language-go" data-language="go"><code class="language-go">func Login(c *gin.Context)  {var formData model.User_ = c.ShouldBindJSON(&amp;formData)var token stringvar code int// 验证用户名密码formData, code = model.CheckLogin(formData.Username, formData.Password)if code == errmsg.SUCCSE{// 成功则签发tokentoken, code = middleware.SetToken(formData.Username)}c.JSON(http.StatusOK, gin.H{"status":  code,"message": errmsg.GetErrorMsg(code),"token": token,})}</code></pre><p>最后把路由组给搞一下，注册一下中间件<code>routes/router.go</code></p><pre class="language-go" data-language="go"><code class="language-go">package routesimport (v1 "blog/api/v1""blog/middleware""blog/utils""github.com/gin-gonic/gin")func InitRouter()  {gin.SetMode(utils.AppMode)r := gin.Default()Auth := r.Group("")Auth.Use(middleware.JwtToken()){// User模块的路由接口Auth.PUT("user/:id/", v1.EditUser)Auth.DELETE("user/:id/", v1.DeleteUser)// Category模块的路由接口Auth.POST("category/", v1.AddCategory)Auth.PUT("category/:id/", v1.EditCategory)Auth.DELETE("category/:id/", v1.DeleteCategory)// Article模块的路由接口Auth.POST("article/", v1.AddArticle)Auth.PUT("article/:id/", v1.EditArticle)Auth.DELETE("article/:id/", v1.DeleteArticle)}router := r.Group("api/v1"){router.GET("user/", v1.GetUsers)Auth.POST("user/", v1.AddUser)router.POST("login/", v1.Login)router.GET("category/", v1.GetCategorys)router.GET("category/:id/", v1.GetCateInfo)router.GET("article/", v1.GetArticles)router.GET("article/:id/", v1.GetArticleInfo)router.GET("catelist/:id/", v1.GetCateArt)}_ = r.Run(utils.HttpPort)}</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><blockquote><p>关于文件上传，我选择使用seaweedfs，这是一个很牛掰的文件存储系统，并且他也是使用go写的，所以，都是一家人，<a href="https://github.com/chrislusf/seaweedfs">地址</a>，最后再使用docker一部署，go的一揽子服务。奈斯。</p></blockquote><p>关于部署seaweedfs和连接，请查看拙作<a href="https://www.godhearing.cn/posts/44921/">seaweedfs部署详解+部署生产</a>，这里的函数等都是我搭配着gin来使用的，在耦合方面没有什么难度。</p><pre class="language-go" data-language="go"><code class="language-go">package v1import ("blog/utils""blog/utils/errmsg""blog/utils/goseaweed""bytes""github.com/gin-gonic/gin""io""log""net/http""time")// 上传文件func UploadFile(c *gin.Context){file, _, _ := c.Request.FormFile("file")// 初始化fs := goseaweed.NewSeaweedFs(utils.SeaweedAddress, time.Second * 10)code = errmsg.SUCCSE// 转换数据类型为bytesbuf := bytes.NewBuffer(nil)if _, err := io.Copy(buf, file); err != nil {code = errmsg.ERROR}fid,err := fs.UploadFile("submit",buf.Bytes())// 上传文件if  err != nil {log.Fatalln(err)}c.JSON(http.StatusOK,gin.H{"code":code,"msg": errmsg.GetErrorMsg(code),"data": fid,})}</code></pre><p>后端接口方面还有诸多问题，不过我以实现功能为目的，先暂时这样，之后再慢慢补充。</p><p>未完待续….</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin-vue搭建个人博客-3</title>
      <link href="/posts/41378/"/>
      <url>/posts/41378/</url>
      
        <content type="html"><![CDATA[<h2 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h2><blockquote><p>密码加密用到了一个go内置的包<code>crypto</code>，不需要安装，官网地址在<a href="https://pkg.go.dev/golang.org/x/crypto/scrypt">这里</a>，代码也很简单，通过使用GORM的钩子函数，可以直接进行哈希，同样的，在<code>models/User.go</code>下：</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">// 密码加密func ScryptPw(password string) string {const cost = 10HashPw, err := bcrypt.GenerateFromPassword([]byte(password), cost)if err != nil {log.Fatal(err)}return string(HashPw)}// BeforeCreate 密码加密&amp;权限控制func (u *User) BeforeCreate(_ *gorm.DB) (err error) {u.Password = ScryptPw(u.Password)u.Role = 2return nil}</code></pre><h2 id="分类CURD"><a href="#分类CURD" class="headerlink" title="分类CURD"></a>分类CURD</h2><blockquote><p>直接复用代码即可，没啥难度，就不放轮子了。</p></blockquote><h2 id="文章CURD"><a href="#文章CURD" class="headerlink" title="文章CURD"></a>文章CURD</h2><blockquote><p>同样的，复用代码，只是在查询时，需要用到外键的关联查询。</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">// 分类下所有文章func GetCateArt(cid int, Size int, Page int)([]Article, int){var cateArtList []Articleerr = db.Preload("Category").Limit(Size).Offset((Page - 1) * Size).Where("cid=?", cid).Find(&amp;cateArtList).Errorif err != nil{return nil,errmsg.ERROR_CATE_NOT_EXIST}return cateArtList, errmsg.SUCCSE}// 单个文章func ArticleInfo(id int) (Article, int) {var art Articleerr = db.Preload("Category").Where("id=?",id).First(&amp;art).Errorif err != nil{return art, errmsg.ERROR_ART_NOT_EXIST}return art, errmsg.SUCCSE}</code></pre><p>大部分都是重复的代码，改一下结构体即可，这个应该没啥难度，就不放一大堆无效代码了。</p><p>未完待续….</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin-vue搭建个人博客-2</title>
      <link href="/posts/24931/"/>
      <url>/posts/24931/</url>
      
        <content type="html"><![CDATA[<h2 id="错误定义"><a href="#错误定义" class="headerlink" title="错误定义"></a>错误定义</h2><p>定义错误码和输出，在utils下，新建一个文件夹errmsg，注意，文件夹！在文件夹下再新建<code>errmsg.go</code>，为什么要这样做呢，因为在同一个文件夹下，只能允许存在一个package，我们在utils下，只能使用utils，所以，新建一个errmsg，我们就可以使用errmsg这个包名。</p><pre class="language-go" data-language="go"><code class="language-go">package errmsg// 定义一些常量，用来指定错误码。const (SUCCSE = 200ERROR  = 500// code=1XXX，用户模块错误ERROR_USERNAME_USED = 1001ERROR_PASSWORD_WRONG = 1002ERROR_USER_NOT_EXIST = 1003ERROR_TOKEN_EXIST = 1004ERROR_TOKEN_RUNTIME = 1005ERROR_TOKEN_WRONG = 1006ERROR_TOKEN_TYPE_WRONG = 1007// code=2XXX，文章模块错误// code=3XXX，分类模块错误)// 定义一个map，用来接收状态码来输入错误信息var CodeMsg = map[int]string{SUCCSE:                 "OK",ERROR:                  "FAIL",ERROR_USERNAME_USED:    "用户名已存在！",ERROR_PASSWORD_WRONG:   "密码错误",ERROR_USER_NOT_EXIST:   "用户不存在",ERROR_TOKEN_EXIST:      "TOKEN不存在,请重新登陆",ERROR_TOKEN_RUNTIME:    "TOKEN已过期,请重新登陆",ERROR_TOKEN_WRONG:      "TOKEN不正确,请重新登陆",ERROR_TOKEN_TYPE_WRONG: "TOKEN格式错误,请重新登陆",}// 定义一个方法，来接收状态吗输出错误信息func GetErrorMsg(code int)string  {return CodeMsg[code]}</code></pre><h2 id="用户create-get"><a href="#用户create-get" class="headerlink" title="用户create/get"></a>用户create/get</h2><blockquote><p>写业务逻辑接口，每个人都有每个人的习惯，这里我按照我的习惯写一下，这部分如果熟悉gorm的使用或者有其他想法的道友就可以跳过啦。</p><p>不过注意，此时的用户添加注册不是最终形态，因为最起码的密码还没有加密，所以后期还需要慢慢的来补。暂时先如此。</p></blockquote><ol><li>首先在<code>model/User.go</code>下，新添加几个操作数据库函数，这里只针对于数据库的GORM操作，并不关API的事。</li></ol><pre class="language-go" data-language="go"><code class="language-go">// 存在性判断func CheckUser(name string)(code int) {var users User// 查询用户是否存在db.Where("username=?",name).First(users)if users.ID &gt; 0 {// 如果存在则引出错误return errmsg.ERROR_USERNAME_USED}// 不存在则输入正确return errmsg.SUCCSE}// 添加用户func CreateUser(data *User)int  {// 添加时接收一下错误err := db.Create(&amp;data).Errorif err!=nil {return errmsg.ERROR}return errmsg.SUCCSE}// 用户列表func GetUsers(PageSize int, PageNum int)[]User  {var users []User// 分页err = db.Limit(PageSize).Offset((PageNum - 1) * PageSize).Find(&amp;users).Errorif err != nil &amp;&amp; err != gorm.ErrRecordNotFound {return nil}// 返回用户的列表return users}</code></pre><ol start="2"><li>在<code>api/v1/user.go</code>下，添加API代码：</li></ol><pre class="language-go" data-language="go"><code class="language-go">var code int// 添加用户func AddUser(c *gin.Context)  {  // 接收用户数据，放在data里var data model.User_ = c.ShouldBindJSON(&amp;data)  // 查看是否存在，不存在则添加code = model.CheckUser(data.Username)if code == errmsg.SUCCSE {model.CreateUser(&amp;data)}  // 如果存在，则返回错误码if code == errmsg.ERROR_USERNAME_USED {code = errmsg.ERROR_USERNAME_USED}c.JSON(http.StatusOK,gin.H{"code":code,"msg":errmsg.GetErrorMsg(code),"data":data,})}// 查询多个用户func GetUsers(c *gin.Context)  {// 字符串转int，如果不传，默认值按照需求设置PageSize,_ := strconv.Atoi(c.DefaultQuery("pagesize","3"))PageNum,_ := strconv.Atoi(c.DefaultQuery("pagenum","1"))data := model.GetUsers(PageSize,PageNum)code = errmsg.SUCCSEc.JSON(http.StatusOK,gin.H{"code":code,"msg":errmsg.GetErrorMsg(code),"data":data,})}</code></pre><p>有个小问题，如果用户存在，且状态码返回了，但是返回的同时有他输入的数据，还有User这个结构体的数据结构，很不安全，掌握了接口之后，有心之人很可能会通过篡改数据等方法威胁到数据库安全。暂时先这样，还得研究一下。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin-vue搭建个人博客-1</title>
      <link href="/posts/24611/"/>
      <url>/posts/24611/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>一直想自己搭建属于自己的个人的web博客，以此来记录一下过程。</p></blockquote><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><blockquote><p>可以在gitee或者github建一个仓库，然后初始化项目到本地即可。</p></blockquote><ol><li>gin框架项目结构，我大体分为了这几个部分</li></ol><ul><li>api是逻辑代码，都会放到这里</li><li>config是配置文件</li><li>middleware：中间件</li><li>model：orm模型</li><li>routes：路由</li><li>upload：上传的静态文件，后期会改成线上或者自己搭建的静态服务器</li><li>utils：工具，一些通用的代码会放在这里</li><li>web：前端项目</li></ul><img src="/posts/24611/image-20210625111022689.png" style="zoom:50%;" loading="lazy"><p>定义好自己的项目结构，然后新建一个main.go。</p><p>包管理工具，我使用的是mod。</p><pre class="language-go" data-language="go"><code class="language-go">go mod init 项目名</code></pre><ol start="2"><li><p>然后安装gin框架，请观看这篇<a href="https://www.godhearing.cn/posts/77/">文章</a></p></li><li><p>配置文件，使用的是ini文件，官网地址在<a href="https://ini.unknwon.io/docs">这里</a>，命令为</p> <pre class="language-go" data-language="go"><code class="language-go">go get gopkg.in/ini.v1</code></pre></li><li><p>在<code>config</code>下新建<code>config.ini</code>文件，定义自己的服务端口和数据库信息</p> <pre class="language-ini" data-language="ini"><code class="language-ini">[server]# 默认为debug模式，生产使用release模式AppMode = debugHttpPort = :8020[database]Db = mysqlDbHost = 127.0.0.1DbPort = 3306DbUser = rootDbPassWord = rootDbName = blogdb</code></pre></li><li><p>在utils下新建<code>settings.go</code>，来引入ini配置</p> <pre class="language-go" data-language="go"><code class="language-go">import ("fmt""gopkg.in/ini.v1")var (AppMode stringHttpPort stringDb         stringDbHost     stringDbPort     stringDbUser     stringDbPassWord stringDbName     string)// 初始化的函数func init() {file, err := ini.Load("config/config.ini")if err != nil {fmt.Println("配置文件读取错误，请检查路径", err)  }LoadServer(file)LoadData(file)}// 服务端配置func LoadServer(file *ini.File) {AppMode = file.Section("server").Key("AppMode").MustString("debug")HttpPort = file.Section("server").Key("HttpPort").MustString(":8020")}// 数据库配置func LoadData(file *ini.File) {Db = file.Section("database").Key("Db").MustString("debug")DbHost = file.Section("database").Key("DbHost").MustString("localhost")DbPort = file.Section("database").Key("DbPort").MustString("3306")DbUser = file.Section("database").Key("DbUser").MustString("root")DbPassWord = file.Section("database").Key("DbPassWord").MustString("root")DbName = file.Section("database").Key("DbName").MustString("blogdb")}</code></pre></li><li><p>然后测试一下路由版本管理，在<code>routes</code>下新建<code>router.go</code>文件，把InitRouter函数添加到main.go下的main函数中。</p> <pre class="language-go" data-language="go"><code class="language-go">import ("blog/utils""github.com/gin-gonic/gin""net/http")func InitRouter()  {gin.SetMode(utils.AppMode)r := gin.Default()router := r.Group("api/v1"){router.GET("hello/", func(c *gin.Context) {c.JSON(http.StatusOK,gin.H{"msg":"ok",})})}r.Run(utils.HttpPort)}</code></pre><p> 启动项目，<code>go run main.go</code>，访问一下<code>localhost:8020/api/v1/hello/</code>，显示ok，成功。</p></li></ol><h2 id="ORM迁移数据库"><a href="#ORM迁移数据库" class="headerlink" title="ORM迁移数据库"></a>ORM迁移数据库</h2><blockquote><p>orm我使用的是文档最为全面的GORM，在更新到了GORM2之后，和之前的版本有些许不同，为此，我也不搬砖了，<a href="https://www.godhearing.cn/posts/33181/">地址</a></p></blockquote><p>在<code>model</code>下新建三个文件(User.go、Category.go、Article.go)来定义我们的模型，也就是表。</p><p>User.go:</p><pre class="language-go" data-language="go"><code class="language-go">import "gorm.io/gorm"type User struct {gorm.ModelUsername string `gorm:"type:varchar(20);not null " json:"username" validate:"required,min=4,max=12" label:"用户名"`Password string `gorm:"type:varchar(500);not null" json:"password" validate:"required,min=6,max=120" label:"密码"`Avatar string `gorm:"type:varchar(40);not null" json:"avatar" label:"头像"`Role     int    `gorm:"type:int;DEFAULT:2" json:"role" validate:"required,gte=2" label:"角色"`}</code></pre><p>Article.go:</p><pre class="language-go" data-language="go"><code class="language-go">package modelimport "gorm.io/gorm"type Article struct {Category Category `gorm:"foreignkey:Cid"`gorm.ModelTitle        string `gorm:"type:varchar(100);not null" json:"title"`Cid          int    `gorm:"type:int;not null" json:"cid"`Desc         string `gorm:"type:varchar(200)" json:"desc"`Content      string `gorm:"type:longtext" json:"content"`Img          string `gorm:"type:varchar(100)" json:"img"`}</code></pre><p>Category.go:</p><pre class="language-go" data-language="go"><code class="language-go">package modeltype Category struct {ID   uint   `gorm:"primary_key;auto_increment" json:"id"`Name string `gorm:"type:varchar(20);not null" json:"name"`}</code></pre><p>然后再新建一个<code>db.go</code>来进行配置</p><pre class="language-go" data-language="go"><code class="language-go">var db *gorm.DBvar err errorfunc InitDb()  {dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local",utils.DbUser,utils.DbPassWord,utils.DbHost,utils.DbPort,utils.DbName,)db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config{// gorm日志模式：silentLogger: logger.Default.LogMode(logger.Silent),// 外键约束DisableForeignKeyConstraintWhenMigrating: true,// 禁用默认事务（提高运行速度）SkipDefaultTransaction: true,NamingStrategy: schema.NamingStrategy{// 使用单数表名，启用该选项，此时，`User` 的表名应该是 `user`SingularTable: true,},})if err != nil{fmt.Println("链接数据库失败。", err)}// 迁移数据表，在没有数据表结构变更时候，建议注释不执行_ = db.AutoMigrate(&amp;User{}, &amp;Article{}, &amp;Category{})sqlDB, _ := db.DB()// SetMaxIdleCons 设置连接池中的最大闲置连接数。sqlDB.SetMaxIdleConns(10)// SetMaxOpenCons 设置数据库的最大连接数量。sqlDB.SetMaxOpenConns(100)// SetConnMaxLifetiment 设置连接的最大可复用时间。sqlDB.SetConnMaxLifetime(10 * time.Second)}</code></pre><p>然后把初始化函数配置到main.go中。</p><pre class="language-go" data-language="go"><code class="language-go">package mainimport ("blog/model""blog/routes")func main()  {model.InitDb()routes.InitRouter()}</code></pre><p>然后启动项目，他就会自动的进行迁移，如果你们跟我一样，项目启动了，他没有迁移，那就，*@¥&amp;@¥的，自己建吧，这个GORM我也没有理解的太好，哪怕代码正常运行，他也没有迁移表。</p><p>最后，目前的项目结构是这样。</p><img src="/posts/24611/image-20210625113610164.png" alt style="zoom:50%;" loading="lazy"><p>未完待续….</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GORM入门</title>
      <link href="/posts/33181/"/>
      <url>/posts/33181/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>GORM，是Go语言中的ORM(对象关系映射)，什么是ORM，是通过使用描述对象和数据库之间映射的元数据，将程序中的对象与关系数据库相互映射</p><p>坦白来说，就是一个简略sql语句的工具，每个人写sql语句习惯不同，不一定每个人都能看得懂，但是，换成orm后，统一的格式，无论在业务交接上还是便捷度上，都有很大的提升。</p><p>推荐去官网阅读文档，中文文档非常简便，我也不想搬过来了，就简简单单的使用一下。</p></blockquote><p><a href="https://gorm.io/">官网</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="language-go" data-language="go"><code class="language-go">go get -u gorm.io/gorm</code></pre><p>直接go get安装即可，GORM 官方支持的数据库类型有： MySQL, PostgreSQL, SQlite, SQL Server，本文章就以mysql为例。</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><pre class="language-go" data-language="go"><code class="language-go">import ("fmt""gorm.io/driver/mysql""gorm.io/gorm")func main() {// 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情dsn := "账号:密码@tcp(IP:端口号)/数据库名字?charset=utf8mb4&amp;parseTime=True&amp;loc=Local"db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})fmt.Println(db)fmt.Println(err)}</code></pre><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>就使用结构体即可，不过需要一点，实现一个TableName接口，否则他会在映射时表名多加一个s。比如有个表user，只有id和name两个字段</p><pre class="language-go" data-language="go"><code class="language-go">type User struct {ID   uintName string}func (User) TableName() string {return "user"}</code></pre><p>如果不写这个TableName的话，默认会映射成为<code>users</code>表。</p><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p>Gorm是我见过最简单的orm了，只需要将数据指针地址传过去，就ok</p><pre class="language-go" data-language="go"><code class="language-go">import ("fmt""gorm.io/driver/mysql""gorm.io/gorm")type User struct {ID   uintName string}func (User) TableName() string {return "user"}func main() {user := User{ID: 0, Name: "Salmon"}dsn := "root:root@tcp(127.0.0.1:3306)/test01?charset=utf8mb4&amp;parseTime=True&amp;loc=Local"db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})if err!= nil{panic(err)}result := db.Create(&amp;user)fmt.Println(user.ID)}user.ID             // 返回插入数据的主键result.Error        // 返回 errorresult.RowsAffected // 返回插入记录的条数</code></pre><h2 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h2><p>GORM 提供了 <code>First</code>、<code>Take</code>、<code>Last</code> 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 <code>LIMIT 1</code> 条件，且没有找到记录时，它会返回 <code>ErrRecordNotFound</code> 错误。</p><pre class="language-go" data-language="go"><code class="language-go">// 获取第一条记录（主键升序）db.First(&amp;user)// SELECT * FROM users ORDER BY id LIMIT 1;// 获取一条记录，没有指定排序字段db.Take(&amp;user)// SELECT * FROM users LIMIT 1;// 获取最后一条记录（主键降序）db.Last(&amp;user)// SELECT * FROM users ORDER BY id DESC LIMIT 1;result := db.First(&amp;user)result.RowsAffected // 返回找到的记录数result.Error        // returns error// 条件查询db.Where("id=?", 19).Find(&amp;users)// 检查 ErrRecordNotFound 错误errors.Is(result.Error, gorm.ErrRecordNotFound)</code></pre><p>主键检索</p><pre class="language-go" data-language="go"><code class="language-go">db.First(&amp;user, 10)// SELECT * FROM users WHERE id = 10;db.First(&amp;user, "10")// SELECT * FROM users WHERE id = 10;db.Find(&amp;users, []int{1,2,3})// SELECT * FROM users WHERE id IN (1,2,3);</code></pre><p>查询所有，使用<code>Find</code>方法，并且，接收值为数组。</p><pre class="language-go" data-language="go"><code class="language-go">var users []User//users := make([]User, 10)dsn := "root:root@tcp(127.0.0.1:3306)/test01?charset=utf8mb4&amp;parseTime=True&amp;loc=Local"db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})if err!= nil{panic(err)}db.Find(&amp;users)fmt.Println(users)</code></pre><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p>更新单个列，当使用 <code>Update</code> 更新单个列时，你需要指定条件，否则会返回 <code>ErrMissingWhereClause</code> 错误，查看 <a href="https://gorm.io/zh_CN/docs/update.html#block_global_updates">Block Global Updates</a> 获取详情。当使用了 <code>Model</code> 方法，且该对象主键有值，该值会被用于构建条件</p><pre class="language-go" data-language="go"><code class="language-go">db.Model(User{}).Where("id=?", 19).Update("role","Salmon")fmt.Println(users)// db.Model(&amp;users).Where("id=?", 19).Update("role","godhearing")</code></pre><p>更新多列</p><p><code>Updates</code> 方法支持 <code>struct</code> 和 <code>map[string]interface{}</code> 参数。当使用 <code>struct</code> 更新时，默认情况下，GORM 只会更新非零值的字段</p><pre class="language-go" data-language="go"><code class="language-go">db.Model(&amp;users).Where("id=?", 19).Updates(User{ID: 20,Role: "godhearing"})</code></pre><p>只更新某些字段(Select)，忽略某些字段(Omit)</p><pre class="language-go" data-language="go"><code class="language-go">db.Model(&amp;users).Where("id=?", 20).Select("role").Updates(User{ID: 21,Role: "龙"})db.Model(&amp;users).Where("id=?", 20).Omit("role").Updates(User{ID: 21,Role: "龙"})</code></pre><h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><p>根据主键删除</p><pre class="language-go" data-language="go"><code class="language-go">db.Delete(&amp;User{}, 22)</code></pre><p>条件删除</p><pre class="language-go" data-language="go"><code class="language-go">db.Where("role = ?", "asdasd").Delete(&amp;users)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go编译遇到xxx/go.mod malformed record data 问题</title>
      <link href="/posts/e9f705ae/"/>
      <url>/posts/e9f705ae/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近在慢慢转语言，在go语言下，编译时或者mod下，会偶尔莫名出现 xxx/go.mod malformed record data的问题</p><p>我理解是这样的，go 1.13 可以设置多个代理，在某个下载失败时，他会换代理下载代理设置：<a href="https://goproxy.io,direct/">https://goproxy.io,direct</a> 就是连个代理直接下载，或者使用goproxy.io下载当使用直接下载时，会通过默认代理“sum.golang.org”，这个代理需要FQ验证，所以会失败，切换goproxy.io 是报的这个错误，Google 上查可能是跟这个代理bug 有关</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>关掉它的默认代理</p><pre class="language-go" data-language="go"><code class="language-go">go env -w GOSUMDB=off</code></pre><p>由于目前转go，暂时可以用这个进行解决，不太明确是否有后患，记录一下</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构初识</title>
      <link href="/posts/62208/"/>
      <url>/posts/62208/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>什么是微服务，微服务是使用一套小服务来开发单个应用的方式，每个服务运行在独立的进程里，一般采用轻量级的通讯机制互联，并且它们可以通过自动化的方式部署</p><p>什么叫微？</p><ul><li>单一功能</li><li>代码少，不是，而且代码多</li><li>架构变的复杂了</li><li>微服务是设计思想，不是量的体现</li></ul></blockquote><h2 id="微服务特点"><a href="#微服务特点" class="headerlink" title="微服务特点"></a>微服务特点</h2><ul><li>单一职责，此时项目专注于登录和注册</li><li>轻量级的通信，通信与平台和语言无关，http是轻量的，例如java的RMI属于重量的</li><li>隔离性，数据隔离</li><li>有自己的数据</li><li>技术多样性</li></ul><h2 id="互联网架构"><a href="#互联网架构" class="headerlink" title="互联网架构"></a>互联网架构</h2><p>互联网的架构演变之路，是从一开始的<strong>单体架构</strong>，到<strong>垂直架构</strong>，再到SOA架构，直至微服务架构。</p><h4 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a><strong>单体架构</strong></h4><ul><li>所有功能放一个项目里</li><li>应用和数据库服务器可能部在一起，分开部</li><li>优点：<ul><li>简单，高效，小型项目</li></ul></li><li>缺点：<ul><li>扛不住</li><li>技术栈受限</li></ul></li></ul><img src="/posts/62208/image-20210617153840598.png" style="zoom:80%;" loading="lazy"><h4 id="垂直架构"><a href="#垂直架构" class="headerlink" title="垂直架构"></a><strong>垂直架构</strong></h4><ul><li>将大项目架构拆分成一个一个单体架构</li><li>优点：<ul><li>不至于像单体无限扩大</li></ul></li><li>缺点：<ul><li>有瓶颈</li><li>成本高</li></ul></li></ul><h4 id="SOA架构，面向服务的编程"><a href="#SOA架构，面向服务的编程" class="headerlink" title="SOA架构，面向服务的编程"></a><strong>SOA架构，面向服务的编程</strong></h4><ul><li>ESB，比较传统的中间件技术</li><li>优点：<ul><li>代码提高重用性，ESB接口解耦</li><li>针对不同服务，做不同数据层和部署</li></ul></li><li>缺点：<ul><li>ESB比较重量级</li><li>对于开发人员来说，系统层和服务层界限模糊</li></ul></li></ul><img src="/posts/62208/image-20210617154610892.png" alt style="zoom:80%;" loading="lazy"><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a><strong>微服务架构</strong></h4><ul><li>每个功能抽取成一个一个的服务</li><li>微服务之间访问是轻量级的，RPC</li></ul><p>微服务架构的优势：</p><ul><li>独立性</li><li>使用者容易理解</li><li>技术栈灵活</li><li>高效团队</li></ul><p>缺点：</p><ul><li>额外的工作，服务的拆分</li><li>保证数据一致性</li><li>增加了沟通成本</li></ul><img src="/posts/62208/image-20210617155114201.png" alt style="zoom:80%;" loading="lazy">]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin框架</title>
      <link href="/posts/77/"/>
      <url>/posts/77/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Gin是一个golang的微框架，封装比较优雅，API友好，源码注释比较明确，具有快速灵活，容错方便等特点</li><li>对于golang而言，web框架的依赖要远比Python，Java之类的要小。自身的<code>net/http</code>足够简单，性能也非常不错</li><li>借助框架开发，不仅可以省去很多常用的封装带来的时间，也有助于团队的编码风格和形成规范</li></ul><p><a href="https://gin-gonic.com/zh-cn/docs/">官方文档地址</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>要安装Gin软件包，需要安装Go并首先设置Go工作区。</p><p>1.首先需要安装Go（需要1.10+版本），然后可以使用下面的Go命令安装Gin。</p><ul><li>go get -u github.com/gin-gonic/gin</li></ul><p>2.将其导入代码中：</p><ul><li>import “github.com/gin-gonic/gin”</li></ul><p>3.（可选）导入net/http。例如，如果使用常量，则需要这样做http.StatusOK。</p><ul><li>import “net/http”</li></ul><blockquote><p>需要注意的是，直接下载gin有可能会报错，因为毕竟这不是国内的地址，可以通过以下命令来更改源：<code>go env -w GOPROXY=https://goproxy.cn,direct</code></p></blockquote><p>下载完毕后，去go工程目录下的<code>/pkg/mod/github.com/gin-gonic/</code>查看是否有gin，如果名字带着版本什么的，改成gin就好了，否则你在引入的时候还有可能会找不到这个包。</p><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>新建一个文件<code>main.go</code></p><pre class="language-go" data-language="go"><code class="language-go">package mainimport ("net/http""github.com/gin-gonic/gin")func main() {// 1.创建路由r := gin.Default()// 2.绑定路由规则，执行的函数// gin.Context，封装了request和responser.GET("/", func(c *gin.Context) {c.String(http.StatusOK, "hello Salmon!")})// 3.监听端口，默认在8080// Run("里面不指定端口号默认为8080")r.Run(":8020")}</code></pre><p>直接运行或者编译</p><pre class="language-go" data-language="go"><code class="language-go">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production. - using env:   export GIN_MODE=release - using code:  gin.SetMode(gin.ReleaseMode)[GIN-debug] GET    /                         --&gt; main.main.func1 (3 handlers)[GIN-debug] Listening and serving HTTP on :8020</code></pre><p>ok，启动完毕，然后我们来访问一下<code>http://127.0.0.1:8020/</code>，显示<code>hello Salmon!</code>，大功告成。</p><h2 id="path参数"><a href="#path参数" class="headerlink" title="path参数"></a>path参数</h2><blockquote><p>path参数可以根据<code>:xxx</code>来定义，通过<code>Param</code>取值，或者通过<code>Params.Get</code>的方式来取值。</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">package mainimport ("fmt""github.com/gin-gonic/gin""net/http")func main() {r := gin.Default()r.GET("/user/:name/:com", func(c *gin.Context) {ok,err := c.Params.Get("name")    // fmt.Println(c.Param("name"))fmt.Println(ok, err)c.JSON(http.StatusOK,gin.H{"message":"你好，tt "})})r.Run("0.0.0.0:8020")}</code></pre><h2 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h2><blockquote><p>查询参数，又叫query参数，一般是拼接在url后面的参数，通过?开始，不同的查询参数之间，用<code>&amp;</code>来拼接，例如:<code>xxx.com/?id=1111&amp;name=salmon</code>,</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func main() {r := gin.Default()r.GET("/user", func(c *gin.Context) {req := c.DefaultQuery("name","天听")fmt.Println(req)c.JSON(http.StatusOK,gin.H{"msg":req})})r.Run("0.0.0.0:8020")}</code></pre><p>可以通过<code>DefaultQuery</code>或者<code>Query</code>来取值，Query自不必说，<code>DefaultQuery</code>是有带一个默认值的。参数不存在，返回默认值，Query()若不存在，返回空串。</p><h2 id="表单参数"><a href="#表单参数" class="headerlink" title="表单参数"></a>表单参数</h2><ul><li>表单传输为post请求，http常见的传输格式为四种：<ul><li>application/json</li><li>application/x-www-form-urlencoded</li><li>application/xml</li><li>multipart/form-data</li></ul></li><li>表单参数可以通过PostForm()方法获取，该方法默认解析的是x-www-form-urlencoded或from-data格式的参数</li></ul><p>我们先定义一个表单</p><pre class="language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;Salmon&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="http://localhost:8020/form" method="post" action="application/x-www-form-urlencoded"&gt;    用户名：&lt;input type="text" name="username" placeholder="请输入你的用户名"&gt;  &lt;br&gt;    密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type="password" name="userpassword" placeholder="请输入你的密码"&gt;  &lt;br&gt;    &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后使用<code>PostForm</code>或者<code>DefaultPostForm</code>来取值。</p><h2 id="上传单个文件"><a href="#上传单个文件" class="headerlink" title="上传单个文件"></a>上传单个文件</h2><ul><li>multipart/form-data格式用于文件上传</li><li>gin文件上传与原生的net/http方法类似，不同在于gin把原生的request封装到c.Request中</li></ul><p>还是先定义一个html</p><pre class="language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action="http://localhost:8080/upload" method="post" enctype="multipart/form-data"&gt;          上传文件:&lt;input type="file" name="file" &gt;          &lt;input type="submit" value="提交"&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>后台：</p><pre class="language-go" data-language="go"><code class="language-go">package mainimport ("github.com/gin-gonic/gin""net/http")func main() {r := gin.Default()//限制上传最大尺寸r.MaxMultipartMemory = 8 &lt;&lt; 20r.POST("/upload", func(c *gin.Context) {file, err := c.FormFile("file")if err != nil {c.String(500, "上传图片出错")}// c.JSON(200, gin.H{"message": file.Header.Context})c.SaveUploadedFile(file, file.Filename)c.String(http.StatusOK, file.Filename)})r.Run(":8020")}</code></pre><p>也可以加一些限制：</p><pre class="language-go" data-language="go"><code class="language-go">func main() {    r := gin.Default()    r.POST("/upload", func(c *gin.Context) {        _, headers, err := c.Request.FormFile("file")        if err != nil {            log.Printf("Error when try to get file: %v", err)        }        //headers.Size 获取文件大小        if headers.Size &gt; 1024*1024*2 {            fmt.Println("文件太大了")            return        }        //headers.Header.Get("Content-Type")获取上传文件的类型        if headers.Header.Get("Content-Type") != "image/png" {            fmt.Println("只允许上传png图片")            return        }        c.SaveUploadedFile(headers, "./video/"+headers.Filename)        c.String(http.StatusOK, headers.Filename)    })    r.Run(":8020")}</code></pre><h2 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a>上传多个文件</h2><blockquote><p>照旧，html先搞上</p></blockquote><pre class="language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action="http://localhost:8020/upload" method="post" enctype="multipart/form-data"&gt;          上传文件:&lt;input type="file" name="files" multiple&gt;          &lt;input type="submit" value="提交"&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>后台:</p><pre class="language-go" data-language="go"><code class="language-go">package mainimport ("fmt""github.com/gin-gonic/gin""net/http")func main() {// 1.创建路由// 默认使用了2个中间件Logger(), Recovery()r := gin.Default()// 限制表单上传大小 8MB，默认为32MBr.MaxMultipartMemory = 8 &lt;&lt; 20r.POST("/upload", func(c *gin.Context) {form, err := c.MultipartForm()if err != nil {c.String(http.StatusBadRequest, fmt.Sprintf("get err %s", err.Error()))}// 获取所有图片files := form.File["files"]// 遍历所有图片for _, file := range files {// 逐个存if err := c.SaveUploadedFile(file, file.Filename); err != nil {c.String(http.StatusBadRequest, fmt.Sprintf("upload err %s", err.Error()))return}}c.String(200, fmt.Sprintf("upload ok %d files", len(files)))})//默认端口号是8080r.Run(":8020")}</code></pre><h2 id="routes-group"><a href="#routes-group" class="headerlink" title="routes group"></a>routes group</h2><ul><li>routes group是为了管理一些相同的URL，例如迭代版本不同</li></ul><p>举个例子：</p><pre class="language-go" data-language="go"><code class="language-go">r := gin.Default()v1 := r.Group("/v1")v1.GET("/login/",func(c *gin.Context) {c.String(200,"v1版本")})v2 := r.Group("/v2")v2.GET("/login/", func(c *gin.Context) {c.String(200, "v2版本")})</code></pre><p>url分别可以访问：<code>/v1/login/</code>或者<code>v2/login/</code></p><h2 id="gin的异步操作"><a href="#gin的异步操作" class="headerlink" title="gin的异步操作"></a>gin的异步操作</h2><blockquote><p>goroutine机制可以方便地实现异步处理</p><p>另外，在启动新的goroutine时，不应该使用原始上下文，必须使用它的只读副本</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">r.GET("/long_async", func(c *gin.Context) {// 需要搞一个副本copyContext := c.Copy()//fmt.Println(copyContext.Request.URL)// 异步处理go func() {time.Sleep(3 * time.Second)log.Println("异步执行：" + copyContext.Request.URL.Path)}()})// 2.同步r.GET("/long_sync", func(c *gin.Context) {time.Sleep(3 * time.Second)log.Println("同步执行：" + c.Request.URL.Path)})</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlalchemy-union</title>
      <link href="/posts/34699/"/>
      <url>/posts/34699/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>union是mysql中的联合查询，他的作用就是将两条查询语句和为一句。举个例子：</p><p>将两个字段相似的表里的数据统一起来展示在一个统计页面。如果是单纯的展示数据那很简单，两个表查出来之后组合一下就完事了，但是有坑的地方就是分页和按照时间搜索，这两个功能决定了不可能单独查询两张表。</p><p>想要完成这个功能，使用union的联合查询可以很轻易的做到。</p></blockquote><h2 id="定义数据表"><a href="#定义数据表" class="headerlink" title="定义数据表"></a>定义数据表</h2><p> 定义 两张表，字段类型相同，但名称不同。</p><pre class="language-python" data-language="python"><code class="language-python">#coding:utf-8from sqlalchemy import Column,CHAR,INTEGERfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import create_enginefrom sqlalchemy.orm import sessionmaker  Base = declarative_base()class User(Base):    __tablename__ = "user"    id = Column(CHAR(20),primary_key = True)    name = Column(CHAR(20))    age = Column(INTEGER)class Teacher(Base):    __tablename__ = "teacher"    id = Column(CHAR(20),primary_key = True)    tec_name = Column(CHAR(20))    tec_age = Column(INTEGER)engine = create_engine('mysql+mysqldb://root:12345678@localhost:3306/test')def create_table(table_name):    table_name.metadata.create_all(engine)    print "创建成功"def insert_data():    DBSession = sessionmaker(bind=engine)    session = DBSession()    for x in range(10):        temp = {}        temp['id'] = x        temp['name'] = 'user_' + str(x)        temp['age'] = x        user = User(**temp)        session.add(user)    for x in range(15):        temp = {}        temp['id'] = x        temp['tec_name'] = 'tec_' + str(x)        temp['tec_age'] = x * 2         tec = Teacher(**temp)        session.add(tec)    session.commit()    session.close()    print('success')if __name__ = '__main__':    create_table(User)    create_table(Teacher)    insert_data()</code></pre><p>User表字段：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; desc user;+-------+----------+------+-----+---------+-------+| Field | Type     | Null | Key | Default | Extra |+-------+----------+------+-----+---------+-------+| id    | char(20) | NO   | PRI | NULL    |       || name  | char(20) | YES  |     | NULL    |       || age   | int(11)  | YES  |     | NULL    |       |+-------+----------+------+-----+---------+-------+3 rows in set (0.00 sec)</code></pre><p>User表数据： </p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from user;+----+--------+------+| id | name   | age  |+----+--------+------+| 0  | user_0 |    0 || 1  | user_1 |    1 || 2  | user_2 |    2 || 3  | user_3 |    3 || 4  | user_4 |    4 || 5  | user_5 |    5 || 6  | user_6 |    6 || 7  | user_7 |    7 || 8  | user_8 |    8 || 9  | user_9 |    9 |+----+--------+------+10 rows in set (0.00 sec)</code></pre><p>Teacher表字段：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; desc teacher;+----------+----------+------+-----+---------+-------+| Field    | Type     | Null | Key | Default | Extra |+----------+----------+------+-----+---------+-------+| id       | char(20) | NO   | PRI | NULL    |       || tec_name | char(20) | YES  |     | NULL    |       || tec_age  | int(11)  | YES  |     | NULL    |       |+----------+----------+------+-----+---------+-------+3 rows in set (0.00 sec)mysql&gt;  </code></pre><p>teacher表数据：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; select * from teacher;+----+----------+---------+| id | tec_name | tec_age |+----+----------+---------+| 0  | tec_0    |       0 || 1  | tec_1    |       2 || 10 | tec_10   |      20 || 11 | tec_11   |      22 || 12 | tec_12   |      24 || 13 | tec_13   |      26 || 14 | tec_14   |      28 || 2  | tec_2    |       4 || 3  | tec_3    |       6 || 4  | tec_4    |       8 || 5  | tec_5    |      10 || 6  | tec_6    |      12 || 7  | tec_7    |      14 || 8  | tec_8    |      16 || 9  | tec_9    |      18 |+----+----------+---------+15 rows in set (0.00 sec)</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>首先做一个简单的查询，将两个表的数据分别查出来</p><pre class="language-python" data-language="python"><code class="language-python">def select():    DBSession = sessionmaker(bind=engine)    session = DBSession()    table_data = session.query(User).all()    session.close()    for x in table_data:        print(x.name,'------&gt;',x.age)    table_data = session.query(Teacher).all()    session.close()    for x in table_data:        print(x.tec_name,'------&gt;',x.tec_age)</code></pre><blockquote><p>union原理，首先将第一张表的数据全部查询出来，然后将第二张表的数据全部查询出来，最后将两个数据使用union联合成一张新表，这张新表可以再次被筛选过滤，分页等。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">def select():    DBSession = sessionmaker(bind=engine)    session = DBSession()    table_data = session.query(User).all()    session.close()    # for x in table_data:    #     print(x.name,'------&gt;',x.age)    # table_data = session.query(Teacher).all()    # session.close()    # for x in table_data:    #     print(x.tec_name,'------&gt;',x.tec_age)    user_data = session.query(User.name,User.age)    tec_data = session.query(Teacher.tec_name.label('name'), Teacher.tec_age.label('age'))    result = user_data.union_all(tec_data)    for x in result:            print(x.name,'------&gt;',x.age)</code></pre><p>在上面的查询中需要有一个注意点就是<strong>label</strong>，可以看到tec_data的查询语句中使用了label这个属性，该属性的作用是将Teacher这张表查询出来的tec_name 字段名称变成name，已达到和User表字段的统一，只有两张表的字段名称一致，类型一致的情况下才能联合查询。</p><p>另外还使用了一个<strong>union_all</strong> 字段，该字段的意思是如果两张表存在相同的记录也要全部展示出来，想要让相同的记录合并起来使用union即可。</p><hr><p>往往查询出来还不是最终目的，还需要对查询出来的数据过滤。查询出来的数据不是一张正真的表，如果使用字段去匹配过滤条件呢？以查询出age 大于 5为例 ，有两种过滤方式：</p><p>1.使用User.age 作为筛选条件</p><p>2.使用Teacher.age 作为筛选条件 </p><p>规则就是使用两张表里任意一张表的原始字段过滤即可，该过滤条件会在联合查询出来的结果起上作用。</p><h4 id="使用-User-表字段"><a href="#使用-User-表字段" class="headerlink" title="使用 User 表字段"></a>使用 User 表字段</h4><pre class="language-python" data-language="python"><code class="language-python">def select():    DBSession = sessionmaker(bind=engine)    session = DBSession()    table_data = session.query(User).all()    session.close()    # for x in table_data:    #     print(x.name,'------&gt;',x.age)    # table_data = session.query(Teacher).all()    # session.close()    # for x in table_data:    #     print(x.tec_name,'------&gt;',x.tec_age)    user_data = session.query(User.name,User.age)    tec_data = session.query(Teacher.tec_name.label('name'), Teacher.tec_age.label('age'))    # result = user_data.union_all(tec_data)    # for x in result:    #         print(x.name,'------&gt;',x.age)    result = user_data.union_all(tec_data).filter(User.age &gt; 5)    for x in result:        print(x.name,'------&gt;',x.age)</code></pre><p>使用 Teacher 表字段 </p><pre class="language-python" data-language="python"><code class="language-python">def select():    DBSession = sessionmaker(bind=engine)    session = DBSession()    table_data = session.query(User).all()    session.close()    # for x in table_data:    #     print(x.name,'------&gt;',x.age)    # table_data = session.query(Teacher).all()    # session.close()    # for x in table_data:    #     print(x.tec_name,'------&gt;',x.tec_age)    user_data = session.query(User.name,User.age)    tec_data = session.query(Teacher.tec_name.label('name'), Teacher.tec_age.label('age'))    result = user_data.union_all(tec_data).filter(Teacher.tec_age&gt;5)    for x in result:        print(x.name,'------&gt;',x.age)  </code></pre><p>关于union联合查询有一个说法很形象：join查询就像是横向扩展，将多张表的数据横向组合在一起，而union像是纵向扩展，将多张表数据纵向排列起来。</p>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastAPI </tag>
            
            <tag> SQLAlchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于最近的迷茫和感受</title>
      <link href="/posts/12653/"/>
      <url>/posts/12653/</url>
      
        <content type="html"><![CDATA[<h2 id="对个人的思考"><a href="#对个人的思考" class="headerlink" title="对个人的思考"></a>对个人的思考</h2><p>感觉一直在学东西，从来没有停止过脚步，停止了，就会被干掉，但是呢，越学，越感到迷茫，学得都是应用层面的东西，就像是阮一峰老师分享的文章里面说的实施细节。</p><p>软件开发中，技术变化如此之快，花费了大量的时间学习技术和工具，一旦这些技术被取代，你的知识将变得毫无价值。</p><p>我最近总是在想这段话，软件开发算不算是真正的知识？</p><p>如果它是一种真正的知识，那么理论上，我们学到的东西大部分应该不会过时，就好像微积分不会过时一样。可是实际上，我们都知道，软件开发技能有时效性，十年前学习的编程知识，十年后几乎肯定不能用于生产。那样的话，软件开发就不能算真正的知识，只是一种实施的细节。</p><p>以上内容出自阮一峰老师很早之前的一篇分享，对我影响很大，就在我满腔热血的准备学习一门新语言，学习新的知识。这篇文章像是一盆水，狠狠的让我停下脚步，开始了思考，假如说，10年后，没有人用我学习的这门语言了，我会的这门语言毫无价值，那我应该如何？</p><p>现在去银行存款，去税务局交税，去医院看病，如果你是第一次来，肯定搞不清楚具体流程，必须有人教你，要带哪些证件，要填哪些表，要去哪些窗口排队等等。</p><p>当你掌握了流程，某一天，他改变了，你又该怎么办，又得有人教你流程。我目前的状况怕是和这个场景很相似，额，应该不只是我，所有都在搞应用层代码的码农都应该是这种情况，可是，我们赖以生存的，就是应用层的技术，你去搞底层，底层会给你发工资吗？我们这些人，未来出路在哪？多学一门语言，多学一个框架，多学一个思想，解决的只是广面的问题。想要在这个神仙云集的行业中出头，要解决的一定不只是广面，最重要的还是深度，不过，要付出的代价，怕是更多，当然了，也有说多劳多得的说法，话是没错，但是我认为，不全对。在本来就不平等的棋盘上，没有赢这么一说，有些人跟你对弈，你只有象和士，其进攻你的，是兵，车，马，炮，你该怎样赢他，赢不了，你只有拼尽全力，打出一个和。</p><p>或许在其他人看来，你已经很厉害了，但是，只有你自己知道，你和其他人的差距。总的来说，这盘棋，或许不存在赢的可能，但是你坚持的时间够久，那就算是逐渐的接近了胜利。这个时代已经变了，单枪匹马打天下，根本就不现实。脚下的路，唯有一条，提高自己的认知，不知道有没有注意过，你接触了一个新的认知，你达到了一个新的高度，永远有跟不上你脚步的人，他们会慢慢的消失在身后，但同时，你也能看到很多在你前面的人，他们和你一样，在提高着自己的认知，在不断的刷新迭代和优化自己。</p><h2 id="小矫情一下"><a href="#小矫情一下" class="headerlink" title="小矫情一下"></a>小矫情一下</h2><p><code>https://v2ex.com/t/729626</code>，这是一个让我刷新认知的帖子，因为流量的变现，一个不起眼的应用，却能够赚着我们赚不到的钱。还有via浏览器，单一个华为应用市场，就有1200万的下载量，是这个帖子中例子的三四倍，在幕后赚的钱也无法估计，因为，贫穷限制了我的想象力。码农发家致富，成功几率相对来说还是不小的，只是还没有发现路。或者说，没注意到哪里有路。这世界很大，对于初出茅庐的我来说，就好像在风雨中的小船，随时可能会翻，只能眼睁睁着狂风暴雨，听天由命。</p><p>有人跟我说过，迷茫证明你在变强，可是…天天尼玛迷茫哪来的时间变强。不过有一点是对的，迷茫了，证明你已经在舒适区里呆不下去了，你要踏出这个舒适区了，或许你没有方向，或许你没有动力，但是只要找到了那个方向，便会不顾一切的朝着那个方向走去。</p><p>不过人生在世，活的就要一个自在，总以为骄傲的抬着头，就能看见头顶的月亮，但是有人说了，抬头不累吗，拿面镜子将他映在脚下不行吗？然后又有人说了，咱躺着看不行吗？是躺着不舒服吗？emmm….懒都没有懒到点上。</p><p>鸡汤横行的世界，都中了鸡汤的毒，很难有能保持初心的人，不过我始终相信，志向越大，付出的东西就会越多，如果还在迷茫，就适当的向生活低下头吧，低下头还迷茫大不了再抬起来嘛。不过这好像是在向生活磕头了，行了，就到这里吧，写之前我还是挺迷茫的，写完之后，突然就有些看开了，也许是因为快下班了吧。。。</p><p>哦对了，还有一碗鸡汤没灌，每当我觉得前路不明朗的时候，就会念一遍这句话，希望这鸡汤真的有用吧。</p><p>如果你种下了一颗种子，你不会每隔几分钟把它挖出来看看有没有发芽。所以你为什么要一直怀疑自己，怀疑自己的努力和决定。 耐心一点儿，不要想太多。不断的给自己的种子浇水就好了。</p>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7安装python3</title>
      <link href="/posts/36063/"/>
      <url>/posts/36063/</url>
      
        <content type="html"><![CDATA[<h2 id="简略步骤"><a href="#简略步骤" class="headerlink" title="简略步骤"></a>简略步骤</h2><p>直接把所有步骤简略写下，简略的解释，如果要安装的话，直接复制命令即可。</p><pre class="language-python" data-language="python"><code class="language-python">1、安装依赖包yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make libffi-devel -y2、下载python3的安装包wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz  3、解压安装包tar -zxvf Python-3.7.4.tgzcd Python3.7.44、配置路径，编译安装./configure --prefix=/usr/local/Python-3.7.4make &amp;&amp; make install5、添加软连接ln -s /usr/local/Python-3.7.4/bin/python3 /usr/bin/pythonln -s /usr/local/Python-3.7.4/bin/pip3 /usr/bin/pip"""如果出现文件已存在，则将其删除，重新再执行"""rm -rf /usr/bin/pythonrm -rf /usr/bin/pip"""不出现不用执行"""6、修复yum，将这两个文件的第一行的python改为python2，注意，是python2vi /usr/libexec/urlgrabber-ext-downvi /usr/bin/yum</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlalchemy序列化</title>
      <link href="/posts/56951/"/>
      <url>/posts/56951/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>sqlalchemy虽然说是python最好用的orm之一，但是其内部的功能还是有不完善的地方，就比如序列化，如果表字段要破百，假设前后端不分离的情况下还好，但是前后端分离的情况下，前端无法处理，而sqlalchemy又不带序列化，所以我们只能自己写一个序列化了</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-python" data-language="python"><code class="language-python">from sqlalchemy import inspectfrom sqlalchemy.orm import ONETOMANY, MANYTOMANYclass Serializer:    def __init__(self, instance, many=False, include=[], exclude=[], depth=2):        self.instance = instance        self.many = many        self.include = include        self.exclude = exclude        self.depth = depth    @property    def data(self):        if self.include and self.exclude:            raise ValueError('include and exclude can\'t work together')        if self.many:            if isinstance(self.instance, list):                return self._serializerlist(self.instance, self.depth)            pageinfo = {                'items': True,                'pages': self.instance.pages,                'has_prev': self.instance.has_prev,                'page': self.instance.page,                'has_next': self.instance.has_next,                'iter_pages': list(self.instance.iter_pages(left_edge=1,                                                            left_current=2,                                                            right_current=3,                                                            right_edge=1))            }            return {'data': self._serializerlist(self.instance.items,                                                 self.depth),                    'pageinfo': pageinfo}        return self._serializer(self.instance, self.depth)    def _serializerlist(self, instances, depth):        results = []        for instance in instances:            result = self._serializer(instance, depth)            if result:                results.append(result)        return results    def _serializer(self, instance, depth):        result = {}        if depth == 0:            return result        depth -= 1        model_class = self.get_model_class(instance)        inp = self.get_inspect(model_class)        model_data = self._serializer_model(inp, instance, depth)        relation_data = self._serializer_relation(inp, instance, depth)        result.update(model_data)        result.update(relation_data)        return result    def _serializer_model(self, inp, instance, depth):        result = {}        model_columns = self.get_model_columns(inp)        for column in model_columns:            result[column] = getattr(instance, column)        return result    def _serializer_relation(self, inp, instance, depth):        result = {}        relation_columns = self.get_relation_columns(inp)        for relation in relation_columns:            column = relation.key            if relation.direction in [ONETOMANY, MANYTOMANY]:                children = getattr(instance, column)                if relation.lazy == 'dynamic':                    children = children.all()                result[column] = Serializer(                    children,                    many=True,                    exclude=[relation.back_populates],                    depth=depth).data            else:                child = getattr(instance, column)                if relation.lazy == 'dynamic':                    child = child.first()                result[column] = Serializer(                    child,                    many=False,                    exclude=[relation.back_populates],                    depth=depth).data        return result    def get_model_class(self, instance):        return getattr(instance, '__class__')    def get_inspect(self, model_class):        return inspect(model_class)    def get_model_columns(self, inp):        if self.include:            model_columns = [                column.name for column in inp.columns                if column.name in self.include            ]        elif self.exclude:            model_columns = [                column.name for column in inp.columns                if column.name not in self.exclude            ]        else:            model_columns = [column.name for column in inp.columns]        return model_columns    def get_relation_columns(self, inp):        if self.include:            relation_columns = [                relation for relation in inp.relationships                if relation.key in self.include            ]        elif self.exclude:            relation_columns = [                relation for relation in inp.relationships                if relation.key not in self.exclude            ]        else:            relation_columns = [relation for relation in inp.relationships]        return relation_columns</code></pre><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>使用上很简单(以flask-sqlalchemy为例),原生<strong>sqlalchemy</strong>类似</p><h3 id="多个实例"><a href="#多个实例" class="headerlink" title="多个实例"></a>多个实例</h3><pre class="language-none"><code class="language-none">posts = Post.query.all()serializer = Seralizer(posts,many=True)data = serializer.data</code></pre><h3 id="单个实例"><a href="#单个实例" class="headerlink" title="单个实例"></a>单个实例</h3><pre class="language-none"><code class="language-none">post = Post.query.first()serializer = Seralizer(post,many=False)data = serializer.data</code></pre><h3 id="排除字段"><a href="#排除字段" class="headerlink" title="排除字段"></a>排除字段</h3><pre class="language-none"><code class="language-none">serializer = Seralizer(post,exclude=['title'])</code></pre><h3 id="仅包括字段"><a href="#仅包括字段" class="headerlink" title="仅包括字段"></a>仅包括字段</h3><pre class="language-none"><code class="language-none">serializer = Seralizer(post,include=['title'])</code></pre><h3 id="关系查询深度"><a href="#关系查询深度" class="headerlink" title="关系查询深度"></a>关系查询深度</h3><pre class="language-none"><code class="language-none">serializer = Seralizer(post,depth=3)</code></pre>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastAPI </tag>
            
            <tag> SQLAlchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-componse搭建ES单机集群</title>
      <link href="/posts/23811/"/>
      <url>/posts/23811/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>也不想前言了，作为一名非专业运维，各种bug层出不穷，不过好在功夫不负有心人，终于是成功了搭建了ES单机集群</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><p>首先就是一个巨坑，我在使用docker-compose内写了挂载，他自动创建，然后，就没有然后了，他自动创建的文件夹和文件是没有读写权限的，所以我们手动创建。</p></blockquote><pre class="language-none"><code class="language-none"># 创建数据/日志目录 这里我们部署2个节点# 由于服务器辣鸡，所以只部署两个，如果想增多的话，就手动加着建就行了mkdir /opt/elasticsearch/data/{node0,node1,node2} -pmkdir /opt/elasticsearch/logs/{node0,node1,node2} -pmkdir /opt/elasticsearch/nodecd /opt/elasticsearch/nodemkdir es1mkdir es2cd /opt/elasticsearch# 给予777最大权限chmod 0777 data/* -R &amp;&amp; chmod 0777 logs/* -</code></pre><p>把该创建完成的都创建完成，之后，又是一个坑，系统参数不足导致的内存一直不够用，这里我们直接修改<code>/etc/sysctl.conf</code></p><pre class="language-none"><code class="language-none">echo vm.max_map_count=655360 &gt;&gt; /etc/sysctl.conf# 在root账户执行这一句 作用是重新载入sysctl系统参数sysctl -p</code></pre><h2 id="Docker-compose文件"><a href="#Docker-compose文件" class="headerlink" title="Docker-compose文件"></a>Docker-compose文件</h2><blockquote><p>然后进入到<code>/opt/elasticsearch</code>目录下，建立docker-compose.yml文件即docker-compose使用的主模板文件：</p></blockquote><pre class="language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">version: '3'services:  es1:    image: elasticsearch:7.2.0    container_name: es1    privileged: true    environment:      - "ES_JAVA_OPTS=-Xms128m -Xmx128m"    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - ./data/node0:/usr/share/elasticsearch/data      - ./node/es1/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml      - ./logs/node0:/usr/share/elasticsearch/logs    ports:      - 9200:9200    networks:      - esnet  es3:    image: elasticsearch:7.2.0    container_name: es2    privileged: true    environment:      - "ES_JAVA_OPTS=-Xms128m -Xmx128m"    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - ./data/node2:/usr/share/elasticsearch/data      - ./node/es2/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml      - ./logs/node2:/usr/share/elasticsearch/logs    ports:      - 9202:9200    links:      - es1    networks:      - esnet# 使用桥接的网络连接方式networks:  esnet:    driver: bridge</code></pre><p>然后<code>cd node/es1/</code>写<code>elasticsearch.yml</code>配置文件</p><pre class="language-none"><code class="language-none"># 集群名称 EsClustercluster.name: yawp# 节点名称node.name: es1# 是否为主节点node.master: true# 该节点是否存储数据node.data: true# 对外开放的http端口http.port: 9200# 回环地址network.host: 0.0.0.0discovery.zen.ping.unicast.hosts: ["es1"]bootstrap.memory_lock: true# 是否运行跨域REST请求http.cors.enabled: true# 允许跨域请求来自何处http.cors.allow-origin: "*"# 有成为主节点资格的最小节点数discovery.zen.minimum_master_nodes: 1xpack.security.enabled: falsecluster.initial_master_nodes: ["es1"]</code></pre><p>从节点的配置文件<code>elasticsearch.yml</code></p><pre class="language-none"><code class="language-none"># 集群名称 EsClustercluster.name: yawp# 节点名称node.name: es2# 是否为主节点node.master: false# 该节点是否存储数据node.data: true# 对外开放的http端口http.port: 9200# 回环地址network.host: 0.0.0.0# 有资格成为主节点的资格列表discovery.zen.ping.unicast.hosts: ["es1"]# 是否运行跨域REST请求http.cors.enabled: true# 允许跨域请求来自何处http.cors.allow-origin: "*"# 有成为主节点资格的最小节点数discovery.zen.minimum_master_nodes: 1xpack.security.enabled: falsecluster.initial_master_nodes: ["es1"]</code></pre><p>然后回到<code>/opt/elasticsearch</code>启动集群 <code>docker-compose up -d</code></p><p>启动成功后通过<code>docker-compose ps</code>查看集群情况，如果你的容器在运行，但是输入这个命令却找不到，请不用担心，停掉容器，重新启动一下就好了。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker内ES配置IK分词</title>
      <link href="/posts/8829/"/>
      <url>/posts/8829/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>使用ES，安装分词器是必不可少的，因为es默认的分词器对中文太不友好，按照每个汉字划分，缺少灵魂，而ik这个分词器，就是一个中文分词器，非常的好用。下面介绍两种安装IK的方式，第一种比较简单，第二种比较繁琐，如果还没有安装ES的话，请移步：<a href="https://www.godhearing.cn/2019/03/24/ji-yu-docker-pei-zhi-elasticsearch-quan-wen-jian-suo/">这里</a></p></blockquote><h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><ol><li><p>进入容器</p> <pre class="language-none"><code class="language-none">docker exec -it 容器id /bin/bash</code></pre></li><li><p>在线下载并安装，需要注意，一定要安装你对应es版本的插件</p> <pre class="language-none"><code class="language-none">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.5.4/elasticsearch-analysis-ik-6.5.4.zip</code></pre></li><li><p>cd到<code>plugins</code>看到<code>analysis-ik</code>，就代表安装成功，此时，我们只需要exit退出容器，然后执行<code>docker restart 容器id</code>重启即可</p></li></ol><h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><p>确认ES版本,去github上下载正确版本的IK分词器</p><pre class="language-none"><code class="language-none">https://github.com/medcl/elasticsearch-analysis-ik</code></pre><p>然后通过下载页.下载zip包 <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p><p>通过docker命令将其拷贝进容器内</p><pre class="language-none"><code class="language-none">docker cp /tmp/elasticsearch-analysis-ik-7.8.0.zip {容器名}:/usr/share/elasticsearch/plugins</code></pre><pre class="language-none"><code class="language-none"># 进入容器docker exec -it elasticsearch /bin/bash# 创建目录mkdir /usr/share/elasticsearch/plugins/ik将文件压缩包移动到ik中mv /usr/share/elasticsearch/plugins/elasticsearch-analysis-ik-7.8.0.zip /usr/share/elasticsearch/plugins/ik# 进入目录cd /usr/share/elasticsearch/plugins/ik# 解压unzip elasticsearch-analysis-ik-7.8.0.zip# 删除压缩包rm -rf elasticsearch-analysis-ik-7.8.0.zip</code></pre><p>重启docker容器即可。</p><p>然后我们来测试一下，打开postman，向<code>localhost:9200/_analyze?pretty</code>地址发送一个post请求，注意要改成json格式</p><img src="/posts/8829/image-20210517175414852.png" alt style="zoom:50%;" loading="lazy"><p>然后查看结果，不再是一个字一个字的，就对了，ok，测试完毕</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canal同步ES</title>
      <link href="/posts/13974/"/>
      <url>/posts/13974/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>canal 是阿里巴巴开源的一个项目，主要用途是基于 MySQL 数据库 binlog 日志解析，提供增量数据订阅和消费。</p><p>基于日志增量订阅和消费的业务包括：</p><ul><li>数据库镜像</li><li>数据库实时备份</li><li>索引构建和实时维护（拆分异构索引、倒排索引等）</li><li>业务 cache 刷新</li><li>带业务逻辑的增量数据处理</li></ul><h2 id="MySQL-配置"><a href="#MySQL-配置" class="headerlink" title="MySQL 配置"></a>MySQL 配置</h2><p>修改 MySQL 配置文件<code>/etc/mysql/my.cnf</code>，开启 binlog 写入功能，并配置模式为 ROW。</p><pre class="language-none"><code class="language-none">log-bin=mysql-bin # 开启 binlogbinlog-format=ROW # 选择 ROW 模式server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复</code></pre><p>重启数据库，查看配置是否生效。命令是：<code>sudo service mysql restart</code></p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; show variables like 'binlog_format';+---------------+-------+| Variable_name | Value |+---------------+-------+| binlog_format | ROW   |+---------------+-------+1 row in set (0.19 sec)mysql&gt;mysql&gt; show variables like 'log_bin';+---------------+-------+| Variable_name | Value |+---------------+-------+| log_bin       | ON    |+---------------+-------+1 row in set (0.00 sec)mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000003 |     4230 |              |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)</code></pre><p>然后创建用户，并授权。</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">mysql&gt; CREATE USER canal IDENTIFIED BY 'canal';mysql&gt; GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%';mysql&gt; FLUSH PRIVILEGES;mysql&gt; show grants for 'canal'@'%';+----------------------------------------------------------------------------+| Grants for canal@%%                                                        |+----------------------------------------------------------------------------+| GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO `canal`@`%` |+----------------------------------------------------------------------------+1 row in set (0.00 sec)</code></pre><h2 id="canal服务端"><a href="#canal服务端" class="headerlink" title="canal服务端"></a>canal服务端</h2><blockquote><p>canal的原理呢，就是canal服务端来监听mysql的binlog，然后canal的客户端来连接并解析日志，达到自己想要的效果，比如增量数据到ES，我们用docker来启动服务端</p></blockquote><p>第一步，拉取镜像</p><pre class="language-none"><code class="language-none">docker pull canal/canal-server:v1.1.4</code></pre><p>第二步，写一个docker-compose，启动起来比较方便，或者直接使用它提供的脚本也可以。</p><pre class="language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">version: '3'services:  canal-server:    image: canal/canal-server:v1.1.4    container_name: canal-server    restart: unless-stopped    network_mode: host    ports:       - 11111:11111    environment:      - canal.auto.scan=false      - canal.instance.master.address=127.0.0.1:3306      - canal.instance.dbUsername=canal      - canal.instance.dbPassword=canal      - canal.instance.filter.regex=.*\\..*      - canal.destinations=test      - canal.instance.connectionCharset=UTF-8      - canal.instance.tsdb.enable=true    volumes:      - /root/canal/test/log/:/home/admin/canal-server/logs/</code></pre><blockquote><p>如果碰到<code>host network_mode is incompatible with port_bindings</code>这个错误，那我们直接用它默认的网络即可，将<code>network_mode</code>删掉就好。</p></blockquote><p>官方提供的shell脚本</p><pre class="language-none"><code class="language-none"># sh run.sh -e canal.auto.scan=false -e canal.destinations=test -e canal.instance.master.address=127.0.0.1:3306 -e canal.instance.dbUsername=canal -e canal.instance.dbPassword=canal -e canal.instance.connectionCharset=UTF-8 -e canal.instance.tsdb.enable=true -e canal.instance.gtidon=false</code></pre><p>启动服务：</p><pre class="language-none"><code class="language-none"># docker-compose upRecreating canal-server ... doneAttaching to canal-servercanal-server    | DOCKER_DEPLOY_TYPE=VMcanal-server    | ==&gt; INIT /alidata/init/02init-sshd.shcanal-server    | ==&gt; EXIT CODE: 0canal-server    | ==&gt; INIT /alidata/init/fix-hosts.pycanal-server    | ==&gt; EXIT CODE: 0canal-server    | ==&gt; INIT DEFAULTcanal-server    | Generating SSH1 RSA host key: [  OK  ]canal-server    | Starting sshd: [  OK  ]canal-server    | Starting crond: [  OK  ]canal-server    | ==&gt; INIT DONEcanal-server    | ==&gt; RUN /home/admin/app.shcanal-server    | ==&gt; START ...canal-server    | start canal ...canal-server    | start canal successfulcanal-server    | ==&gt; START SUCCESSFUL ...</code></pre><p>看见START SUCCESSFUL即启动成功。</p><h2 id="canal客户端"><a href="#canal客户端" class="headerlink" title="canal客户端"></a>canal客户端</h2><blockquote><p>直接copy官方的客户端代码即可，<a href="https://github.com/haozi3156666/canal-python">地址</a>，我就不搬砖了</p><pre class="language-none"><code class="language-none">connected to 127.0.0.1:11111Auth succedSubscribe succed</code></pre><p>看到这个，即为成功</p></blockquote><p>我们来验证一下，随便建个库，建个表，然后插入几条数据。</p><p>打印出的，db就是我们的库，table就是表，event_type字段1表示新增，2表示更新，3表示删除，data里就是我们的数据，可以根据自己的需要来灵活的变动。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>canal服务端启动之后，在<code>docker-compose.yml</code>里设置的<code>volumes</code>位置，会生成两个日志文件，分别是<code>meta.log和test.log</code>，可以查看服务是不是正常，有没有报错信息。</p><p>后续如果要更改，更好的做法是将消息发送到消息队列，然后再从消息队列消费。在1.1.5版本中，官方支持了RabbitMQ，后续有时间再继续更新</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序支付后台调用</title>
      <link href="/posts/20031/"/>
      <url>/posts/20031/</url>
      
        <content type="html"><![CDATA[<h2 id="支付交互流程"><a href="#支付交互流程" class="headerlink" title="支付交互流程"></a>支付交互流程</h2><blockquote><p>这里呢，就不多说了，先上图</p></blockquote><img src="/posts/20031/image-20210423162246245.png" loading="lazy"><p>后台调用，只需要调用<a href="https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=9_1&amp;index=1">统一下单API</a>，就可以了。</p><h2 id="获取openid"><a href="#获取openid" class="headerlink" title="获取openid"></a>获取openid</h2><blockquote><p>这是第一步，openid是微信用户在你的小程序中的唯一标识，只需调用<code>vx.login</code>即可。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">import requestsfrom config import APPID, SECRETclass OpenidUtils(object):    def __init__(self, jscode):        self.url = "https://api.weixin.qq.com/sns/jscode2session"        self.appid = APPID  # 小程序id        self.secret = SECRET  # 不要跟后面支付的key搞混        self.jscode = jscode    # 前端传回的动态jscode    def get_openid(self):        # url一定要拼接，不可用传参方式        url = self.url + "?appid=" + self.appid + "&amp;secret=" + self.secret + "&amp;js_code=" + self.jscode + "&amp;grant_type=authorization_code"        r = requests.get(url)        print(r.json())        openid = r.json()['openid']        return openid</code></pre><h2 id="支付请求"><a href="#支付请求" class="headerlink" title="支付请求"></a>支付请求</h2><pre class="language-python" data-language="python"><code class="language-python">import requestsimport jsonimport hashlibimport timeimport randomimport stringimport xmltodictclass WX_PayToolUtil():    """ 微信支付工具 """    def __init__(self, APP_ID, MCH_ID, API_KEY, NOTIFY_URL):        self._APP_ID = APP_ID  # 小程序ID        self._MCH_ID = MCH_ID  # 商户号        self._API_KEY = API_KEY        self._UFDODER_URL = "https://api.mch.weixin.qq.com/pay/unifiedorder"  # 接口链接        self._NOTIFY_URL = NOTIFY_URL  # 异步通知    def generate_sign(self, param):            '''生成签名'''            stringA = ''            ks = sorted(param.keys())            # 参数排序            for k in ks:                stringA += (k + '=' + param[k] + '&amp;')            # 拼接商户KEY            stringSignTemp = stringA + "key=" + self._API_KEY            # md5加密,也可以用其他方式            hash_md5 = hashlib.md5(stringSignTemp.encode('utf8'))            sign = hash_md5.hexdigest().upper()            return sign    def getPayUrl(self, orderid, openid, goodsPrice, **kwargs):        """向微信支付端发出请求，获取url"""        # key = self._API_KEY        nonce_str = ''.join(random.sample(string.ascii_letters + string.digits, 30))  # 生成随机字符串，小于32位        params = {            'appid': self._APP_ID,            'mch_id': self._MCH_ID,            'nonce_str': nonce_str,            "body": '艺术品订单',            'out_trade_no': orderid,            'total_fee': str(goodsPrice),            'spbill_create_ip': "127.0.0.1",            'notify_url': self._NOTIFY_URL,            'trade_type': "JSAPI",            "openid": openid,         }        # 生成签名        params['sign'] = self.generate_sign(params)        param = {'root': params}        xml = xmltodict.unparse(param)        response = requests.post(self._UFDODER_URL, data=xml.encode('utf-8'), headers={'Content-Type': 'text/xml'})        # xml 2 dict        msg = response.text        xmlmsg = xmltodict.parse(msg)        # 4. 获取prepay_id        if xmlmsg['xml']['return_code'] == 'SUCCESS':            if xmlmsg['xml']['result_code'] == 'SUCCESS':                prepay_id = xmlmsg['xml']['prepay_id']                # 时间戳                timeStamp = str(int(time.time()))                # 5. 五个参数                data = {                    "appId": self._APP_ID,                    "nonceStr": nonce_str,                    "package": "prepay_id=" + prepay_id,                    "signType": 'MD5',                    "timeStamp": timeStamp,                }                # 6. paySign签名                paySign = self.generate_sign(data)                data["paySign"] = paySign  # 加入签名                # 7. 传给前端的签名后的参数                return data</code></pre><p>当然你可能会遇到的错误有签名错误，一般的情况是你的appSecret和商户号的API密钥两个弄错了，当然如果不是还有可能是其他问题，解决方案链接<a href="https://www.cnblogs.com/wanghuijie/p/wxpay_sign_error.html%E3%80%82">https://www.cnblogs.com/wanghuijie/p/wxpay_sign_error.html。</a></p><h2 id="很可能遇到的错误"><a href="#很可能遇到的错误" class="headerlink" title="很可能遇到的错误"></a>很可能遇到的错误</h2><p>比如返回<code>invalid total_fee</code>，这是因为，微信支付和支付宝不同，他的计量单位是分，所以不能出现小数点。所以我们系统如果是以元为单位要处理下金额，即先乘以100，再去小数点</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CORS跨域问题</title>
      <link href="/posts/34938/"/>
      <url>/posts/34938/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><pre class="language-none"><code class="language-none">The value of the 'Access-Control-Allow-Origin' header in the response must not be the wildcard '*' when the request's credentials mode is 'include'. The credentials mode of requests initiated by t...</code></pre><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>前端配置了<code>withCredentials=true</code></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>后端配置<code>Access-Control-Allow-Origin</code>不能为<code>*</code>, 必须是相应地址</p><p>后端需配置<code>Access-Control-Allow-Credentials</code></p><p>后端需要配置<code>Access-Control-Allow-Headers</code>为对应的请求头集合</p>]]></content>
      
      
      <categories>
          
          <category> cors </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cors </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apscheduler设置时区</title>
      <link href="/posts/3894/"/>
      <url>/posts/3894/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在最近的使用中，感觉到这个apscheduler非常的好用，但是吧，一切美好的想象就停留在了部署的那天….</p><p>我本以为一切如我所愿，按照我预期的运行，于是我在开启了一个定时任务后，满怀期待的等待着，只要他执行，我就可以下班走人了，但是，时间到了之后，他还是没有执行，于是我就意识到，事情开始往我意想不到的方向发展了。</p><p>我在查看了redis之后，发现，他的任务还在，并没有报错，只是时间是在八小时之后，哎，我这才意识到是时区的问题。那，废话不多说，直接开始上代码。</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>直接在添加任务处指定时区，如下：</p> <pre class="language-python" data-language="python"><code class="language-python"># 这样的话，就是utc时间了。schedudler.add_job(worker,'cron',day="*/1", timezone=pytz.utc)# 改为下面这个时区，就是亚洲上海，与我们时间一致，也就能最好的解决这个问题timezone=pytz.timezone('Asia/Shanghai')</code></pre></li><li><p>还有一种方法，就是更改你的系统和docker的时区，因为apscheduler的时间是根据你本机的时区来进行的。</p><p> 1: 以ubuntu为例，更改时区</p><p> <code>date -R</code>或者<code>timedatectl status</code>都能查看时区，然后修改时区<code>timedatectl set-timezone "Asia/Shanghai"</code></p><p> 2: 修改docker的时区</p><p> 这个呢，可以在启动容器时将本地的时区文件挂载映射，看起来像是这样：</p> <pre class="language-python" data-language="python"><code class="language-python">docker run -v /etc/timezone:/etc/timezone -v /etc/localtime:/etc/localtime -it ubuntu bash</code></pre><p> 或者直接在dockerfile中添加上<code>RUN cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo 'Asia/Shanghai' &gt;/etc/timezone</code></p></li></ol><p>问题完美解决</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>brew安装nginx</title>
      <link href="/posts/14823/"/>
      <url>/posts/14823/</url>
      
        <content type="html"><![CDATA[<p>1.安装</p><pre class="language-none"><code class="language-none">brew install nginx</code></pre><p>或</p><pre class="language-none"><code class="language-none">sudo brew install nginx</code></pre><p>2.启动</p><pre class="language-none"><code class="language-none">brew services start nginx或者sudo brew services start nginx</code></pre><p>3.重启</p><pre class="language-none"><code class="language-none">brew services restart nginx或者sudo brew services restart nginx</code></pre><p>4.停止</p><pre class="language-none"><code class="language-none">brew services stop nginx或者sudo brew services stop nginx</code></pre><p>5.查看</p><pre class="language-none"><code class="language-none">cat usr/local/etc/nginx/nginx.conf</code></pre><p>6.编辑</p><pre class="language-none"><code class="language-none">vi usr/local/etc/nginx/nginx.conf</code></pre>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytest进阶</title>
      <link href="/posts/60788/"/>
      <url>/posts/60788/</url>
      
        <content type="html"><![CDATA[<h2 id="分组执行"><a href="#分组执行" class="headerlink" title="分组执行"></a>分组执行</h2><p>pytest的分组执行依旧可以用mark进行标记，标记名可以自定义的取，比如冒烟用例可以用<code>smoke</code>。</p><p>看起来像是这样：</p><pre class="language-python" data-language="python"><code class="language-python">class TestLogin:    @pytest.mark.smoke    def test_01(self):        print('hello salmon')# 同时使用两个装饰器，也是可以的。@pytest.mark.run(order=2)@pytest.mark.smokedef test_03():    print('bing')</code></pre><p>然后，我们在配置文件里添加上markers，这是分组，整体的<code>pytest.ini</code>可能会是这样的</p><pre class="language-python" data-language="python"><code class="language-python">[pytest]addopts = -vstestpaths = ./test_pytestpython_files = test*.pypython_classes = Test*python_functions = testMarkers =    smoke:冒烟用例    www:名字可以随意取</code></pre><p>执行：我们只需要在执行时加一个<code>-m</code>参数即可，<code>-m</code>后面跟的是你要执行哪些组，比如你要执行smoke</p><pre class="language-none"><code class="language-none">pytest -m "smoke"</code></pre><p>或者你想同时执行smoke和www</p><pre class="language-none"><code class="language-none">pytest -m "smoke or www"</code></pre><p>亦或者再执行同时标记有smoke和www的</p><pre class="language-python" data-language="python"><code class="language-python">class TestLogin:    @pytest.mark.smoke    @pytest.mark.www    def test_01(self):        print('hello salmon')        pytest -m "smoke and www"</code></pre><h2 id="跳过用例"><a href="#跳过用例" class="headerlink" title="跳过用例"></a>跳过用例</h2><h4 id="无条件跳过"><a href="#无条件跳过" class="headerlink" title="无条件跳过"></a>无条件跳过</h4><p>同样的，我们使用mark进行标记</p><pre class="language-python" data-language="python"><code class="language-python">@pytest.mark.skip()# 还可以说明一下，为什么跳过@pytest.mark.skip(reason='asdasdasd')</code></pre><h4 id="有条件跳过"><a href="#有条件跳过" class="headerlink" title="有条件跳过"></a>有条件跳过</h4><p>依旧是使用mark进行标记，只要满足了某个判断，就可以跳过</p><pre class="language-python" data-language="python"><code class="language-python">a = 1@pytest.mark.skipif(a &gt; 10, reason='因为大于10，所以跳过')</code></pre><h2 id="生成html报告"><a href="#生成html报告" class="headerlink" title="生成html报告"></a>生成html报告</h2><p>前提是，安装了pytest-html</p><p>在pytest.ini文件下，addopts之后添加<code>--html 路径</code></p><pre class="language-python" data-language="python"><code class="language-python">[pytest]addopts = -vs --html ./report/report.htmltestpaths = ./test_pytestpython_files = test*.pypython_classes = Test*python_functions = testMarkers =    smoke:冒烟用例</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytest基础使用</title>
      <link href="/posts/35752/"/>
      <url>/posts/35752/</url>
      
        <content type="html"><![CDATA[<h2 id="pytest单元测试框架"><a href="#pytest单元测试框架" class="headerlink" title="pytest单元测试框架"></a>pytest单元测试框架</h2><ol><li><p>什么是单元测试框架</p><blockquote><p>单元测试是指在软件开发当中，针对软件的最小单位(函数，方法)进行正确性的检查测试</p></blockquote></li><li><p>单元测试框架主要做什么</p><blockquote><p>测试发现：从多个文件里面去找到我们测试用例</p><p>测试执行：按照一定的顺序和规则去执行，并生成结果</p><p>测试判断：通过断言判断预期结果和实际结果的差异</p><p>测试报告：统计测试进度，耗时，通过率，生成测试报告</p></blockquote></li></ol><h2 id="单元测试框架和自动化测试框架的关系"><a href="#单元测试框架和自动化测试框架的关系" class="headerlink" title="单元测试框架和自动化测试框架的关系"></a>单元测试框架和自动化测试框架的关系</h2><p>自动化测试框架：</p><ol><li><p>提高测试效率，降低维护成本</p></li><li><p>减少人工干预，提高测试的准确性，增加代码的重用性</p></li><li><p>核心思想是让不懂代码的人也能够通过这个框架去实现自动化测试</p><p> 单元测试框架只是自动化测试框架的组成部分之一</p></li></ol><h2 id="需要安装的插件"><a href="#需要安装的插件" class="headerlink" title="需要安装的插件"></a>需要安装的插件</h2><pre class="language-none"><code class="language-none">pytestpytest-html  # 生成html格式的自动化测试报告pytest-xdist # 测试用例分布式执行，多CPU分发pytest-ordering # 用于改变测试用例多执行顺序pytest-rerunfailures # 用例失败后重跑allure-pytest # 用于生成美观的测试报告</code></pre><h2 id="默认的测试用例规则"><a href="#默认的测试用例规则" class="headerlink" title="默认的测试用例规则"></a>默认的测试用例规则</h2><ol><li>模块名必须以<code>test_</code>开头或者以<code>_test</code>结尾</li><li>测试类必须以<code>Test</code>开头，并且不能有init方法</li><li>测试方法必须以<code>test</code>开头</li></ol><h2 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h2><h3 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h3><ol><li><p>主函数模式<br> 通过程序入口:<code>if __name__ == '__main__':</code>下来执行</p><blockquote><p>(1) 运行所有：<code>pytest.main()</code><br>(2) 指定模块运行：<code>pytest.main(['文件名'])</code>，如果不指定文件名，它会自动(3) 寻找当前文件夹下所有符合条件的文件并执行。</p><p>指定文件夹执行：<code>pytest.main(['路径/文件夹名'])</code></p><p>(4) 通过nodeid去执行：</p><p>​    解释一下nodeid，nodeid由模块名，分隔符，类名，方法名，函数名组成，        通过<code>::</code>来分割类、方法、函数</p><p><code>pytest.main(['-vs', './文件夹名/文件名::类名::方法名'])</code>，如果是函数测试的话，那直接文件名后用<code>::</code>分割，写上函数即可。</p></blockquote></li><li><p>命令行模式<br> 在当前目录下，执行<code>pytest</code>或者<code>python -m pytest</code></p><blockquote><p>至于，为什么可能会执行<code>python -m pytest</code>呢，是因为有可能你执行pytest会找不到，这是因为通过pip安装pytest不会使其成为系统命令，而是会将其安装到python。-m命令将pytest作为其自己的命令运行，然后任何后续脚本都将作为参数。</p></blockquote></li><li><p>通过读取pytest.ini配置文件运行</p></li></ol><h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h3><p><code>-s</code>: 表示输出调试信息，包括print打印出的信息，如果使用主函数模式，他的传参方式是一个数组，看起来像是这样</p><pre class="language-python" data-language="python"><code class="language-python">pytest.main(['-s'])</code></pre><p>如果是命令行模式，就直接<code>pytest -s</code>即可</p><p><code>-v</code>：输出用例的类名和方法名，可以和<code>-s</code>一起用</p><p><code>-n</code>：支持多线程或者分布式运行测试用例，前提是安装了<code>pytest-xdist</code>，用法，在命令行<code>-n 2</code>代表启用两个线程，这个线程数可以根据需要来自己定义，在入口函数中使用的话，就直接<code>-n=线程数</code>即可</p><p><code>--reruns</code>：代表失败后重跑，前提是安装了<code>pytest-rerunfailures</code>，用法，在命令行<code>--reruns 2</code>即可，后面的数字代表，如果失败了再跑几次，如果超过这个数它还是报错，那就说明这个东西它已经没救了。可以放弃治疗，在入口中，使用方法和<code>-n</code>一致。</p><p><code>-x</code>：只要有一个用例错误，测试停止</p><p><code>--maxfail 2</code>：失败两个用例，才会停止</p><p><code>-k 'XXX'</code>：根据测试用例的部分字符串指定测试用例，比如你的函数名带QQ的，那么，<code>-k 'QQ'</code>，只有带QQ的才会被执行，不带的则会直接跳过</p><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><blockquote><p>pytest默认是从上到下执行，这个和<code>unittest</code>的执行方式不同，<code>unittest</code>的顺序是由<code>ascll</code>码来决定顺序</p></blockquote><h3 id="标记更改执行顺序"><a href="#标记更改执行顺序" class="headerlink" title="标记更改执行顺序"></a>标记更改执行顺序</h3><p>标记更改，手动的去标记某些方法或者函数的执行顺序，这个是需要使用到装饰器，<code>@pytest.mark.run(order=1)</code>的</p><p>order，代表的是第几个执行，例如：order=1，则是第一个执行</p><blockquote><p>前提是，你安装了<code>pytest-ordering</code></p></blockquote><h2 id="配置文件执行"><a href="#配置文件执行" class="headerlink" title="配置文件执行"></a>配置文件执行</h2><blockquote><p>无论是命令行模式还是入口函数模式，真正使用起来并不多，而最多的是使用配置文件，就像我们使用docker，是可以一个个的使用dockerfile来写，但是没人会这么做吧，还是一个docker-componse解决。pytest的配置文件名，是<code>pytest.ini</code>，一般来说，放在文件的根目录，这个没有什么可说的，但是需要 <strong>注意</strong> 的是，他的编码，必须是<code>ANSI</code>，可以使用notpad++来更改，或者更直接点，我们通过python代码来手动更改</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">import osimport codecs# oldfile:UTF8文件的路径# newfile:要保存的ANSI文件的路径def convertUTF8ToANSI(oldfile, newfile):    #打开UTF8文本文件    f = codecs.open(oldfile, 'r', 'utf8')    utfstr = f.read()    f.close()    # 把UTF8字符串转码成ANSI字符串    outansestr = utfstr.encode('mbcs')    # 使用二进制格式保存转码后的文本    f = open(newfile, 'wb')    f.write(outansestr)    f.close()</code></pre><pre class="language-python" data-language="python"><code class="language-python"># 头部格式，不可更改[pytest]# 命令行参数，用空格分割addopts = -vs # 测试用例文件夹路径，可自己配置testpaths = ./test_profile# 配置测试搜索的模块文件名称，我们之前说过，文件名、类名、方法名都必须是固定格式，但是，这里我们变了，我们可以通过这里来设置自己定义的python_files = test*.py# 配置测试搜索的测试类名python_classes = Test*# 配置测试搜索的测试方法名python_functions = test</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apscheduler定时任务</title>
      <link href="/posts/46685/"/>
      <url>/posts/46685/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在web开发中，定时任务在很多场景中是经常用到的，比较常见的定时任务就是linux自带的crontab和celery还有今天要说的这个apscheduler了。</p><p><code>APScheduler</code>基于Quartz的一个Python定时任务框架，实现了Quartz的所有功能，使用起来十分方便。提供了基于日期、固定时间间隔以及crontab类型的任务，并且可以持久化任务。基于这些功能，我们可以很方便的实现一个python定时任务系统。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接使用pip安装即可</p><pre class="language-python" data-language="python"><code class="language-python">pip install apscheduler</code></pre><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>APScheduler由四部分组成，分别是：触发器，作业存储，执行器，调度器。</p></blockquote><p><strong>触发器(trigger)</strong> 包含调度逻辑，每一个作业有它自己的触发器，用于决定接下来哪一个作业会运行。除了他们自己初始配置意外，触发器完全是无状态的。</p><p><strong>作业存储(job store)</strong> 存储被调度的作业，默认的作业存储是简单地把作业保存在内存中，其他的作业存储是将作业保存在数据库中。一个作业的数据讲在保存在持久化作业存储时被序列化，并在加载时被反序列化。调度器不能分享同一个作业存储。</p><p><strong>执行器(executor)</strong> 处理作业的运行，他们通常通过在作业中提交制定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。</p><p><strong>调度器(scheduler)</strong> 是其他的组成部分。你通常在应用只有一个调度器，应用的开发者通常不会直接处理作业存储、调度器和触发器，相反，调度器提供了处理这些的合适的接口。配置作业存储和执行器可以在调度器中完成，例如添加、修改和移除作业。　</p><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>添加任务：</p><pre class="language-python" data-language="python"><code class="language-python">import timefrom apscheduler.schedulers.blocking import BlockingScheduler def my_job():    print time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())) sched = BlockingScheduler()sched.add_job(my_job, 'interval', seconds=5)sched.start()</code></pre><p>上面的例子表示每隔5s执行一次my_job函数，输出当前时间信息</p><blockquote><p>上面是通过add_job()来添加任务，另外还有一种方式是通过scheduled_job()修饰器来修饰函数</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">import timefrom apscheduler.schedulers.blocking import BlockingScheduler sched = BlockingScheduler() @sched.scheduled_job('interval', seconds=5)def my_job():    print time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())) sched.start()</code></pre><p>移除任务：</p><pre class="language-python" data-language="python"><code class="language-python">job = scheduler.add_job(myfunc, 'interval', minutes=2)job.remove()#如果有多个任务序列的话可以给每个任务设置ID号，可以根据ID号选择清除对象，且remove放到start前才有效sched.add_job(myfunc, 'interval', minutes=2, id='4')sched.remove_job('my_job_id')</code></pre><p>暂停任务：</p><pre class="language-python" data-language="python"><code class="language-python">apsched.job.Job.pause()apsched.schedulers.base.BaseScheduler.pause_job()</code></pre><p>恢复任务：</p><pre class="language-python" data-language="python"><code class="language-python">apsched.job.Job.resume()apsched.schedulers.base.BaseScheduler.resume_job()</code></pre><p>查询任务：</p><pre class="language-python" data-language="python"><code class="language-python"># 根据任务设置的id查看某个定时任务详情print(sched.get_job(job_id='4'))# 查看实例下所有定时任务print(sched.get_jobs())</code></pre><p>关闭调度器：</p><blockquote><p>默认情况下调度器会等待所有正在运行的作业完成后，关闭所有的调度器和作业存储。</p><p>如果你不想等待，可以将wait选项设置为False。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">sched.shutdown()sched.shutdown(wait=False)</code></pre><h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p>add_job的第二个参数是trigger，它管理着作业的调度方式。它可以为date, interval或者cron。对于不同的trigger，对应的参数也相同。</p><ul><li><p>date: 定时调度（只会执行一次）</p>  <pre class="language-python" data-language="python"><code class="language-python"># 表示2009年11月6号执行一次sched.add_job(my_job, 'date', run_date=date(2009, 11, 6), args=['text'])</code></pre></li></ul><ul><li><p>interval: 间隔调度（每隔多久执行）</p>  <pre class="language-python" data-language="python"><code class="language-python">#表示每隔3天17时19分07秒执行一次任务sched.add_job(my_job, 'interval',days  = 03,hours = 17,minutes = 19,seconds = 07)</code></pre></li></ul><ul><li><p>cron：定时调度（某一定时时刻执行）</p>  <pre class="language-python" data-language="python"><code class="language-python"># 例子#表示2017年3月22日17时19分07秒执行该程序sched.add_job(my_job, 'cron', year=2017,month = 03,day = 22,hour = 17,minute = 19,second = 07) #表示任务在6,7,8,11,12月份的第三个星期五的00:00,01:00,02:00,03:00 执行该程序sched.add_job(my_job, 'cron', month='6-8,11-12', day='3rd fri', hour='0-3') #表示从星期一到星期五5:30（AM）直到2014-05-30 00:00:00sched.add_job(my_job(), 'cron', day_of_week='mon-fri', hour=5, minute=30,end_date='2014-05-30') #表示每5秒执行该程序一次，相当于interval 间隔调度中seconds = 5sched.add_job(my_job, 'cron',second = '*/5')</code></pre></li></ul><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><blockquote><p>在<code>add_job</code>中，如果调用的是一个有形参的函数，不能够直接在该函数后实例传参，而是应该在add_job里的args或者kwargs里传，所以，假如你有个函数，需要传参db和q</p><p>如果这样写：</p><pre class="language-python" data-language="python"><code class="language-python">ched.add_job(my_job(db,'q'), 'date', run_date='2021-04-06 14:58:40')</code></pre><p>你会看到一个这样的错误：</p><pre class="language-python" data-language="python"><code class="language-python">ValueError: The following arguments have not been supplied: db, q</code></pre><p>正确写法是：</p><pre class="language-python" data-language="python"><code class="language-python">schedule.add_job(hello, 'date', args=[db, 'q'], run_date='2021-04-06 14:59:00')</code></pre></blockquote><p>至于集成到web框架中，尽情期待，有时间了会补上，最后，<a href="https://apscheduler.readthedocs.io/en/stable/userguide.html">官方文档</a>，各位有兴趣可以看一看</p><h2 id="补充一则很难搞的错误"><a href="#补充一则很难搞的错误" class="headerlink" title="补充一则很难搞的错误"></a>补充一则很难搞的错误</h2><blockquote><p>我在使用apscheduler定时任务的时候，将他挂载到了fastapi上，使用起来倒是一点毛病没有，但是，我将他储存的时候，他却给我报了一个这样的错误。</p><pre class="language-none"><code class="language-none">_pickle.PicklingError: Can't pickle &lt;class 'sqlalchemy.orm.session.Session'&gt;: it's not the same object as sqlalchemy.orm.session.Session</code></pre><p>我迟迟没有头绪，而且根据源码，我也确定，我并没有写错什么，但是这个错误就是会出现。</p><p>在我经过了不懈的寻找之后发现….是我自己写的调度函数问题，我在函数中传了一个<code>sqlalchemy.orm.session</code>，然而，它的储存也正好如此，所以，在传参中，他们重复了。</p><p>这个问题，应该很难遇到，因为毕竟没人跟我一样这么搞嘛，不过呢，既然遇到了我就要记录一下，以免再卡这么久。</p><p>只要我们不传session对象就好了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx负载均衡配置</title>
      <link href="/posts/64850/"/>
      <url>/posts/64850/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>nginx的作用呢，相信大家都是特别熟悉的了，这里也就不多说了，但是以防还有处于懵懂状态的同学，还是简单介绍一下负载均衡。</p><p>我们平时在一台服务器搭建起应用后，万一承受量超过了他的极限，这样的话，服务就会垮掉，所以，我们为了不让这样的事情发生，通常情况下是使用nginx的一个负载均衡的功能，他能够将发来的请求，均匀的，或者是特定的去分配给多台服务器，来提高承受并发的能力。</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在<code>/etc/nginx</code>下，(这是默认目录，如果你的nginx不在这里，那去对应的地方即可)</p><p>打开nginx.conf，在http模块下任意位置写上如下配置，这个服务器集群名可以随意起</p><pre class="language-nginx" data-language="nginx"><code class="language-nginx">upstream 服务器集群名{            server 127.0.0.1:8000;            server 39.98.35.129:8000;        }</code></pre><p>然后我们去<code>server</code>配置，然后注释掉我们本来的地址<code>proxy_pass</code>，改为变量绑定，要注意的是，nginx是一个很神奇的东西，所以，多一个斜杠少一个斜杠都会定成败，一定要注意。</p><pre class="language-nginx" data-language="nginx"><code class="language-nginx">location /api/ {            proxy_set_header X-Real-IP $remote_addr;            # proxy_pass http://127.0.0.1:8000/;            proxy_pass http://服务器集群名/;            proxy_set_header   Host    $host;            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;        }</code></pre><p>nginx负载均衡的默认策略是轮询，也就是轮着来，如果你的服务器配置是差不多的情况下，是不用改的。还有一种常见的策略，就是权重，在配置服务器集群的那里，来给每个节点配置不同的权重，他们就会接到对应的几率来获得访问，像这样：</p><pre class="language-nginx" data-language="nginx"><code class="language-nginx">upstream 服务器集群名 {    server 127.0.0.1:8000 weight=3;    server 39.98.35.129:8000 weight=7;}</code></pre><p>ip_hash（ IP绑定）<br>上述方式存在一个问题就是说，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的。</p><p>我们可以采用ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。</p><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><pre class="language-nginx" data-language="nginx"><code class="language-nginx">upstream backserver {    ip_hash;    server 127.0.0.1:8000;    server 39.98.35.129:8000;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu下pip安装问题</title>
      <link href="/posts/37511/"/>
      <url>/posts/37511/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><pre class="language-python" data-language="python"><code class="language-python">Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-buil</code></pre><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>解决方法是更新 setuptools 和 pip：</p></blockquote><pre class="language-bash" data-language="bash"><code class="language-bash">pip install --upgrade setuptoolspython -m pip install --upgrade pip</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker打包vue多处/static/css路径解决办法</title>
      <link href="/posts/61305/"/>
      <url>/posts/61305/</url>
      
        <content type="html"><![CDATA[<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p><strong>在build/utils.js文件中添加publicPath:’…/…/’,重新打包即可。</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">if (options.extract) {      return ExtractTextPlugin.extract({        use: loaders,        fallback: "vue-style-loader",        publicPath: "../../"      });    } else {      return ["vue-style-loader"].concat(loaders);    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac下安装go语言开发环境</title>
      <link href="/posts/51360/"/>
      <url>/posts/51360/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在mac下，homebrew这个包管理工具是每个开发环境必不可少的，然后就是go语言编译器，这是必不可少的，最后就是编辑器，可以用Goland，也可以简单一点的用vscode和sublime</p></blockquote><h2 id="安装homebrew"><a href="#安装homebrew" class="headerlink" title="安装homebrew"></a>安装homebrew</h2><p>Homebrew有点类似于Linux操作系统中的apt-get（Ubuntu）、yum（yum），Mac的操作系统中使用它解决包依赖问题，套用官方的话来说：</p><h3 id="Homebrew-能干什么"><a href="#Homebrew-能干什么" class="headerlink" title="Homebrew 能干什么?"></a>Homebrew 能干什么?</h3><p>使用 Homebrew 安装 Apple 没有预装但 <a href="https://formulae.brew.sh/formula/">你需要的东西</a>。</p><p>输入命令，安装:</p><pre class="language-none"><code class="language-none">fabric:~ fabric$ ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</code></pre><p>出现这样内容，就是安装成功了</p><pre class="language-none"><code class="language-none">==&gt; Installation successful!==&gt; Homebrew has enabled anonymous aggregate user behaviour analytics.Read the analytics documentation (and how to opt-out) here:  https://docs.brew.sh/Analytics.html==&gt; Next steps:- Run `brew help` to get started- Further documentation:     https://docs.brew.sh</code></pre><h2 id="安装go"><a href="#安装go" class="headerlink" title="安装go"></a>安装go</h2><blockquote><p>我们可以选择使用brew安装go，也可以直接去<a href="https://golang.google.cn/dl/">官网</a>，选择需要的版本来进行安装。</p><p>官网安装比较简单，就是无脑下一步就可以了，安装包会默认安装在<code>/usr/local</code>目录下。</p></blockquote><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>首先需要查看你的go目录，默认是<code>/usr/local</code>，然后进入这个目录，再cd到go中，查看是否在此，确认之后，就可以直接在<code>~/.bash_profile</code>中，添加以下：</p><pre class="language-none"><code class="language-none">export PATH=$PATH:/usr/local/go/bin</code></pre><p>然后重启<code>source .bash_profile</code></p><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>理论上，你现在使用终端输入go应该是不好使的，因为没有配置环境变量，如果你之前有<code>bash_profile</code>文件，那就打开就好了，执行<code>cd ~</code>和<code>.bash_profile</code>添加上这两行：</p><pre class="language-none"><code class="language-none">export GOROOT=/usr/local/goexport PATH=$GOROOT/bin</code></pre><p>然后保存，退出，运行此命令，使环境变量生效</p><pre class="language-none"><code class="language-none">source ~/.bash_profile</code></pre><h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><blockquote><p>使用第二种方法的人，可能有的人关闭终端后，会突然性的发现，什么命令都用不了了，emmmm…，不过不用担心，有办法，首先终端输入:</p></blockquote><pre class="language-none"><code class="language-none">export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin" </code></pre><p>然后暂时性的命令可以用了，然后打开<code>vim ~/.bash_profile</code>，在<strong>最后</strong>一行，把上面的命令添加上去，然后保存，执行<code>source ~/.bash_profile </code>， 之后就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlalchemy的事务</title>
      <link href="/posts/38315/"/>
      <url>/posts/38315/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>说起事务，后端工程师都不会陌生，这是存在于关系型数据库中的一个特性，它具有四个特性：</p><ul><li>原子性<br>事务包含的所有操作要么都执行成功，要么都失败，不可分割</li><li>一致性<br>中间过程不管怎么执行，结果一定是一致的</li><li>隔离性<br>事务在执行过程中，不受其他事务的影响</li><li>持久性<br>执行成功之后，结果时永久修改的，不能撤回</li></ul><p>MySQL执行的SQL是autocommit的，SALAlchemy 查询语句也是 autocommit的，就是说如果没有明确声明事务的begin，每个单独的SQL都是一个独立的事务。但是在做交易系统时，比如银行给用户A转账给用户B时，有两个操作，从A里面减100，然后给B加100。这两个操作必须放在一个事务里面才行，否是就会出现钱扣了，对方又没到账的情况。</p><p>所以，事务，是sqlalchemy乃至所有orm不可或缺的一环</p></blockquote><h2 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h2><blockquote><p>开启事务有两种方法，这里只说最简单的一种方法，就是利用with，为了更加真实的模拟业务场景，我们创建两张表和sqlalchemy的连接</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from sqlalchemy import create_engine, Column, Integer, Stringfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmakerconnect = create_engine('mysql+pymysql://root:root@localhost:3306/test01')ModelBase = declarative_base()class User(ModelBase):    # 定义表名    __tablename__ = "user"    # 声明字段    id = Column(Integer, primary_key=True)    name = Column(String(length=255))class Role(ModelBase):    __tablename__ = 'role'    id = Column(Integer, primary_key=True)    role = Column(String(length=255))    DBSession = sessionmaker(bind=connect,autoflush=False, autocommit=False, expire_on_commit=True)</code></pre><p>然后我们利用一个fastapi框架来模拟一下</p><pre class="language-python" data-language="python"><code class="language-python">from fastapi import FastAPI, HTTPException, statusapp = FastAPI()@app.get('/')async def create_sqlalchemy():  # 使用上下文管理器开启事务    with DBSession.begin() as session:        data = {            "id": 0,            'name': 'Salmon'        }        # 添加user数据        new_user = User(**data)        session.add(new_user)        data2 = {            'id': 0,          # 'id':'添加错误数据'            'role':'SuperUser1'        }        # 添加role数据        new_role = Role(**data2)        session.add(new_role)        # 模拟错误        if data2['role'] == 'SuperUser1':          raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST)    return 'ok'</code></pre><blockquote><p>需要知道的是，在事务开启后，使用with不需要自己来执行commit操作,执行完sql会自动提交，如果报异常会自动rollback 。</p><p>我们这里，主动抛出异常，两个表中的数据都没有改变。然后我们发送一个错误数据，不主动抛出，再来试试，解开那个id注释。然后把if和raise这两行删掉，然后，引发他原生错误。数据也不会发生改变。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastAPI </tag>
            
            <tag> SQLAlchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac下破解pycharm</title>
      <link href="/posts/32237/"/>
      <url>/posts/32237/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>提起写python最好的编辑器，你能想起来什么，vscode？sublime？No，我认为最好的还是pycharm，虽然他过于重量级，但是，论代码提示和python的功能，最好用的python编辑器还是非pycharm莫属，只是一个缺点，这个货，他要钱。。</p><p>对于有资金的大佬，还是建议直接购买官方正品。但是像我这种穷人，只能够忍着眼泪(😂)，开始破解了。</p></blockquote><h2 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h2><blockquote><p>下载pycharm，可以直接下载官方正版的，我这边使用的是2020.3版本，下载完之后，打开，试用，这都不说了。</p></blockquote><p>关注公众号：程序员软件库，回复758344，获取下载链接和提取码。</p><p>ps：这不是我的广告啊，只是我懒得把它放到自己的网盘了，不过多一步的事情，不必在意这么多啦。😁</p><ol><li><p>然后下载出来之后，将 <strong>ide-eval-resetter.zip</strong> 插件拖动至 PyCharm 主界面中，对，你没看错，直接拖。</p></li><li><p>提示重启PyCharm ，如下图</p><blockquote><p>ps：有的不提示重启，可直接跳过此步骤。插件直接在界面底部显示</p></blockquote><img src="/posts/32237/image-20210318115930677.png" alt style="zoom:67%;" loading="lazy"></li><li><p>重启完成并进入PyCharm主界面，点击菜单【Help】-&gt;【Eval Reset】</p><img src="/posts/32237/image-20210318120046508.png" alt style="zoom:50%;" loading="lazy"></li><li><p>然后钩上这个框之后，重启pycharm</p><img src="/posts/32237/image-20210318120231558.png" alt="image-20210318120231558" style="zoom:50%;" loading="lazy"></li><li><p>然后点击【Help】-&gt;【Register】，查看一下试用期，续命成功！</p><img src="/posts/32237/image-20210318120543696.png" alt style="zoom:50%;" loading="lazy"></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>那什么，有力量的还是支持正版哈。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协同过滤算法</title>
      <link href="/posts/a10feb4a/"/>
      <url>/posts/a10feb4a/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>协同过滤算法，这是一个比较著名的推荐算法，其主要的功能就是预测和推荐，算法通过对用户历史行为数据的挖掘发现用户的偏好，基于不同的偏好对用户进行群组划分并推荐品味相似的商品，协同过滤算法分为两类，分别是基于用户的协同过滤算法和基于物品的协同过滤算法，简单的说，就是物以类聚，人以群分。</p></blockquote><h2 id="基于用户的协同过滤"><a href="#基于用户的协同过滤" class="headerlink" title="基于用户的协同过滤"></a>基于用户的协同过滤</h2><blockquote><p>基于用户的协同过滤算法是通过用户的历史行为数据发现用户对商品或内容的喜欢(如商品购买，收藏，内容评论或分享)，并对这些喜好进行度量和打分。根据不同用户对相同商品或内容的态度和偏好程度计算用户之间的关系。在有相同喜好的用户间进行商品推荐。</p></blockquote><p>说的再简单点，就是，你去买了一个XX手办，对它评价挺高，然后有一个路人甲也买了一个XX手办，评价和你很类似，然后根据算法算出你们的喜好可能是相近的，所以，下次路人甲买了其他的商品，也会把这件商品推荐给你，因为你们的相似度很高。当然了，这就是一个例子，商品的数量足够多，那么，推荐的也就越准确。</p><p>实现这个协同过滤算法的第一个重要步骤就是计算用户之间的相似度。而 计算相似简历相关系数矩阵目前主要分为：</p><ol><li>皮尔逊相关系数</li><li>基于欧几里德距离的相似度</li><li>余弦相似度</li></ol><p>我们这里就说基于欧几里德距离(又称欧式距离)这一种。</p><p>欧式距离计算相似度是所有相似度计算里面最简单、最易理解的方法。它以经过人们一致评价的物品为坐标轴，然后将参与评价的人绘制到坐标系上，并计算他们彼此之间的直线距离。计算出来的欧几里德距离是一个大0的数，为了使其更能体现用户之间的相似度，可以把它规约到(0.1]之间，最终得到如下计算公式：<br><img src="/posts/a10feb4a/image-20210316173558673.png" alt style="zoom:30%;" loading="lazy"></p><p>只要有一个共同评分的项，就能用欧式距离计算相似度，如果没有共同评分项，那也就意味着两个用户或者物品并不相似。</p><h2 id="python实现协同过滤"><a href="#python实现协同过滤" class="headerlink" title="python实现协同过滤"></a>python实现协同过滤</h2><blockquote><p>我们使用代码来实现一下协同过滤，我们首先创造模型，比如说，我们都喜欢看动漫，我们就可以根据个人的喜好来进行推荐，首先，新建txt文件，名字随意。</p></blockquote><pre class="language-txt" data-language="txt"><code class="language-txt">1,海贼王,2.01,火影忍者,5.01,全职猎人,2.62,刀剑神域,1.02,海贼王,5.02,犬夜叉,4.63,画江湖,2.03,全职高手,5.03,喜羊羊与灰太狼,2.6</code></pre><p>解释一下：1喜欢看海贼王，给出了2.0的评分。以此类推，可以看到，1、2、3三个人中，只有1和2喜欢看海贼王，这也是他们之间唯一的交集。</p><pre class="language-python" data-language="python"><code class="language-python">content = []with open('./comic.txt') as fp:    content = fp.readlines()print(content)</code></pre><p>首先，读取，这里就不用多说了。</p><pre class="language-python" data-language="python"><code class="language-python"># 将用户、评分、和动漫写入字典datadata = {}for line in content:  # 处理掉多余的空格并分割    line = line.strip().split(',')    # 如果字典中没有某位用户，则使用用户ID来创建这位用户    if not line[0] in data.keys():        data[line[0]] = {line[1]: line[2]}    # 否则直接添加以该用户ID为key字典中    else:        data[line[0]][line[1]] = line[2]print(data)</code></pre><pre class="language-python" data-language="python"><code class="language-python">def Euclid(user1, user2):    # 取出两位用户看过的动漫和评分    user1_data = data[user1]    user2_data = data[user2]    distance = 0    # 找到两位用户都看过的动漫，并计算欧式距离    for key in user1_data.keys():        if key in user2_data.keys():            # 注意，distance越大表示两者越相似            distance += pow(float(user1_data[key]) - float(user2_data[key]), 2)    return 1 / (1 + sqrt(distance)) # 这里的返回值越小，相似度越大</code></pre><p>计算某个用户和其他用户的相似度</p><pre class="language-python" data-language="python"><code class="language-python">def top_simliar(userID):    res = []    for userid in data.keys():        # 排除与自己计算相似度        if not userid == userID:            simliar = Euclid(userID, userid)            res.append((userid, simliar))    # 排序    res.sort(key=lambda val: val[1])    return res</code></pre><p>可以看到，与其他两位用户的相似度已经被推算出来了。</p><p>接下来，我们可以根据相似度来进行推送，按照我们这个例子，1和2之间是唯一有交集的，如果我们要给1推送，也只能推送2看过的，也就是犬夜叉和刀剑神域。</p><pre class="language-python" data-language="python"><code class="language-python">def recommend(user):    # 相似度最高的用户    top_sim_user = top_simliar(user)[0][0]    # 相似度最高的用户看过的动漫    items = data[top_sim_user]    recommendations = []    # 筛选出该用户未看过的动漫    for item in items.keys():        if item not in data[user].keys():            recommendations.append((item, items[item]))    recommendations.sort(key=lambda val: val[1], reverse=True)  # 按照评分排序    return recommendations</code></pre><p>ok，结果还算不错，按照我们所想。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Casbin</title>
      <link href="/posts/56743/"/>
      <url>/posts/56743/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>什么是casbin，Casbin是一个强大的、高效的开源访问控制框架，其权限管理机制支持多种访问控制模型。</p></blockquote><p>Casbin<strong>可以</strong>做到：</p><ol><li>支持自定义请求的格式，默认的请求格式为<code>{subject, object, action}</code>。</li><li>具有访问控制模型model和策略policy两个核心概念。</li><li>支持RBAC中的多层角色继承，不止主体可以有角色，资源也可以具有角色。</li><li>支持超级用户，如<code>root</code>或<code>Administrator</code>，超级用户可以不受授权策略的约束访问任意资源。</li><li>支持多种内置的操作符，如<code>keyMatch</code>，方便对路径式的资源进行管理，如<code>/foo/bar</code>可以映射到<code>/foo*</code></li></ol><p>Casbin<strong>不能</strong>做到：</p><ol><li>身份认证 authentication（即验证用户的用户名、密码），casbin只负责访问控制。应该有其他专门的组件负责身份认证，然后由casbin进行访问控制，二者是相互配合的关系。</li><li>管理用户列表或角色列表。 Casbin 认为由项目自身来管理用户、角色列表更为合适， 用户通常有他们的密码，但是 Casbin 的设计思想并不是把它作为一个存储密码的容器。 而是存储RBAC方案中用户和角色之间的映射关系。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>python使用casbin需要安装，命令是</p><pre class="language-python" data-language="python"><code class="language-python">pip install casbin</code></pre><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><blockquote><p>在 Casbin 中, 访问控制模型被抽象为基于<strong>PERM</strong>(Policy(策略), Effect(效果), Request(请求), Matcher(匹配器))的一个文件。 因此，切换或升级项目的授权机制与修改配置一样简单。 您可以通过组合可用的模型来定制您自己的访问控制模型。 例如，您可以在一个model中获得RBAC角色和ABAC属性，并共享一组policy规则。</p></blockquote><p>比如说，我们定义一个<code>model.conf</code>来实现ACL模型</p><pre class="language-none"><code class="language-none"># 请求定义[request_definition]r = sub, obj, act# 策略定义[policy_definition]p = sub, obj, act# 策略效果[policy_effect]e = some(where (p.eft == allow))# 匹配器[matchers]m = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</code></pre><blockquote><p>⚠！这里注重说一下匹配器，这代表了你的匹配规则，比如现在这个例子，只有请求(r)和定义的策略(p)完全一致，才可以被认可。</p></blockquote><p>ACL模型的示例，我们创建一个<code>policy.csv</code>：</p><pre class="language-none"><code class="language-none">p, alice, data1, readp, bob, data2, write</code></pre><p>这表示，alice可以读取data1，bob可以编写data2</p><p>然后我们在同级目录下测试，新建一个py文件</p><pre class="language-python" data-language="python"><code class="language-python">import casbine = casbin.Enforcer("./model.conf", "./policy.csv")# 你的请求sub = "alice"obj = "data1"act = "read"if e.enforce(sub, obj, act):    print('通过')else:    print("拒绝")</code></pre><blockquote><p>解释一下，我们通过<code>casbin</code>的<code>Enforcer</code>引入，然后定义了三个变量，去通过<code>enforce</code>验证他们，这也就代表了，他们会去<code>policy.csv</code>去查找策略，然后通过匹配器来进行匹配，如果通过了，他将会为你返回一个<code>casbin</code>，这是个布尔值。</p></blockquote><h2 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h2><p>我们再来演示一下<code>RBAC</code>，首先需要在<code>model.conf</code>中更改一下策略，新增加一个<code>role_definition</code>，然后更改一下匹配器的策略。所以，你的<code>model.conf</code>看起来像是这样</p><pre class="language-none"><code class="language-none">[request_definition]r = sub, obj, act[policy_definition]p = sub, obj, act[role_definition]g = _,_[policy_effect]e = some(where (p.eft == allow))[matchers]m = g(r.sub,p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act</code></pre><blockquote><p>Casbin 支持 RBAC 系统的多个实例, 例如, 用户可以具有角色及其继承关系, 资源也可以具有角色及其继承关系。 这两个 RBAC 系统不会互相干扰。</p><p>此部分是可选的。 如果在模型中不使用 RBAC 角色, 则省略此部分。</p></blockquote><ul><li><code>_, _</code>表示角色继承关系的前项和后项，即前项继承后项角色的权限。</li></ul><p>然后，我们在<code>policy.csv</code>中重新定义我们的策略。</p><pre class="language-none"><code class="language-none">p, superuser, data1, allg, alice, superuser</code></pre><blockquote><p>首先，就是superuser有对data1资源的所有操作，而，alice的角色正好是superuser</p></blockquote><p>ok，那让我们回到py文件</p><p>首先，实例化这块没有什么改变，我们首先验证一下，你输入的用户是否有角色了。我们使用<code>has_role_for_user</code></p><pre class="language-python" data-language="python"><code class="language-python">import casbindd = casbin.Enforcer("./model.conf", "./policy.csv")sub = "alice"obj = "data1"act = "all"a = dd.has_role_for_user(sub,'superuser')print(a)</code></pre><p>返回的是一个布尔值，这是我们在<code>policy.csv</code>定w的alice是superuser。</p><p>如果说，你想要为这个用户添加角色，则可以使用<code>add_role_for_user</code>，如果用户已经有该角色了，则返回false，这一块还没有太了解是会更改policy.csv还是说别的什么，所以，这一块暂时只能是先搁置了，后续待补。。。</p>]]></content>
      
      
      <categories>
          
          <category> Casbin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Casbin </tag>
            
            <tag> FastAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker详解(巨详)</title>
      <link href="/posts/11581/"/>
      <url>/posts/11581/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><blockquote><p>  类似于虚拟机镜像、或者是面对对象里的”类”。如果一个镜像可以包含一个基本的操作系统环境，里面仅安装Apache，就可以把它称为Apache镜像，镜像是创建 docker 容器的基础。</p><p>  <strong>注意：镜像自身是只读的，容器从镜像启动的时候，会在镜像的最上层创建一个可写层。</strong></p></blockquote><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><blockquote><p>  类似于一个轻量级的沙箱，或者是面对对象里的 “对象”。 docker  利用容器来运行和隔离应用，容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而且这些容器都是彼此相互隔离的，互不可见的。</p><p>  可以把容器看作是一个简易版的Linux系统环境，以及运行在其中的应用程序打包而成的盒子。</p></blockquote><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><blockquote><p>  类似于代码仓库，它是  docker 集中存放镜像文件的场所，一个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的标签（tag）来进行区分。</p><p>  例如：存放 ubuntu 镜像的仓库称为 ubuntu 仓库，其中可能包含14.04、12.04等不同版本的镜像。</p><p>   docker  仓库分为公开仓库和私有仓库，比较出名的公开仓库有： docker  Hub、时速云、aliyun 等。 </p></blockquote><h2 id="安装及配置"><a href="#安装及配置" class="headerlink" title="安装及配置"></a>安装及配置</h2><blockquote><ol><li> 卸载旧版本 ：yum remove  docker * ；</li><li> 安装  docker ：yum -y install  docker ，如果提示您接受 GPG 密钥，请选“是” ；</li><li> [可选] 配置用户组： docker  安装后自动创建 docker 用户组，我们可以将用户添加到 docker 用户组，可以避免每次都使用 sudo 运行：usermod -aG docker YOUR_NAME ；</li><li> [可选] 让 docker 服务可以通过本地 2375 端口接受来自外部的请求：docker _OPTS=”$ docker _OPTS -H tcp://0.0.0.0:2375 -H unix:/// /var/run/ docker .sock” ；</li><li> [可选] 然后重启 docker 服务：systemctl restart  docker ；</li><li> 启动 docker ：systemctl start  docker ；</li><li> 运行 hello-world 镜像来验证是否正确安装 ：docker  run hello-world ；</li></ol></blockquote><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><blockquote><ul><li><p>  info：显示 docker 系统信息，包括镜像和容器数；</p></li><li><p>  version：显示 docker 版本信息；</p></li></ul></blockquote><h2 id="仓库管理命令"><a href="#仓库管理命令" class="headerlink" title="仓库管理命令"></a>仓库管理命令</h2><blockquote><ul><li><p>login ：登陆到一个 docker 镜像仓库，未指定镜像仓库地址，默认为官方仓库 docker Hub ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker login [Options] [SERVER][Options]:-u: 登陆的用户名    -p: 登陆的密码</code></pre></li><li><p>logout ：登出镜像仓库，未指定镜像仓库地址，默认为官方仓库 docker Hub ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker logout [SERVER]</code></pre></li><li><p>pull ：从镜像仓库中拉取或者更新指定镜像 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker pull [Options] NAME[:TAG][Options]:-a: 拉取所有 tagged 镜像--disable-content-trust: 忽略镜像的校验,默认开启</code></pre></li><li><p>push ：将本地的镜像上传到镜像仓库 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker push [Options] NAME[:TAG][Options]:--disable-content-trust: 忽略镜像的校验,默认开启</code></pre></li><li><p>search ：从 docker  Hub 查找镜像 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker search [Options] Name[Options]:--automated: 只列出 automated build 类型的镜像--no-trunc: 显示完整的镜像描述-s: 列出收藏数不小于指定值的镜像-f：过滤条件？</code></pre></li></ul></blockquote><h2 id="镜像管理命令"><a href="#镜像管理命令" class="headerlink" title="镜像管理命令"></a>镜像管理命令</h2><blockquote><ul><li><p>images：列出所有本地镜像 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker images [Options] [REPOSITORY[:TAG]][Options]:-a: 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）--digests: 显示镜像的摘要信息-f: 显示满足条件的镜像--format: 指定返回值的模板文件 --no-trunc: 显示完整的镜像信息 -q: 只显示镜像ID</code></pre></li><li><p>rmi : 删除本地一个或多少镜像 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker rmi [OPTIONS] IMAGE [IMAGE...]-f: 强制删除--no-prune: 不移除该镜像的过程镜像，默认移除</code></pre></li><li><p>tag : 为镜像添加一个标签 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker tag  IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</code></pre></li><li><p>history：查看指定镜像的创建历史 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker history [Options] IMAGE[Options]:-H: 以可读的格式打印镜像大小和日期，默认为true--no-trunc: 显示完整的提交记录-q: 仅列出提交记录ID</code></pre></li><li><p>save：将指定镜像保存成 tar 归档文件 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker save [Options] IMAGE [IMAGE...][Options]:-o: 输出到的文件# 示例：$ docker save centos_test_v3.tar centos:v3</code></pre></li><li><p>load：导入使用 save 命令导出的镜像 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker load [Options][Options]:--input,-i :指定导入的文件，代替 STDIN--quiet,-q :精简输出信息# 示例1：$ docker load &lt; busybox.tar.gz# Loaded image: busybox:latest# 示例2:$ docker load --input fedora.tar# Loaded image: fedora:latest</code></pre></li><li><p>import：导入镜像 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker  import [Options] file|URL(压缩文件或url) [容器名:标签][Options]:-c: 应用 docker 指令创建镜像-m: 提交时的说明文字# 示例：$ docker import centos_test.tar os/centos_test:v2</code></pre></li></ul></blockquote><h2 id="容器管理命令"><a href="#容器管理命令" class="headerlink" title="容器管理命令"></a>容器管理命令</h2><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><blockquote><ul><li><p>run：根据镜像创建并启动一个容器 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker run [Options] image-name[Options]:-i: 以交互模式运行容器，通常与 -t 同时使用    -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用    -a: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项    -d: 后台运行容器，并返回容器ID    -p: 指定端口映射，格式为：8000:8000    -m: 设置容器使用内存最大值    -P: 随机端口映射，容器内部端口随机映射到主机的高端口    -e username="ritchie": 设置容器的环境变量    -h "mars": 指定容器的 hostname    --restart='always': 设置容器自动重启，[no:不重启/on-failure:非0退出时重启]    --name="nginx-lb":为容器指定一个名称    --network='bridge'：指定容器的网络    --privileged=True：让容器获取宿主机 root 权限    --link=[]: 添加链接到另一个容器    --volume,-v: 绑定一个卷    --dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致    --dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致    --env-file=[]: 从指定文件读入环境变量    --cpuset="0,1,2": 绑定容器到指定CPU运行    --net="bridge": 指定容器的网络连接类型，支持 bridge/host/none/container    --expose=[]: 开放一个端口或一组端口    --rm：退出容器时删除容器</code></pre></li><li><p>create：创建一个新的容器但不启动它 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker create [Options] IMAGE [COMMAND] [ARG...][Options]: 命令同 run</code></pre></li><li><p>start/stop/restart：启动/停止/重启 一个或多个容器 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker stop id/name[容器2, ...]docker start id/name[容器2, ...]docker restart id/name[容器2, ...]</code></pre></li><li><p>pause/unpause ：暂停/恢复 一个或多个容器进程 ；</p>  <pre class="language-SHELL" data-language="SHELL"><code class="language-SHELL">docker pause id/name[容器2, ...]docker unpause id/name[容器2, ...]</code></pre></li><li><p>kill：杀掉一个运行中的容器 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker kill [Options] id/name[Options]:-s :向容器发送一个信号# 示例：$ docker kill -s KILL mynginx</code></pre></li><li><p>rm：删除容器 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker rm [Options] id/name[容器2, ...][Options]: -f: 强制删除一个运行中的容器-l: 移除容器间的网络连接，而非容器本身 -v: 删除与容器关联的卷# 示例1：删除所有未运行的容器$ docker rm $(docker ps -aq)# 示例2：删除所有终止状态的容器$ docker container prune</code></pre></li></ul></blockquote><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><blockquote><ul><li><p>ps：查看容器 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker ps [Options][Options]:-a: 显示所有的容器，包括未运行的-q: 只显示容器编号-l: 显示最近创建的容器-n: 列出最近创建的n个容器-s: 显示总的文件大小-f: 根据条件过滤显示的内容--format : 指定返回值的模板文件--no-trunc: 不截断输出</code></pre></li><li><p>exec：进入容器或在运行的容器中执行命令 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker exec [Options] id/name COMMAND [ARG...][Options]:-d: 后台运行-i: 即使没有附加也保持 STDIN 打开-t: 分配一个伪终端COMMAND：要在容器中执行的命令[ARG...]: 命令的参数# 示例：$ docker exec -it c3c7732da20e /bin/bash</code></pre></li><li><p>top：查看容器中运行的进程信息 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker top id</code></pre></li><li><p>logs：查看容器日志 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker logs [Options] id/name[Options]:-t: 显示时间戳-f: 跟踪日志输出--tail: 仅列出最新N条容器日志--since: 显示某个开始时间的所有日志</code></pre></li><li><p>inspect： 获取容器/镜像的元数据（配置信息）。</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker inspect [Options] id/name[Options]:-s: 显示总的文件大小-f: 指定返回值的模板文件--type: 指定返回类型 JSON</code></pre></li><li><p>attach：进入容器 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker attach [Options] id/name[Options]:--sig-proxy=false: 退出容器时不停止容器注意：使用 attach 进入容器，ctrl + c/d 退出容器时会停止容器，所以需要使用 --sig-proxy=false 参数</code></pre></li><li><p>events: 从服务器获取实时事件 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker events [Options][Options]:-f：根据条件过滤事件--since：从指定的时间戳后显示所有事件--until：流水时间显示到指定的时间为止</code></pre></li><li><p>wait: 阻塞运行直到容器停止，然后打印出它的退出代码 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker wait id/name</code></pre></li><li><p>export：导出容器 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker export [Options] id/name[Options]:-o: 将输入内容写到文件# 示例1：将 id 为 abcdefg 的容器按日期保存为tar文件$ docker export -o centos-'date +%Y%m%d'.tar abcdefg # 示例2：将容器 test_centos 导出为 centos_test.tar$ docker export test_centos &gt; ./centos_test.tar</code></pre></li><li><p>port：列出指定的容器的端口映射</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker port id/name</code></pre></li><li><p>  rename：重命名一个容器 ；</p></li><li><p>  update：更新一个或多个容器的配置 ；</p></li></ul></blockquote><h3 id="容器rootfs"><a href="#容器rootfs" class="headerlink" title="容器rootfs"></a>容器rootfs</h3><blockquote><ul><li><p>commit：根据容器创建一个新的镜像 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker commit [Options] id/name 镜像名:标签[Options]:    -a: 提交的镜像作者    -c: 使用 docker file指令来创建镜像    -m: 提交时的说明文字    -p: 在commit时，将容器暂停</code></pre></li><li><p>cp：用于容器与主机之间的数据拷贝 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell"># 将容器内数据拷贝到外部docker cp [Options] id/name:from_path to_host_path# 将外部数据拷贝到容器内docker cp [Options] from_host_path id/name:to_path[Options]:-L: 保持源目标中的链接</code></pre></li><li><p>diff：检查容器里文件结构的更改 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker diff id/name</code></pre></li></ul></blockquote><h2 id="网络管理命令"><a href="#网络管理命令" class="headerlink" title="网络管理命令"></a>网络管理命令</h2><h3 id="docker-network"><a href="#docker-network" class="headerlink" title="docker  network"></a>docker  network</h3><blockquote><ul><li><p>create：创建一个 docker 网络 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker network create [OPTIONS] net_name[OPTIONS]:-d：指定 docker 网络类型，有 bridge、overlay 等类型</code></pre></li><li><p>ls：查看已有的 docker 网络 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker network ls-q：仅显示网络id-f：过滤条件# 示例：根据网络类型过滤$ docker network ls -f 'driver=bridge'</code></pre></li><li><p>connect：将容器连接到网络 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker network connect net_name container_id/name</code></pre></li><li><p>disconnect：断开容器与网络的连接 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker network disconnect [OPTIONS] net_name container_id/name[OPTIONS]:-f：强制断开</code></pre></li><li><p>inspect：显示一个或多个网络上的详细信息 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker network inspect [Options] net_name[Options]:-f：用给定的模版格式化输出信息</code></pre></li><li><p>rm：删除1个或多个网络 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker network rm net_name[net_2, ...]</code></pre></li><li><p>prune：删除所有未使用的网络 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker network prune [OPTIONS][OPTIONS]:-f：不提示确认</code></pre></li></ul></blockquote><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><blockquote><p>  dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p></blockquote><h2 id="构建命令"><a href="#构建命令" class="headerlink" title="构建命令"></a>构建命令</h2><blockquote><ul><li><p>build：dockerfile 利用 build 命令来构建一个镜像 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">docker build [Options] image_name:tag dockerfile_path[Options]:    -c：cpu核心数    -m：最大内存    -t：镜像标记    # 注意：存放 dockerfile 的文件夹中不要放无关的文件，因为 docker 会收集 dockerfile工作路径的所有文件用来构建镜像!</code></pre></li></ul></blockquote><h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><blockquote><p>  dockerfile 分为四个部分：基础镜像信息、维护者信息、镜像操作执行、容器启动时执行的指令 ；</p><ul><li><p>FROM：指定要引用的基础镜像，先从本地找，找不到再去 docker  hub 找 ；</p><p>  <strong>注意事项：</strong></p><ul><li><p>  基础镜像有 tag 一定要带上，否则不识别 ；</p></li><li><p>  任何 dockerfile 的第一条指令必须为 FROM ；</p></li><li><p>如果在同一个 dockerfile 中创建多个镜像，可以使用多个 FROM 指令；</p><pre class="language-shell" data-language="shell"><code class="language-shell">FROM centos:7.5.1804</code></pre></li></ul></li><li><p>RUN：在镜像 build 时执行命令 ；</p><p>  <strong>注意事项：</strong></p><ul><li><p>RUN 指令每执行一次都会在 docker 上新建一层镜像，造成镜像膨胀，所以无必要的话应该用 <code> &amp;&amp;</code> 连接多个指令；</p><pre class="language-shell" data-language="shell"><code class="language-shell"># 使用 RUN 指令有两种方式：# 1. 默认使用 shell 执行命令，RUN &lt;command&gt;# 示例1：RUN -c  # 等价于 /bin/sh -c# 2. 推荐用法，采用 exec 的格式执行命令RUN ["executable", "param1", "param2"] "executable"：可执行文件"param1"，"param2"：执行时的参数# 示例2：RUN ["/bin/bash", "-c", "echo hello"]  # RUN /bin/bash -c echo helloRUN ["./test.php", "dev", "offline"]  # RUN ./test.php dev offline# 示例3：使用 &amp;&amp; 连接多个命令FROM centosRUN yum install wget \    &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \    &amp;&amp; tar -xvf redis.tar.gz</code></pre></li></ul></li><li><p>CMD：类似于 RUN，为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束 ；</p><p>  <strong>注意事项：</strong></p><ul><li><p>  类似于 RUN 指令，但二者运行的时间点不同，CMD 在 docker run 时运行。</p></li><li><p>每个  dockerfile 只能有 1 个 CMD 指令，如有多个只会执行最后一条，且如用户启动容器时指定了运行的命令，则会覆盖 CMD 的命令；</p><pre class="language-shell" data-language="shell"><code class="language-shell"># 有三种格式：CMD &lt;command&gt;CMD ["executable", "param1", "param2"]# 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数CMD ["param1", "param2"] </code></pre></li></ul></li><li><p>ENTRYPOINT：类似于 CMD 指令，但不会被 docker run 的指定的参数覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序 ；</p><p>  <strong>注意事项：</strong></p><ul><li><p>  CMD 指令指定参数将会成为 ENTRYPOINT 指定命令的参数 ；</p></li><li><p>  每个 dockerfile 只能有1个 ENTRYPOINT 指令，当有多个时只有最后一个生效 ；</p></li><li><p>会被 docker run 时指定的 –entrypoint 参数覆盖 ；</p><pre class="language-shell" data-language="shell"><code class="language-shell">FROM nginxENTRYPOINT ["nginx", "-c"] # 定参CMD ["/etc/nginx/nginx.conf"] # 变参 # 当不传参启动容器时$ docker run nginx:test  # 容器内执行$ nginx -c /etc/nginx/nginx.conf  # 当传参启动容器时$ docker run nginx:test -c /etc/nginx/new.conf# 容器内执行$ nginx -c /etc/nginx/new.conf</code></pre></li></ul></li><li><p>ENV：指定环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量，在此镜像启动的容器中也会存在。</p><p>  <strong>注意事项：</strong></p><ul><li><p>  可以有多个 ENV</p></li><li><p>该指令指定的环境变量会被启动容器时的 –env 参数覆盖</p><pre class="language-shell" data-language="shell"><code class="language-shell">ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; &lt;key2&gt;=&lt;value2&gt; ...</code></pre></li></ul></li><li><p>ARG：构建参数，与 ENV 作用一至，不过作用域不一样，ARG 设置的环境变量仅在 docker build 的过程中有效 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">ARG &lt;name&gt; &lt;value&gt;ARG &lt;name&gt;=&lt;value&gt;</code></pre></li><li><p>WORKDIR：为后续的 RUN、CMD 和 ENTRYPOINT 指令配置工作目录，可以使用多个指令，后续的指令如果是相对路径，则会基于之前命令指定的路径；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">WORKDIR /path/to/workdir</code></pre></li><li><p>COPY：从宿主机复制数据到容器中 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">COPY &lt;src&gt; &lt;dest&gt;src: 宿主机源路径dest: 容器内目标路径，可以是绝对路径，也可以是工作目录(WORKDIR)的相对路径，如无路径会自动创建</code></pre></li><li><p>ADD：类似 COPY ，不过在源文件为 tar 压缩文件的话，压缩格式为 gzip, bzip2 , xz 的情况下，会自动复制并解压到目标路径 ；如无自动解压的需求，请优先使用 COPY ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">ADD &lt;src&gt; &lt;dest&gt;src: 宿主机源路径dest: 容器内目标路径# 如源文件是 gzip bzip2 xz 格式的压缩文件，ADD 会自动解压</code></pre><p>用法基本与 ADD相同，但是<code>&lt;src&gt;</code>只能是本地主机的路径</p></li><li><p>VOLUME：定义匿名数据卷，在启动容器时忘记挂载数据卷，会自动挂载到匿名卷，避免重要的数据，因容器重启而丢失 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">VOLUME ["&lt;路径1&gt;", "&lt;路径2&gt;", ...]VOLUME &lt;路径&gt;# 在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点</code></pre></li><li><p>EXPOSE：仅仅只是声明容器内服务所监听的端口 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">EXPOSE &lt;port1&gt; &lt;port2&gt;</code></pre></li><li><p>USER：用于指定后续执行命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">USER &lt;用户名&gt;[:&lt;用户组&gt;]# 当服务不需要管理员权限时，可以通过该命令指定运行用户RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code></pre></li><li><p>ONBUILD：配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令 ，可以有多个 ONBUILD 指令 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">ONBUILD [instruction]# 示例：ONBUILD ADD . /app/src</code></pre></li><li><p>STOPSIGNAL：指定镜像构建的容器接收的退出信号的值 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">STOPSIGNAL signal</code></pre></li><li><p>HEALTHCHECK：用于指定某个程序或者指令来监控 docker 容器服务的运行状态 ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">HEALTHCHECK [Options] CMD command：设置检查容器健康状况的命令，根据所执行命令返回值来判断 ;[Options]: --interval=DURARION (默认：30s)：多久检查一次 --timeout=DURARION (默认：30s)：每次检查等待结果的超时时间 --retries=N (默认：3)：如果失败了，重试几次才最终确定失败# 禁止基础镜像中的健康检查HEALTHCHECK NONE</code></pre></li><li><p>SHELL：指定其他命令使用 shell 时默认的 shell 类型，默认值为：[“/bin/sh”, “-c”] ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">SHELL ["executable", "parameters"]</code></pre></li><li><p>  MAINTAINER：指定维护者信息 ；</p></li><li><p>LABEL：用来生成镜像的元数据标签信息，可以有多个 LABEL ；</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">LABEL &lt;key&gt; &lt;value&gt;LABEL &lt;key&gt;=&lt;value&gt;# 示例：LABEL version="1.0"</code></pre></li></ul></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class="language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM python:3.8-busterMAINTAINER ChenENV LC_ALL C.UTF-8ENV LANG C.UTF-8ENV TZ Asia/ShanghaiWORKDIR  /appCOPY ./the_first/ /app/the_first/RUN pip install gunicorn &amp;&amp; \    pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ -r /app/the_first/requirements.txtCMD cd ./the_first &amp;&amp; \    python3 manage.py collectstatic --noinput &amp;&amp; \    gunicorn --workers 2  --log-level debug --bind '0.0.0.0:8000'  'the_first.wsgi'</code></pre><h1 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker-compose"></a>Docker-compose</h1><h2 id="语法规则-1"><a href="#语法规则-1" class="headerlink" title="语法规则"></a>语法规则</h2><pre class="language-yaml" data-language="yaml"><code class="language-yaml">version: '3'# 创建容器数据卷volumes:  # 数据卷名  static:# 创建网络networks:  # 网络名称  django_network:    # 网络模式    driver: bridge# 创建加密文件secrets:  my_secret:    file: ./my_secret.txtservices:  # 定义一个服务名  the_first_django:    # 指定构建容器的 Dockerfile 所在的路径    build:      # 指定上下文环境，是基于 compose.yml 的相对路径      context: ./      # 指定 Dockerfile的路径，是 基于 context 的相对路径      dockerfile: compose/production/django/Dockerfile      # 指定构建过程中的环境变量，构建后删除      args:        buildno: 1        password: secret    # 指定容器运行的镜像，不使用 build    image: django:latest    # 指定容器名称    container_name: the_first    # 网络模式：bridge｜host｜none    # network_mode: "service:[service name]"    # network_mode: "container:[container name/id]"    network_mode: "bridge"    # 加入指定的网络    networks:      - django_network    # 映射端口(宿主机:容器)    ports:      - "8000:8000"    # 暴露端口，但不映射到宿主机，只被连接的服务访问    expose:      - '8080'      # 设置容器自动重启策略      # no：默认，在任何情况下都不会重启容器。      # always：总是重新启动      # on-failure：在容器非正常退出时（退出状态非0），才会重启容器。      # unless-stopped：总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器    restart: on-failure:3    # 是否拥有宿主机 root 权限    privileged: true    # 添加环境变量    environment:      - RACK_ENV: development      # 布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False      - SHOW: 'true'    # 从文件添加环境变量    env_file:      - ./common.env    # 挂载一个目录或者已经存在的数据卷容器    volumes:      - static:/app/the_first/static/  # 将该容器的静态文件共享到其他的容器中      - /opt/data:/var/lib/mysql  # 使用绝对路径挂载数据卷      # :ro 表示为只读      - ./configs:/etc/configs/:ro  # 使用以 Compose 配置文件为基本路径的相对路径    # 容器启动后执行的命令    # command: /start.sh    # ENTRYPOINT，覆盖 RUN 命令 和 Dockerfile 中的同名指令    # entrypoint: /code/entrypoint.sh    # 容器依赖    depends_on:      - mysql-django  # 另外的服务名      - redis-django    # 指定设备映射列表    devices:      - "/dev/ttyUSB0:/dev/ttyUSB0"    # 自定义 DNS 服务器    dns:      - 8.8.8.8      - 9.9.9.9    # 自定义 DNS 搜索域    dns_search:      - dc1.example.com      - dc2.example.com    # 添加主机名映射，类似 docker client --add-host    # 会在此服务的内部容器的 /etc/hosts 中创建 IP 和主机名的映射关系    extra_hosts:      - "somehost:162.242.195.82"      - "otherhost:50.31.209.229"    # 存储敏感数据，例如密码    secrets:      - my_secret    # 在容器内安装一个临时文件系统    tmpfs:      - /tmp    # 用于检测 docker 服务是否健康运行    healthcheck:      test: [ "CMD", "curl", "-f", "http://localhost" ] # 设置检测程序      interval: 1m30s # 设置检测间隔      timeout: 10s # 设置检测超时时间      retries: 3 # 设置重试次数      start_period: 40s # 启动后，多少秒开始启动检测程序    # 链接到其它服务器中的容器    links:      - db      - db:mysql      - redis    # 让 compose 项目里面的容器链接到项目配置外部的容器（外部容器中必须至少有一个容器链接到项目内服务的同一个网络里）    external_links:      - redis_1      - project_db_1:mysql      - project_db_1:postgresql    # 服务的日志记录配置    logging:      # 指定服务容器的日志记录驱动程序: json-file/syslog/none      driver: json-file      options:        # 当 driver: syslog 时        # syslog-address: "tcp://ip"  # 指定日志接收地址        # 当 driver: json-file 时        max-size: "200k"  # 单个文件大小为 200 k        max-file: "10"  # 最多10个文件  # 被依赖的服务  redis-django:    image: redis  mysql-django:    image: mysql</code></pre><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre class="language-shell" data-language="shell"><code class="language-shell"># -f  指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。docker-compose -f docker-compose.yml up -d# 启动所有容器，-d 将会在后台启动并运行所有的容器docker-compose up -d# 停用移除所有容器以及网络相关docker-compose down# 查看服务容器的输出docker-compose logs# 列出项目中目前的所有容器docker-compose ps# 构建（重新构建）项目中的服务容器。服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。可以随时在项目目录下运行 docker-compose build 来重新构建服务docker-compose build# 拉取服务依赖的镜像docker-compose pull# 重启项目中的服务docker-compose restart# 删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。docker-compose rm# 在指定服务上执行一个命令。docker-compose run ubuntu ping docker.com# 设置指定服务运行的容器个数。通过 service=num 的参数来设置数量docker-compose scale web=3 db=2# 启动已经存在的服务容器。docker-compose start# 停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。docker-compose stop</code></pre><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><pre class="language-yaml" data-language="yaml"><code class="language-yaml">version: '3'volumes:  static:  media:networks:  django_network:    driver: bridgeservices:  # mysql 服务  mysql-django:    image: mysql:latest    container_name: mysql-django    networks:      - django_network    ports:      - 13306:3306    restart: always    privileged: true    environment:      TZ: Asia/Shanghai      MYSQL_ROOT_PASSWORD: mysql13306123456      MYSQL_DATABASE: the_first    volumes:      - /usr/local/workspace/mysql/data/:/var/lib/mysql/    command:      # MySQL8.0 之后，默认的加密规则使用的是 caching_sha2_password      # 客户端工具不支持，所以不要修改其加密规则      --default-authentication-plugin=mysql_native_password      --character-set-server=utf8mb4      --collation-server=utf8mb4_unicode_ci  # redis 服务  redis-django:    image: redis:latest    container_name: redis-django    networks:      - django_network    ports:      - 16379:6379    restart: always    privileged: true    environment:      TZ: Asia/Shanghai    # 容器启动后，启动根据配置文件启动 redis-server    command: redis-server /etc/redis/redis.conf --appendonly yes --requirepass 'redis16379123456'    volumes:      - /usr/local/workspace/redis/data:/data/      - /usr/local/workspace/redis/redis.conf:/etc/redis/redis.conf/  # django 服务  the_first:    image: the_first:latest    container_name: the_first    networks:      - django_network    expose:      - '8000'    restart: always    privileged: true    environment:      TZ: Asia/Shanghai    volumes:      - static:/app/the_first/static/  # 将该容器的静态文件共享到其他的容器中      - media:/app/the_first/media/    depends_on:      - mysql-django      - redis-django  # nginx 服务  nginx-django:    image: nginx:latest    container_name: nginx-django    networks:      - django_network    ports:      - 80:80      - 443:443    restart: always    privileged: true    environment:      TZ: Asia/Shanghai    volumes:      # 与 django 服务共享 static media 目录      - static:/app/the_first/static/      - media:/app/the_first/media/      - /usr/local/workspace/nginx/conf/nginx.conf:/etc/nginx/nginx.conf      - /usr/local/workspace/nginx/conf.d:/etc/nginx/conf.d      - /usr/local/workspace/nginx/html:/usr/share/nginx/html      - /usr/local/workspace/nginx/log:/var/log/nginx    depends_on:      - the_first</code></pre><h1 id="Docker-命令快捷栏"><a href="#Docker-命令快捷栏" class="headerlink" title="Docker 命令快捷栏"></a>Docker 命令快捷栏</h1><blockquote><ul><li><p>设置 docker 开机自动启动(服务器重启后自动重启)</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">$ systemctl enable docker</code></pre></li><li><p>进去容器内部</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">$ docker exec -it 容器id/name /bin/bash</code></pre></li><li><p>启动一个 redis 容器</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">$ docker run -itd -p 16379:6379 --name='redis-django' --network='bridge' --restart='always' \-v /usr/local/workspace/redis/data:/data \-v /usr/local/workspace/redis/redis.conf:/etc/redis/redis.conf \redis redis-server /etc/redis/redis.conf --appendonly yes --requirepass 'redis16379123456'# 参数解释：# 挂载数据卷和配置文件-v /usr/local/workspace/redis/data:/data-v /usr/local/workspace/redis/redis.conf:/etc/redis/redis.conf# 使用配置文件启动/etc/redis/redis.conf--appendonly yes: 开启持久化--requirepass 'redis16379123456': 设置密码</code></pre></li><li><p>启动一个 mysql 容器</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">$ docker run -itd -p 13306:3306 --name='mysql-django' --network='bridge' --restart='always' -e MYSQL_ROOT_PASSWORD=mysql13306123456 \-v /usr/local/workspace/mysql/data:/var/lib/mysql \mysql:latest# 参数解释：# 挂载数据卷和配置文件-v /usr/local/workspace/mysql/data:/var/lib/mysql-v /usr/local/workspace/mysql/etc:/etc/mysql-e: 为容器设置环境变量，为 mysql 初始密码</code></pre></li><li><p>启动一个 rabbitmq 容器</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">$ docker run -itd  -p 5672:5672 --name='rabbitmq-django' --network='bridge' --restart='always' rabbitmq:latest# 端口参数解释：5672、5671: AMQP 0-9-1 without and with TLSclient 端通信口15671: 管理监听端口15672: 管理界面ui使用的端口25672: (Erlang distribution）server 间内部通信口4369: （epmd)epmd代表 Erlang 端口映射守护进程，erlang 发现口</code></pre></li><li><p>启动一个 nginx 容器</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">    $ docker run -itd -p 80:80 --name='nginx-django' --network='bridge' --restart='always' \    -v /usr/local/workspace/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \-v /usr/local/workspace/nginx/conf.d:/etc/nginx/conf.d \    -v /usr/local/workspace/nginx/html:/usr/share/nginx/html \    -v /usr/local/workspace/nginx/log:/var/log/nginx \    nginx        # 参数解释：    # 将宿主机 workspace/nginx/ 下的配置文件、日志、html 文件挂载到 Nginx 容器中    -v /usr/local/workspace/nginx/conf/nginx.conf:/etc/nginx/nginx.conf    -v /usr/local/workspace/nginx/conf.d:/etc/nginx/conf.d    -v /usr/local/workspace/nginx/html:/usr/share/nginx/html    -v /usr/local/workspace/nginx/log:/var/log/nginx</code></pre></li><li><p>启动一个 Django 项目</p>  <pre class="language-shell" data-language="shell"><code class="language-shell">$ docker run -itd -p 8000:8000 --name='django' --network='bridge' --restart='always' django</code></pre></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx跨域配置</title>
      <link href="/posts/16776/"/>
      <url>/posts/16776/</url>
      
        <content type="html"><![CDATA[<p>当出现403跨域错误的时候 <code>No 'Access-Control-Allow-Origin' header is present on the requested resource</code>，需要给Nginx服务器配置响应的header参数</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>只需要在Nginx的配置文件中配置以下参数：</p><pre class="language-nginx" data-language="nginx"><code class="language-nginx">location / {      add_header Access-Control-Allow-Origin *;    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';    add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';     if ($request_method = 'OPTIONS') {        return 204;    }}</code></pre><blockquote><p>上面配置代码即可解决问题了，不想深入研究的，看到这里就可以啦=-=</p></blockquote><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ol><li><strong>Access-Control-Allow-Origin</strong></li></ol><pre class="language-none"><code class="language-none">服务器默认是不被允许跨域的。给Nginx服务器配置`Access-Control-Allow-Origin *`后，表示服务器可以接受所有的请求源（Origin）,即接受所有跨域的请求。</code></pre><ol start="2"><li><strong>Access-Control-Allow-Headers</strong> 是为了防止出现以下错误：</li></ol><pre class="language-none"><code class="language-none">Request header field Content-Type is not allowed by Access-Control-Allow-Headers in preflight response.</code></pre><p>这个错误表示当前请求Content-Type的值不被支持。其实是我们发起了”application/json”的类型请求导致的。这里涉及到一个概念：<code>预检请求（preflight request）</code>,请看下面”预检请求”的介绍。</p><ol start="3"><li><strong>Access-Control-Allow-Methods</strong> 是为了防止出现以下错误：</li></ol><pre class="language-none"><code class="language-none">Content-Type is not allowed by Access-Control-Allow-Headers in preflight response.</code></pre><ol start="4"><li>给<code>OPTIONS</code> 添加 <code>204</code>的返回，是为了处理在发送POST请求时Nginx依然拒绝访问的错误</li></ol><p>发送”预检请求”时，需要用到方法 <code>OPTIONS</code> ,所以服务器需要允许该方法。</p><h2 id="预检请求（preflight-request）"><a href="#预检请求（preflight-request）" class="headerlink" title="预检请求（preflight request）"></a>预检请求（preflight request）</h2><p>其实上面的配置涉及到了一个W3C标准：<code>CROS</code>,全称是跨域资源共享 (Cross-origin resource sharing)，它的提出就是为了解决跨域请求的。</p><blockquote><p>跨域资源共享(CORS)标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求， <code>对那些可能对服务器数据产生副作用的HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求）</code>，浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。</p></blockquote><p>其实<code>Content-Type字段的类型为application/json</code>的请求就是上面所说的<code>搭配某些 MIME 类型的 POST 请求</code>,CORS规定，Content-Type不属于以下MIME类型的，都属于预检请求：</p><pre class="language-none"><code class="language-none">application/x-www-form-urlencodedmultipart/form-datatext/plain</code></pre><p>所以 application/json的请求 会在正式通信之前，增加一次”预检”请求，这次”预检”请求会带上头部信息 <code>Access-Control-Request-Headers: Content-Type</code>：</p><pre class="language-none"><code class="language-none">OPTIONS /api/test HTTP/1.1Origin: http://foo.exampleAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: Content-Type... 省略了一些</code></pre><p>服务器回应时，返回的头部信息如果不包含<code>Access-Control-Allow-Headers: Content-Type</code>则表示不接受非默认的的Content-Type。即出现以下错误：</p><pre class="language-none"><code class="language-none">Request header field Content-Type is not allowed by Access-Control-Allow-Headers in preflight response.</code></pre>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastAPI学习之路-4  依赖注入</title>
      <link href="/posts/34371/"/>
      <url>/posts/34371/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>依赖注入系统，可以说是fastapi框架中很重要也是一个核心的系统。因为fastapi主要用的都是函数式编程实现API的方式，不像Django里面，有FBV和CBV。为了实现和Django一样的视图编程方式，于是就引入了这个依赖注入的概念。</p><p>依赖注入的优势：</p><ul><li>提高代码的复用率，一些公共的资源，比如，函数，提取出来复用，一些pydantic验证也是如此。</li><li>共享数据库连接，避免操作数据库CURD时创造多条连接。</li><li>增强安全、认证和角色管理，就比如，超级管理员拥有什么权限。管理员拥有超级管理员之中的某些权限，而用户又只拥有管理员之下的某些权限。</li></ul><p>从这个fastapi框架的角度来看，他的兼容性也是非常的强大的。通过依赖注入系统，可以支持SQL数据库，和NoSQL数据库。</p></blockquote><h2 id="声明依赖项"><a href="#声明依赖项" class="headerlink" title="声明依赖项"></a>声明依赖项</h2><blockquote><p>我们不以复杂的理论和代码来论证这个依赖注入，我们声明一个函数，用来当作依赖项来进行讲解。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100):    return {"q": q, "skip": skip, "limit": limit}</code></pre><p>这里，我们声明了一个函数，有三个参数，<code>q</code>、<code>skip</code>、<code>limit</code>，我没有对他进行任何处理，只是原封不动的返回了，如果在真实的开发场景中，我们如果把所有的业务处理全部放在一个函数中，那就成了祖传代码，除了你自己，几乎别人没人看得懂。(PS：你自己也不一定看得懂了~~(●’◡’●))</p><p>好了，回到我们这个场景，假如，我们要多次传入这三个参数，我们按照正常来说，也可以这么写：</p><pre class="language-python" data-language="python"><code class="language-python">async def test1(q: Optional[str] = None, skip: int = 0, limit: int = 100)                async def test2(q: Optional[str] = None, skip: int = 0, limit: int = 100)</code></pre><p>然后，你会发现你的代码重复了，如果要进行相同的校验或者业务逻辑处理，需要更加繁琐的代码，也是需要一一重复。</p><p>这时候，我们把这个当作依赖，直接注入到函数中，就会减少重复。</p><pre class="language-python" data-language="python"><code class="language-python">@app.get('/')async def test(common_parameters:dict = Depends(common_parameters)):    return common_parameters</code></pre><p>这样，我们同样传入这三个参数，但是，在这个函数中，相应的减少了一些业务代码的处理。</p><h2 id="类作为依赖项"><a href="#类作为依赖项" class="headerlink" title="类作为依赖项"></a>类作为依赖项</h2><blockquote><p>fastapi不只是可以将函数作为依赖项，一切可以被称为资源的，都可以作为依赖项。比如，类。用法，几乎是一致的。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">class common_parameters:    def __init__(self,q:Optional[str] = None,skip: int = 0, limit: int = 100):        self.q = q        self.skip = skip        self.limit = limit@app.get('/')async def test(common_parameters:dict = Depends(common_parameters)):    return common_parameters</code></pre><h2 id="子依赖"><a href="#子依赖" class="headerlink" title="子依赖"></a>子依赖</h2><blockquote><p>可以理解为类的继承， 声明了一个依赖项，经过一些处理后，再被另一个依赖给处理，有点像二次加工</p></blockquote><pre class="language-python" data-language="python"><code class="language-python"># 声明一个子依赖项def query_extractor(q: Optional[str] = None):    return q# 声明第二个依赖项，将子依赖作为依赖注入def query_or_cookie_extractor(    q: str = Depends(query_extractor), last_query: Optional[str] = Cookie(None)):    if not q:        return last_query    return q# 最后传到的@app.get("/items/")async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)):    return {"q_or_cookie": query_or_default}</code></pre><h2 id="路径中操作依赖项"><a href="#路径中操作依赖项" class="headerlink" title="路径中操作依赖项"></a>路径中操作依赖项</h2><blockquote><p>在路径中，无论是fastapi项目的实例还是APIrouter的实例，所导的路径装饰器中，都可以进行依赖的注入。在路由中，使用<code>dependencies</code>来进行依赖的注入。他可以是一个<code>Depends</code>，也可以是一个列表，来进行多个依赖项的注入</p></blockquote><pre class="language-python" data-language="python"><code class="language-python"># 声明两个依赖async def verify_token(x_token: str = Header(...)):    if x_token != "fake-super-secret-token":        raise HTTPException(status_code=400, detail="X-Token header invalid")async def verify_key(x_key: str = Header(...)):    if x_key != "fake-super-secret-key":        raise HTTPException(status_code=400, detail="X-Key header invalid")    return x_key# 在路由装饰器中，列表形式注入多个依赖项@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])async def read_items():    return [{"item": "Foo"}, {"item": "Bar"}]</code></pre><h2 id="全局依赖"><a href="#全局依赖" class="headerlink" title="全局依赖"></a>全局依赖</h2><blockquote><p>在全局中，无论是<code>APIRouter</code>还是<code>FastAPI</code>,他们所实例的变量都可以通过<code>dependencies</code>来进行依赖的注入，这样，所有使用了他们的路由装饰器，都会进行其依赖的操作。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python"># 在FastAPI中使用依赖注入app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])# 在APIRouter中使用apirouter = APIRouter(dependencies=[Depends(verify_token), Depends(verify_key)])</code></pre><h2 id="关于fastapi"><a href="#关于fastapi" class="headerlink" title="关于fastapi"></a>关于fastapi</h2><blockquote><p>对于fastapi，我个人把他分成了几个部分，如果有感觉模糊不清的道友，可以参照这个思路，fastapi就非常的好理解了。</p><ol><li>验证部分<br>这里分为了几个验证部分，分别为：<code>Body、Header、Path、Query、Cookie</code>，其中，Body包括了pydantic，这里需要注意的一点就是，pydantic和fastapi不是一体的。不要搞混了。</li><li>请求部分<br>关于对请求的处理，这里也包括了对Path的验证</li><li>依赖注入系统<br>这个就不用多说了，😄</li><li>响应处理<br>包括json、表单、文件等请求或者响应，这个不应该单独分出来，应该是和请求部分一致学习的</li><li>认证授权数据库等</li></ol><p>只要是好好的给他分割开来，逐一击破，对于新的框架学习来说，学习成本实际上并没有这么的高。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch详解</title>
      <link href="/posts/43505/"/>
      <url>/posts/43505/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Elasticsearch是一个基于<a href="https://baike.baidu.com/item/Lucene/6753302">Lucene</a>的搜索服务器。它提供了一个分布式多用户能力的<a href="https://baike.baidu.com/item/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/7847410">全文搜索引擎</a>，基于RESTful web接口。是一种流行的企业级搜索引擎。Elasticsearch用于<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353">云计算</a>中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><blockquote><p>之前出过一篇攻略，关于安装，我们就不再重复了，可以查看这篇攻略以及索引。<a href="https://www.godhearing.cn/posts/46689/">Docker安装ES</a></p><p>之前可能说的不是很详细，所以，我们还是需要再把这个原理和应用再细细划分一下。</p></blockquote><p>我们在接触这个ES之前，一定是接触过数据库的，我们以管理型数据库mysql为例，对照一下，mysql和es之间的区别。</p><table><thead><tr><th>关系型数据库(Eg. MySQL)</th><th>非关系型数据库（Eg. ElasticSearch）</th></tr></thead><tbody><tr><td>数据库Database</td><td>索引Index</td></tr><tr><td>表Table</td><td>类型Type</td></tr><tr><td>数据行Row</td><td>文档Dpcument</td></tr><tr><td>数据列Column</td><td>字段Field</td></tr></tbody></table><h3 id="Node-节点-与Cluster-集群"><a href="#Node-节点-与Cluster-集群" class="headerlink" title="Node(节点)与Cluster(集群)"></a>Node(节点)与Cluster(集群)</h3><p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p><h3 id="Index-索引"><a href="#Index-索引" class="headerlink" title="Index(索引)"></a>Index(索引)</h3><p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p><p>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p><p>下面的命令可以查看当前节点的所有 Index。</p><pre class="language-none"><code class="language-none">$ curl -X GET 'http://localhost:9200/_cat/indices?v'</code></pre><h3 id="Document-文档"><a href="#Document-文档" class="headerlink" title="Document(文档)"></a>Document(文档)</h3><p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。<br>Document 使用 JSON 格式表示，例如这样：</p><pre class="language-json" data-language="json"><code class="language-json">{  "user": "天听",  "title": "攻城狮",  "desc": "CV大法传承人"}</code></pre><blockquote><p>同一个 Index 里面的 Document，不要求有相同的结构，但是最好保持相同，这样有利于提高搜索效率。</p></blockquote><h3 id="Type-类型"><a href="#Type-类型" class="headerlink" title="Type(类型)"></a>Type(类型)</h3><p>Document 可以分组，比如有一个weather的Index，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p><blockquote><p>不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p></blockquote><p>类比一下MySQL，索引就好比是数据库，type就是数据表，文档，就是表中的数据。</p><p>下面的命令可以列出每个 Index 所包含的 Type。</p><pre class="language-none"><code class="language-none">$ curl 'localhost:9200/_mapping?pretty=true'</code></pre><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><p>至于为什么要出这篇文章呢….emmmm….是时间太久，太久没用过这个东西，我自己也已忘的一干二净了，所以借此机会，再写一些关于ES的搜索知识用来巩固，自己的技术还得是总结下来才是自己的，否则时间一久，就跟没有似的。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python发送阿里云短信</title>
      <link href="/posts/61310/"/>
      <url>/posts/61310/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在当今这个网络如此发达的时代，手机已经成为了必不可少的随身物品，而，普通的单因子登录已经不是百分百安全的了，很容易被暴力破解，所以，双因子、三因子这些认证方式，已经从“你有什么”，变成了“你是谁”，从而让账户变得更加的安全，所以，短信验证码已经成为了必不可少的东西，今天，带来阿里云+python来发送短信。</p></blockquote><h2 id="1-注册阿里云"><a href="#1-注册阿里云" class="headerlink" title="1.注册阿里云"></a>1.注册阿里云</h2><blockquote><p>注册步骤很简单，地址：<a href="https://homenew.console.aliyun.com/">在这里</a>，需要注意的是，发送短信只有实名认证的用户才能够使用，<a href="https://help.aliyun.com/knowledge_detail/37171.html?spm=a2c4g.11186623.2.20.2c273ea59ImPQC">参考这里</a></p></blockquote><h2 id="2-创建AccessKey和Access-Key-Secret"><a href="#2-创建AccessKey和Access-Key-Secret" class="headerlink" title="2.创建AccessKey和Access Key Secret"></a>2.创建AccessKey和Access Key Secret</h2><img src="/posts/61310/image-20210226112308451.png" alt style="zoom:67%;" loading="lazy"><h2 id="3-获取签名名称和模板code"><a href="#3-获取签名名称和模板code" class="headerlink" title="3.获取签名名称和模板code"></a>3.获取签名名称和模板code</h2><img src="/posts/61310/image-20210226112434500.png" alt style="zoom:50%;" loading="lazy"><h2 id="4-安装依赖"><a href="#4-安装依赖" class="headerlink" title="4.安装依赖"></a>4.安装依赖</h2><p>1.安装pythonsdk</p><pre class="language-python" data-language="python"><code class="language-python"># 安装阿里云的相关依赖# python2执行此命令pip install aliyun-python-sdk-core# python3执行此命令pip install aliyun-python-sdk-core-v3</code></pre><p>2.安装SDK</p><p>下载地址在<a href="http://ytx-sdk.oss-cn-shanghai.aliyuncs.com/dysms_python.zip?spm=a2c4g.11186623.2.9.10476220dsQLEd&amp;file=dysms_python.zip">这里</a>，解压之后，进入根目录执行命令： python setup.py install #如果为python3，请执行：python3 setup.py install</p><p>3.安装api依赖</p><p><code> pip install aliyun-python-sdk-kms</code></p><p><code>pip install aliyun-python-sdk-dysmsapi</code></p><h2 id="5-写一个工具函数"><a href="#5-写一个工具函数" class="headerlink" title="5.写一个工具函数"></a>5.写一个工具函数</h2><pre class="language-python" data-language="python"><code class="language-python">from aliyunsdkcore.client import AcsClientfrom aliyunsdkcore.request import CommonRequest# 用户AccessKeyACCESS_KEY_ID = ""# Access Key SecretACCESS_KEY_SECRET = ""class SMS:    def __init__(self,signName,templateCode):        self.signName = signName        self.templateCode = templateCode        self.client = client = AcsClient(ACCESS_KEY_ID,ACCESS_KEY_SECRET,'cn-hangzhou')    def send(self, phone_numbers, template_param):        request = CommonRequest()        request.set_accept_format('json')        request.set_domain('dysmsapi.aliyuncs.com')        request.set_method('POST')        request.set_protocol_type('https')  # https | http        request.set_version('2017-05-25')        request.set_action_name('SendSms')        request.add_query_param('RegionId', "cn-hangzhou")        request.add_query_param('PhoneNumbers', phone_numbers)        request.add_query_param('SignName', self.signName)        request.add_query_param('TemplateCode', self.templateCode)        request.add_query_param('TemplateParam', template_param)        response = self.client.do_action_with_exception(request)        return response</code></pre><h2 id="6-调用此函数"><a href="#6-调用此函数" class="headerlink" title="6.调用此函数"></a>6.调用此函数</h2><pre class="language-python" data-language="python"><code class="language-python">from random import randintclass Aliyun_Sms(APIView):    def get(self,request):        # 生成验证码        params = "{'code':%d}"%(randint(1000,100000))        para = request.GET.get('phone_numbers')        sms = SMS("模板名称","模版CODE")res = sms.send(phone,params)        return HttpResponse(res)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装mysqlclient</title>
      <link href="/posts/38218/"/>
      <url>/posts/38218/</url>
      
        <content type="html"><![CDATA[<p>在 <code>Linux</code> 下安装 <code>mysqlclient</code>，如果是选择直接安装的话，一般会报如下错误</p><pre class="language-python" data-language="python"><code class="language-python">(djenv) handsome@fzq:~$ pip install mysqlclient -i https://pypi.doubanio.com/simple/Looking in indexes: https://pypi.doubanio.com/simple/Collecting mysqlclient  Downloading https://pypi.doubanio.com/packages/ec/fd/83329b9d3e14f7344d1cb31f128e6dbba70c5975c9e57896815dbb1988ad/mysqlclient-1.3.13.tar.gz (90kB)    100% |████████████████████████████████| 92kB 2.1MB/s     Complete output from command python setup.py egg_info:    /bin/sh: 1: mysql_config: not found    Traceback (most recent call last):      File "&lt;string&gt;", line 1, in &lt;module&gt;      File "/tmp/pip-install-y16_5477/mysqlclient/setup.py", line 18, in &lt;module&gt;        metadata, options = get_config()      File "/tmp/pip-install-y16_5477/mysqlclient/setup_posix.py", line 53, in get_config        libs = mysql_config("libs_r")      File "/tmp/pip-install-y16_5477/mysqlclient/setup_posix.py", line 28, in mysql_config        raise EnvironmentError("%s not found" % (mysql_config.path,))    OSError: mysql_config not found        ----------------------------------------Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-install-y16_5477/mysqlclient/</code></pre><p>解答方案， 一般来说安装一个依赖即可</p><pre class="language-python" data-language="python"><code class="language-python">(djenv) handsome@fzq:~$ sudo apt install libmysqlclient-dev</code></pre><p>安装完依赖之后，再次执行<code>pip install mysqlclient -i https://pypi.doubanio.com/simple/</code> 即可成功安装</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫描普通链接进入微信小程序</title>
      <link href="/posts/50236/"/>
      <url>/posts/50236/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>为了更加方便的将小程序推广，微信现在推出了扫描普通二维码进入某个微信小程序的指定页面，而小程序是没有链接性的地址的，所以，我们还是要先阅读一下<a href="https://developers.weixin.qq.com/miniprogram/introduction/qrcode.html#%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D">文档</a></p></blockquote><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h4 id="step-1：开启扫描二维码打开小程序"><a href="#step-1：开启扫描二维码打开小程序" class="headerlink" title="step 1：开启扫描二维码打开小程序"></a>step 1：开启扫描二维码打开小程序</h4><p>登录小程序后台，进入“开发-开发设置-扫普通链接二维码打开小程序”，开启功能后即可配置二维码规则。</p><h4 id="step2：配置二维码"><a href="#step2：配置二维码" class="headerlink" title="step2：配置二维码"></a>step2：配置二维码</h4><p>二维码规则：</p><blockquote><ul><li>二维码规则的域名须通过ICP备案的验证。</li><li>支持http、https、ftp开头的链接（如：<a href="https://links.jianshu.com/go?to=http://wx.qq.com">http://wx.qq.com</a>、<a href="https://links.jianshu.com/go?to=https://wx.qq.com/mp/">https://wx.qq.com/mp/</a>、<a href="https://links.jianshu.com/go?to=https://wx.qq.com/mp?id=123">https://wx.qq.com/mp?id=123</a>）</li><li>一个小程序帐号可配置不多于10个二维码前缀规则。</li></ul></blockquote><p>校验文件：</p><p>下载随机校验文件，并将文件上传至服务器指定位置的目录下，方可通过所属权校验。</p><p>这里要确定的是，能够访问到这个文件，我这里直接使用的nginx，在nginx下添加配置</p><pre class="language-none"><code class="language-none">location /tra/校验文件名.txt {            alias  /校验文件名.txt;        }</code></pre><p>使用微信扫码，只要是你配置的前缀名，他就会去服务器找这个校验文件，如果校验成功，就会去小程序你指定的页面。</p><p>小程序功能页面：</p><blockquote><p>小程序功能页面可打开指定页面，扫描二维码可打开对应页面。</p></blockquote><img src="/posts/50236/image-20210220133743592.png" alt style="zoom:67%;" loading="lazy"><h4 id="step3：扫描二维码打开小程序"><a href="#step3：扫描二维码打开小程序" class="headerlink" title="step3：扫描二维码打开小程序"></a>step3：扫描二维码打开小程序</h4><p>配置二维码时可配置测试链接，利用第三方二维码生成工具，使用测试链接生成二维码，利用微信“扫一扫”或微信内长按识别二维码跳转小程序。</p><p>链接?后为参数部分，可在onLoad事件中提取<code>q</code>参数并自行<code>decodeURIComponent</code>一次，即可获取原二维码的完整内容。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">onLoad: function (options) {    if (options.q) {      let queryAll = decodeURIComponent(options.q);      let id = gup('id', queryAll);      //console.log(queryAll);      //console.log(id);    }  },/** * 获取URL中某个字符串字段 * gup('id', 'https://www.lubanso.com/wx/home/?id=bHViYW5zb7W7DJI=&amp;jhkfdhkjfda') * //===&gt; bHViYW5zb7W7DJI= */function gup(name, url) {  if (!url) url = location.href;  name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");  var regexS = "[\\?&amp;]" + name + "=([^&amp;#]*)";  var regex = new RegExp(regexS);  var results = regex.exec(url);  return results == null ? null : results[1];}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中使用setTimeout遇到的问题</title>
      <link href="/posts/32599/"/>
      <url>/posts/32599/</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的问题1"><a href="#遇到的问题1" class="headerlink" title="遇到的问题1"></a>遇到的问题1</h2><p>我在执行setTiemout之后，效果并没有触发，然后发现语法错误</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">// 错误写法for (var i = 0; i &lt; 6; i++) {    setTimeout(            console.log(`这是第 ${i} 次`);        ,1000);}// 正确写法for (var i = 0; i &lt; 6; i++) {    (function (t, data) {   // 注意这里是形参        setTimeout(function () {            console.log(`这是第 ${t} 次，这是其他参数：${data}`);        }, 1000 * t);// 还是每秒执行一次，不是累加的    })(i, '其他参数')   // 注意这里是实参，这里把要用的参数传进去}</code></pre><p>这是个小插曲，之后，我遇到了<code>Uncaught TypeError: this.XXXXX is not a function</code></p><p>原因是，没在一个域内，所以，直接使用this会报错</p><h2 id="解决办法1"><a href="#解决办法1" class="headerlink" title="解决办法1"></a>解决办法1</h2><p>在函数内新生成一个<code>that</code>变量，然后用that代替this</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">var that = thisa(){that.B}</code></pre><h2 id="遇到的问题2"><a href="#遇到的问题2" class="headerlink" title="遇到的问题2"></a>遇到的问题2</h2><p>我直接调用了this变量，可能变量会<code>undefined</code></p><h2 id="解决办法2"><a href="#解决办法2" class="headerlink" title="解决办法2"></a>解决办法2</h2><p>不要要this，直接<code>let</code> 一个新变量，使得在作用域是同一片</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3获取微信小程序码</title>
      <link href="/posts/30799/"/>
      <url>/posts/30799/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>微信小程序是现在开发者经常接触到的了，对微信小程序的一些功能也在逐渐的了解当中，这篇文章记录一下获取微信小程序码遇到的问题</p></blockquote><h2 id="获取access-token"><a href="#获取access-token" class="headerlink" title="获取access_token"></a>获取access_token</h2><blockquote><p>话不多说，直接上代码</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">url = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential"res = requests.get(    url=url,    params={        'appid': 你的APPID,        'secret': 你的SECRET,    }).json().get('access_token')</code></pre><h2 id="获取小程序码"><a href="#获取小程序码" class="headerlink" title="获取小程序码"></a>获取小程序码</h2><p>首先就是要注意，它发送的是json，而不是data数据，所以我们在使用<code>requests</code>的时候，一定要先注意，发送json</p><pre class="language-python" data-language="python"><code class="language-python"># 获取小程序码url2 = "https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=TOKEN"req = {    'scene': scene,    'page': page,    'width': width,}res = requests.post(url=url2, json=req).contentbuf = io.BytesIO()buf.write(res)response = HttpResponse(content=buf.getvalue(), content_type='image/png')response['sss'] = 'sss'return response</code></pre><p>此时要注意，我们在url里传<code>access_token</code>，而不是在json里。他的文档写的并不是很清楚，如果在json中加上<code>access_token</code>，那么就有可能会报错<code>47001</code>。</p><p>还有，如果没注意到，用了data传参，也有可能会报错<code>47129</code>，改成json即可。</p><p>如果成功，返回的是一个二进制文件，需要怎么处理就看自己的了。我这里是以文件流形式返回回去并且添加一个响应头参数。</p><p>还有最重要的一点，<code>41030</code>状态码，并不是说你错了，而是你的小程序还没有上线，这个page路径找不到。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器搭建hexo博客教程</title>
      <link href="/posts/8e750bfd/"/>
      <url>/posts/8e750bfd/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>作为一名合格的程序员，搭建个人博客对于程序员来讲必不可少。为什么？一是因为互联网的知识需要我们不断学习，如果我们我们经常能够进行总结记录，时不时回头复习一下，效果会好很多；</p><p>二是因为作为程序员经常会遇到各种各样的 bug，如果我们将犯的错误记录下来，下次再次遇到同样的问题时，就不用再反复再网上寻找答案了，能为我们节省出很多时间。</p><p>因此，搭建个人博客有以下几点好处：</p><ul><li>提升知识掌握的深度，印象深刻；</li><li>锻炼自己能够把问题“讲清楚”的能力；</li><li>培养开源意识，与他人分享知识。</li></ul></blockquote><p>这里呢，Hexo怎么搭建，我就不说了，相信大家都有搭建hexo的能力。</p><h2 id="服务端准备工作"><a href="#服务端准备工作" class="headerlink" title="服务端准备工作"></a>服务端准备工作</h2><h3 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h3><p>登陆 <code>https://wanwang.aliyun.com/</code> 挑选一个自己喜欢的域名，具体操作如下：</p><p>1、进入网站主页后，点击“域名注册”:</p><img src="/posts/8e750bfd/image-20210209120656914.png" alt style="zoom:50%;" loading="lazy"><p>2、然后在万网进行域名搜索和购买。</p><p>3、初始化自己的服务器</p><p>4、备案，在阿里云的控制台界面，具体备案步骤呢，也就不多说了，往后有机会出一篇备案的攻略。<br><img src="/posts/8e750bfd/image-20210209120903699.png" alt style="zoom:67%;" loading="lazy"></p><p>5、阿里云的服务器默认不开放端口号，这样使得我们在网站部署完成之后仍然无法访问。因此我们需要新建安全组并添加 80 端口，再将安全组添加到 ECS 实例中。具体操作如下。在控制台的 ECS 实例中点击安全组，然后新建安全组。</p><img src="/posts/8e750bfd/image-20210209122807387.png" alt style="zoom:67%;" loading="lazy"><p>在访问规则为 <strong>入方向</strong> 的标签下添加 80 端口。</p><p>最后回到 ECS 服务器实例，将刚刚配置的安全组加入到实例中。</p><img src="/posts/8e750bfd/image-20210209122901251.png" alt style="zoom:67%;" loading="lazy"><h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><p>我们使用 nginx 作为 web 服务器，这里可以将 nginx 理解为安装在服务器上的一个软件。</p><p>还有可以直接使用yum等来安装，不是非得必要用我这个办法。</p><p>安装 nginx 依赖环境，安装期间有提示一律选 yes。推荐直接复制每行命令，避免出错。</p><pre class="language-text" data-language="text"><code class="language-text">yum install gcc-c++yum install -y pcre pcre-develyum install -y zlib zlib-develyum install -y openssl openssl-devel</code></pre><p>下载 nginx 安装包。</p><pre class="language-text" data-language="text"><code class="language-text">wget -c https://nginx.org/download/nginx-1.10.1.tar.gz</code></pre><p>将安装包解压到 <code>/usr/local</code> 目录下。</p><pre class="language-text" data-language="text"><code class="language-text">tar -xvf nginx-1.10.1.tar.gz -C /usr/local</code></pre><p>进入 <code>/usr/local</code> 目录，确认 nginx 解压到该目录下。</p><pre class="language-text" data-language="text"><code class="language-text">cd /usr/local</code></pre><p>进入 <code>nginx-1.10.1</code> 目录，会发现该目录下有一个 <code>configure</code> 文件，执行该配置文件。</p><pre class="language-text" data-language="text"><code class="language-text">cd nginx-1.10.1/ls./configure</code></pre><p>编译并安装 nginx</p><pre class="language-text" data-language="text"><code class="language-text">makemake install</code></pre><p>查找nginx安装目录</p><pre class="language-text" data-language="text"><code class="language-text">whereis nginx</code></pre><p>进入安装目录</p><pre class="language-text" data-language="text"><code class="language-text">cd /usr/local/nginxls</code></pre><p>由于 nginx 默认通过 80 端口访问，而 Linux 默认情况下不会开发该端口号，因此需要开放 linux 的 80 端口供外部访问。</p><pre class="language-text" data-language="text"><code class="language-text">/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT</code></pre><p>进入 <code>/usr/local/nginx/sbin</code> 目录，启动 nginx。</p><pre class="language-text" data-language="text"><code class="language-text">cd sbin./nginx</code></pre><p>没有任何消息，代表启动成功。此时输入公网 IP 即可进入 nginx 的欢迎页面了。</p><p>进入 <code>/usr/local/nginx/conf</code> 目录，并对 <code>nginx.conf</code> 配置文件进行相关配置。</p><pre class="language-text" data-language="text"><code class="language-text">cd /usr/local/nginx/conflsvim nginx.conf</code></pre><p>打开后按 <code>i</code> 键由命令模式切换到编辑模式，修改三处地方：</p><p>首先将最顶端的用户改为 root；</p><img src="/posts/8e750bfd/image-20210210110112486.png" alt style="zoom:67%;" loading="lazy"><p>其次将 <code>server_name</code> 改为自己的域名，如果没有备案，可以先填写自己的公网 IP（在控制台 ECS 实例中查看），访问时暂时用公网 IP 进行访问。最后将 <code>root</code> 项中的值改为你自己博客的根目录</p><img src="/posts/8e750bfd/image-20210210110148969.png" alt style="zoom:67%;" loading="lazy"><p>修改结束之后，先按 <code>Esc</code> 由编辑模式切换到命令模式，再输入 <code>:wq</code> 命令保存并退出编辑器。</p><h2 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h2><h3 id="为-hexo-创建一个部署目录-home-hexo"><a href="#为-hexo-创建一个部署目录-home-hexo" class="headerlink" title="为 hexo 创建一个部署目录 /home/hexo"></a>为 hexo 创建一个部署目录 <code>/home/hexo</code></h3><pre class="language-text" data-language="text"><code class="language-text">mkdir -p /home/hexo</code></pre><p>进入 <code>/usr/local/nginx/conf</code> 目录，并对 <code>nginx.conf</code> 配置文件进行相关配置。</p><pre class="language-text" data-language="text"><code class="language-text">cd /usr/local/nginx/conflsvim nginx.conf</code></pre><p>打开后按 <code>i</code> 键由命令模式切换到编辑模式，修改三处地方：</p><p>首先将最顶端的用户改为 root；</p><p>其次将 <code>server_name</code> 改为自己的域名，如果没有备案，可以先填写自己的公网 IP（在控制台 ECS 实例中查看），访问时暂时用公网 IP 进行访问。</p><p>最后将 <code>root</code> 项中的值改为 <code>/home/hexo;</code>，如果 <code>server</code> 中的端口号不是 <code>80</code>，则改为 <code>80</code>。</p><p>修改结束之后，先按 <code>Esc</code> 由编辑模式切换到命令模式，再输入 <code>:wq</code> 命令保存并退出编辑器。</p><h3 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h3><p>返回用户根目录，进行安装 node.js。</p><pre class="language-text" data-language="text"><code class="language-text">cd ~curl -sL https://rpm.nodesource.com/setup_10.x | bash -yum install -y nodejs</code></pre><p>通过查看版本号验证是否安装成功。</p><pre class="language-text" data-language="text"><code class="language-text">node -vnpm -v</code></pre><h3 id="创建-Git-用户"><a href="#创建-Git-用户" class="headerlink" title="创建 Git 用户"></a>创建 Git 用户</h3><p>为了使我们能够在本地向服务器实现自动部署，需要在服务器端另外新建一个 Git 用户，然后使用公钥连接成功之后，就可以方便地随时进行自动部署了。</p><p>复制粘贴以下命令安装 Git，有提示选择 yes 即可。</p><pre class="language-text" data-language="text"><code class="language-text">yum install git</code></pre><p>安装结束之后，查看版本号判断是否安装成功。</p><pre class="language-text" data-language="text"><code class="language-text">git --version</code></pre><p>创建 Git 用户</p><pre class="language-text" data-language="text"><code class="language-text">adduser git</code></pre><p>修改 Git 用户权限为 740</p><pre class="language-text" data-language="text"><code class="language-text">chmod 740 /etc/sudoers</code></pre><p>在配置文件中增加 Git 用户。首先打开文件：</p><pre class="language-text" data-language="text"><code class="language-text">vim /etc/sudoers</code></pre><blockquote><p>找到<code>root   ALL=(ALL)   ALL</code>，在他下面，添加上<code>git   ALL=(ALL)   ALL</code></p></blockquote><p>将 Git 用户的权限改回去。</p><pre class="language-text" data-language="text"><code class="language-text">chmod 400 /etc/sudoers</code></pre><p>设置 Git 用户密码</p><pre class="language-text" data-language="text"><code class="language-text">sudo passwd git</code></pre><p>以上我们就完成了 Git 用户的创建，接下来我们向 Git 用户添加公钥，就像配置 Github 那样。</p><h2 id="向-Git-用户配置-ssh-公钥"><a href="#向-Git-用户配置-ssh-公钥" class="headerlink" title="向 Git 用户配置 ssh 公钥"></a>向 Git 用户配置 ssh 公钥</h2><p>在服务器端 <strong>切换到 git 用户</strong>，在根目录下创建 <code>.ssh</code>文件夹。</p><pre class="language-text" data-language="text"><code class="language-text">su gitcd ~mkdir .ssh</code></pre><p>这时，命令行信息中的 <code>#</code> 变成了 <code>$</code>，且 <code>root</code> 变成了 <code>git</code>，表示我们切换成功。</p><p>注意哦，然后在<strong>本地</strong>计算机桌面右键打开 <code>GitBash Here</code>，在本地生成公钥/私钥对。</p><pre class="language-text" data-language="text"><code class="language-text">cd ~cd .sshssh-keygen</code></pre><p>如果有询问直接回车即可。结束之后，会在 <code>C:\Users\你的本地用户名\.ssh</code> 里生成两个文件：<code>id_rsa</code> 和 <code>id_rsa.pub</code>。<code>.ssh</code> 为隐藏文件夹，你可能需要显示隐藏文件夹之后才可以看到。</p><p>在 <strong>本地</strong> 终端输入以下命令，为私钥设置权限。<br>PS：终端用不了的话，用git bash</p><pre class="language-text" data-language="text"><code class="language-text">chmod 700 ~/.sshchmod 600 ~/.ssh/id_rsa</code></pre><p>将这两个文件，复制进服务器里，然后将id_rsa.pub复制一份到<code>/home/git/.ssh</code></p><pre class="language-text" data-language="text"><code class="language-text">cp id_rsa.pub authorized_keys</code></pre><p>修改文件权限<br>PS：应该git用户无法修改，输入<code>su</code>返回超级用户</p><pre class="language-text" data-language="text"><code class="language-text">chmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh</code></pre><p> 确保设置了正确的SELinux上下文。</p><pre class="language-text" data-language="text"><code class="language-text">restorecon -Rv ~/.ssh</code></pre><p>现在我们来测试一下是否设置成功。在本地任意位置右键打开 <code>GitBash Here</code>，输入公网 IP：</p><pre class="language-text" data-language="text"><code class="language-text">ssh -v git@xxx.xxx.xxx.xxx（你的公网 IP）</code></pre><p>如果最后提示Welcome to Alibaba Cloud Elastic Compute Service !，我们就是成功了</p><p>在服务端配置 Git 仓库</p><pre class="language-text" data-language="text"><code class="language-text">cd ~git init --bare hexo.gitvi ~/hexo.git/hooks/post-receive</code></pre><p>进入后按 <code>i</code> 键由命令模式切换到编辑模式。输入以下命令后保存：</p><pre class="language-text" data-language="text"><code class="language-text">git --work-tree=/home/hexo --git-dir=/home/git/hexo.git checkout -f</code></pre><p>授予钩子文件可执行权限。</p><pre class="language-text" data-language="text"><code class="language-text">chmod +x ~/hexo.git/hooks/post-receivecd ~sudo chmod -R 777 /home/hexo</code></pre><p>重启 ECS 实例。<code>reboot</code></p><p>至此，我们就完成了服务端的配置</p><h2 id="本地Hexo配置"><a href="#本地Hexo配置" class="headerlink" title="本地Hexo配置"></a>本地Hexo配置</h2><p>安装两个插件</p><p>修改 <code>_config.yml</code> 文件</p><p>把 <code>deploy</code> 参数改成如下方式，注意填写自己的公网 IP 哦。</p><img src="/posts/8e750bfd/image-20210209133357909.png" alt style="zoom:67%;" loading="lazy"><p>除此之外，URL 项改为自己的域名，没有备案的化可以先填写公网 IP。</p><p>然后我们就可以进行发布啦</p><pre class="language-text" data-language="text"><code class="language-text">hexo cleanhexo generatehexo deploy或hexo clhexo ghexo d或hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><blockquote><p>发布三件套命令，哪个都行</p></blockquote><p>这时，在浏览器中输入自己的公网 IP，你就可以看到自己的博客了。</p><p>还有一件事，就是域名是需要解析的，具体步骤请参考这篇<a href="http://www.godhearing.cn/2021/02/09/a-li-yun-yu-ming-jie-xi/">攻略</a></p><p><a href="https://zhuanlan.zhihu.com/p/144774977">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云域名解析</title>
      <link href="/posts/fc296de6/"/>
      <url>/posts/fc296de6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于刚开始接触网站搭建的新手来说，好多东西都需要去了解学习，搭建网站首先需要购买服务器，然后购买域名，然后是域名解析，最后是域名备案等这些大的流程步骤。本节就来将域名的购买备案和解析的步骤，服务器是以阿里云服务器来讲。</p><h2 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h2><blockquote><p>首先就是去万网购买域名，地址在<a href="https://wanwang.aliyun.com/?utm_content=se_1006856673">这里</a>，选择你喜欢的域名和后缀，之后就可以加入清单并且购买。</p></blockquote><img src="/posts/fc296de6/image-20210305134100654.png" alt style="zoom:50%;" loading="lazy"><p>然后，在国内的域名是需要去备案的</p><h2 id="备案"><a href="#备案" class="headerlink" title="备案"></a>备案</h2><p>首先就是要有了自己的服务器实例，然后在控制台去申请备案服务号。</p><img src="/posts/fc296de6/image-20210305134300655.png" alt style="zoom:50%;" loading="lazy"><p>申请步骤按照它的提示来即可，非常简单。</p><p>有了备案服务号之后，就可以去申请备案服务号的地方点开ICP代备案系统，提供它所需要的信息，比如你网站的用途啊，还有你的网站负责人的信息，如果是你本人那就是填写你自己的信息啦！这里需要注意的是，你的网站名称，不要用什么什么技术博客之类的，可以改为使用你自己的名言或者一个其他名字就可以了，反正只有你自己看的见。</p><p>提交完成后，等待他的流程结束，你的域名也就处于可用状态了。</p><p>然后就可以解析到你的服务器上。</p><h2 id="解析域名具体步骤"><a href="#解析域名具体步骤" class="headerlink" title="解析域名具体步骤"></a>解析域名具体步骤</h2><ol><li>打开控制台，进入域名<img src="/posts/fc296de6/image-20210209114350762.png" alt style="zoom:50%;" loading="lazy"></li><li>找到想要解析的域名<img src="/posts/fc296de6/image-20210209114439874.png" alt style="zoom:50%;" loading="lazy"></li><li>添加记录。服务器公网ip<img src="/posts/fc296de6/image-20210209114545682.png" alt style="zoom:50%;" loading="lazy"></li><li>主机记录，就填写www就可以</li><li>解析线路。选择系统默认即可。</li><li>记录值。指的是服务器/虚拟主机的外网IP地址。查看外网IP地址，就直接去购买的服务器详情里面查看。</li><li>TTL。一般以系统默认的情况就行，默认的10分钟就行。</li></ol><p>填写完添加记录之后，最后点击“确定”按钮即可解析完成。</p><h2 id="在nginx中配置域名"><a href="#在nginx中配置域名" class="headerlink" title="在nginx中配置域名"></a>在nginx中配置域名</h2><blockquote><p>解析完成，你的服务器和你的域名都处于可用状态，这时候，你就可以将自己的域名配置到nginx中。</p></blockquote><pre class="language-nginx" data-language="nginx"><code class="language-nginx">server {       listen       8000 default_server;       listen       [::]:8000 default_server;       server_name  # 改为自己的域名       root         /usr/share/nginx/html;       # Load configuration files for the default server block.       include /etc/nginx/default.d/*.conf;       location / {           root   /home/hexo;      # 你的博客地址           index  index.html index.htm;       }       error_page 404 /404.html;       location = /404.html {       }       error_page 500 502 503 504 /50x.html;       location = /50x.html {       }   }</code></pre><p>然后执行这两条命令，重启nginx，就可以通过自己的域名来访问啦。</p><pre class="language-none"><code class="language-none">systemctl stop nginxsystemctl start nginx</code></pre><h2 id="https解析"><a href="#https解析" class="headerlink" title="https解析"></a>https解析</h2><blockquote><p>在阿里云上，是会赠送免费的ssl证书的，首先需要打开控制台，搜索ssl并进入，然后选择云盾ssl证书</p></blockquote><img src="/posts/fc296de6/image-20210305135852323.png" alt style="zoom:50%;" loading="lazy"><p>为了解决免费证书近期存在的吊销、统计等问题，自2021年起，免费证书申请将切换到证书资源包下了，地址在<a href="https://common-buy.aliyun.com/?spm=5176.15089375.J_5834642020.3.5e2865c38sL8jk&amp;commodityCode=cas_dv_public_cn&amp;request=%7B%22ord_time%22:%221:Year%22,%22order_num%22:1,%22product%22:%22cert_product%22,%22domain%22:%22all%22,%22productCode%22:%22symantec-dv-1-starter%22,%22service_num%22:2%7D">这里</a></p><img src="/posts/fc296de6/image-20210305140842701.png" alt style="zoom:50%;" loading="lazy"><p>然后支付0元之后，他就在你的云盾ssl证书中了，直接申请即可，点击下载，选择nginx，你会下载一个压缩包，把其中的两个文件放在你的服务器上，你自己知道的位置即可。</p><p>然后再在nginx配置中，重新配置一个server，使用443端口。并加上如下配置.</p><pre class="language-nginx" data-language="nginx"><code class="language-nginx">server {        listen       443 ssl http2 default_server;        listen       [::]:443 ssl http2 default_server;        server_name  www/godhearing.cn;        root         /usr/share/nginx/html;        ssl_certificate "你下载的位置.pem";        ssl_certificate_key "你下载的位置.key";        ssl_session_cache shared:SSL:1m;        ssl_session_timeout  10m;        ssl_ciphers HIGH:!aNULL:!MD5;        ssl_prefer_server_ciphers on;        # Load configuration files for the default server block.#        include /etc/nginx/default.d/*.conf;#        location / {            root   /home/hexo;            index  index.html index.htm;        }error_page 404 /404.html;        location = /404.html {        }        error_page 500 502 503 504 /50x.html;        location = /50x.html {        }    }}</code></pre><p>然后，重启nginx即可。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python PIL中文变方框的解决办法</title>
      <link href="/posts/56413/"/>
      <url>/posts/56413/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近有个小功能，我看来十分容易，无非就是往图片上添加个文字，但是，在服务器上，瞬间爆炸，所有的中文，都变成一个个的框框，我走了很多弯路，踩了很多坑，在这里记录一下，希望能帮助到同样遇到这个问题的人。</p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><img src="/posts/56413/image-20210206090744358.png" alt style="zoom:67%;" loading="lazy"><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-python" data-language="python"><code class="language-python">from PIL import Image, ImageDraw, ImageFont image= Image.new('RGB', (559, 320),(255,255,255))draw = ImageDraw.Draw(image) # draw.text()font = ImageFont.truetype("arial", 40, encoding="unic") # 设置字体draw.text((100, 50), "哈哈哈", 'black', font)# del drawimage.show()</code></pre><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>我踩了很多的坑，发现有一种及其简易的方式来解决这个问题</p><p>修改字体为simsun.ttc即可，听着简单，但是，假如身处服务器，根本没有这个字体，你需要从windows下copy过去</p></blockquote><ol><li><p>打开”C:\Windows\WinSxS\amd64_microsoft-windows-font-truetype-simsun_31bf3856ad364e35_10.0.18362.1_none_cd668f05ece74044</p><blockquote><p>名字可能会不同，可以搜索simsun.ttc</p></blockquote></li><li><p>通过连接服务器，传到服务器的 <code>/usr/share/fonts</code>文件夹下，如果没有就自己建一个</p></li><li><p>在此目录下，执行<code>#fc-cache -fv</code>，扫描字体目录并生成字体信息的缓存，然后应用程序就可以”立即”使用这些新安装的字体</p></li><li><p>然后重启你的服务器</p></li><li><p>按照相对路径或者绝对路径来进行使用即可。</p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><img src="/posts/56413/image-20210206091500505.png" alt style="zoom:67%;" loading="lazy">]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署Django应用</title>
      <link href="/posts/54683/"/>
      <url>/posts/54683/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在开发完成之后，我们所有的应用，都是要部署到生产环境中的，而docker的出现，让我们看到了容器式部署的好处，就是便捷。</p></blockquote><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><blockquote><p>安装docker和开发web应用我就不多说了，既然能了解到这里，那这些步骤相信对大家来说都是小菜一碟。</p><p>我们从打包开始，首先就是我们使用的Gunicorn的配置，在项目根目录下新建一个<code>gunicorn.conf.py</code></p></blockquote><pre class="language-none"><code class="language-none">import multiprocessingworkers=3 # 并行工作进程数threads = 2 # 指定每个工作者的线程数bind=['0.0.0.0:8000'] # 监听内网端口8000proc_name='yawp' # 进程名称pidfile='/tmp/yawp.pid' # 设置进程文件目录worker_class='gevent' # 工作模式协程timeout=30 # 超时errorlog = '/home/gunicorn.error.log'  # 发生错误时log的路径accesslog = '/home/gunicorn.access.log'  # 正常时的log路径</code></pre><p>然后我们改完项目的一些配置之后，在根目录下新建一个<code>Dockerfile</code>，注意，名字一定要正确，没有任何的后缀，不要自行脑补</p><pre class="language-none"><code class="language-none">FROM python:3.7WORKDIR /Project/你的项目名COPY requirements.txt ./RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simpleCOPY . .ENV LANG C.UTF-8CMD ["gunicorn", "Blue_Lake.wsgi:application","-c","./gunicorn.conf.py"]</code></pre><blockquote><p>给不懂Dockerfile命令的同志讲解一下，Dockerfile一般有以下几个基础命令</p><ol><li><p>基础镜像，以哪个镜像作为基础进行制作，用法是FROM基础镜像名称</p></li><li><p>维护者信息，需要写下该Dockerfile编写人的姓名和邮箱，用法是MIANTAINER</p><p>名字/邮箱</p></li><li><p>镜像操作命令，对基础的镜像要进行的改造命令，比如安装新的软件，进行哪些特殊配置等，常见的是RUN命令</p></li><li><p>容器启动命令，当基于该镜像的容器启动时需要执行哪些命令，常见的是CMD命令或ENTRYPOINT命令</p></li></ol></blockquote><p>然后准备工作完成后，我们就可以进行打包了</p><pre class="language-none"><code class="language-none">docker build -t 项目名 .</code></pre><p>第一次打包可能会比较慢，如果遇到网络问题，重复执行打包命令即可</p><p>还有一件事，重复执行打包命令，会产生空悬镜象，这个解决办法请自行百度，不过不占用我们的空间，不管他也没有事。</p><p>然后键入命令<code>docker images</code> 就可以在看到你的项目镜像了，如果想把这个打包好的项目导出，只需要执行</p><pre class="language-none"><code class="language-none">docker save -o 你要导出的文件名.tar 镜像名</code></pre><p>这样你就可以把他装进U盘，随时带走，也可以进行docker push操作将其上传到dockerhub上。</p><p>然后启动项目</p><pre class="language-none"><code class="language-none">docker run --name 容器名 -d -p 8000:8000 镜像名</code></pre><p>以前也写过一篇类似的攻略，不过当时有点懵懂，所以，我又再次写了一篇攻略，另外，还有一些细小的命令，比如挂载和复制出来。</p><pre class="language-none"><code class="language-none">docker cp 4570:/Project/你的项目/settings.py 宿主机地址/settings.py</code></pre><p>这种场景主要是体现在我们需要修改某些配置的时候，我们需要知道的是，不同的项目打包完之后，项目目录并不是你所熟知的项目目录，就比如我这个django项目，打包完成之后，他的容器内部项目结构是这样的。</p><img src="/posts/54683/image-20210129142315983.png" alt style="zoom:67%;" loading="lazy"><p>我们所熟知的项目，就在Project里。</p><p>然后修改，可以使用vim，也可以使用别的，这都无所谓了。修改完之后，怎么将这个给挂载回去呢，这时候，需要用到我们的-v命令。</p><pre class="language-none"><code class="language-none">docker run --name 你的镜像名 -d -p 8001:8000 -v /宿主机文件地址/settings.py:/Project/你的项目/settings.py 镜像名</code></pre><p>docker的部署，就是这么简单，比一条条的输入命令要强的多了吧。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue解决html2canvas截图不全的问题</title>
      <link href="/posts/61035/"/>
      <url>/posts/61035/</url>
      
        <content type="html"><![CDATA[<h2 id="问题截图"><a href="#问题截图" class="headerlink" title="问题截图"></a>问题截图</h2><img src="/posts/61035/image-20210127160346525.png" alt style="zoom:67%;" loading="lazy"><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>我所知道的原因有两点，</p><p><strong>第一点</strong>：在点击保存图片时，此时要保存的资源较多，造成模块并没有完全加载完毕，就已经生成了截图；</p><p><strong>解决方案</strong>：(加上一个延时操作)</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">// 利用 html2canvas 下载 canvassetTimeout(() =&gt; {    html2canvas(img, { canvas: canvas }).then(function(canvas) {        _this.photoUrl = canvas.toDataURL();    });}, 500);</code></pre><p><strong>第二点</strong>：滚轮滑动造成的，主要是html2canvas是根据body进行截图，若内容高度高于body时，就会出现这样的问题(大概意思就是有滚动条时造成的)<br><strong>解决方案</strong>：(在生成截图前，先把滚动条置顶)</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">window.pageYOffset = 0;document.documentElement.scrollTop = 0document.body.scrollTop = 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker编译时遇到的bug</title>
      <link href="/posts/51106/"/>
      <url>/posts/51106/</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><img src="/posts/51106/image-20210125175514698.png" alt style="zoom:50%;" loading="lazy"><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>在<a href="https://hub.docker.com/">这里</a>注册一个账号，然后终端输入<code>docker login</code>，输入账号密码之后，再次执行打包命令即可</p></blockquote><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><blockquote><p>第二种方法就比较简单加粗暴了，换源，推荐阿里的镜像源， 其他的也可以</p></blockquote><ol><li><p>按照<a href="https://help.aliyun.com/document_detail/60750.html?spm=5176.12901015.0.i12901015.281e525cFBbUpU">这里</a>，去获得分配的加速器地址。</p></li><li><p>打开docker桌面版的设置，也就是settings</p><img src="/posts/51106/image-20210126163650810.png" alt style="zoom:80%;" loading="lazy"><blockquote><p>将这里的地址换成阿里云给分配的地址</p></blockquote></li><li><p>然后终端输入<code>docker info</code> 查看换源成功，即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios获取文件流并且展示为图片</title>
      <link href="/posts/19699/"/>
      <url>/posts/19699/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>axios请求返回的是一张图片，这种情况下，我们可以直接将src定义为请求的地址，但是，如果有请求头等其他信息，这个方法就非常的鸡肋了，所以，我们还是需要搞一下</p></blockquote><h2 id="URL-createObjectURL"><a href="#URL-createObjectURL" class="headerlink" title="URL.createObjectURL()"></a>URL.createObjectURL()</h2><blockquote><p>话不多说，我们直接上代码</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript">this.axios({    url:'http://127.0.0.1:8000/sss/',    method:'get',    responseType:'arraybuffer'}).then(res =&gt; {    return 'data:image/png;base64,' + btoa(        new Uint8Array(res)        .reduce((data, byte) =&gt; data + String.fromCharCode(byte), '')    );}).then(data =&gt; {    this.image = data //图片地址 })</code></pre><blockquote><p>要注意，respnseType是必须的，如果不加，会出不来</p><p>我在这里自己定义了一个image，src属性绑定的就是他，这样，我们就获取到了文件流的同时，把图片预览出来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础</title>
      <link href="/posts/33631/"/>
      <url>/posts/33631/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在一次偶然中，接触到了Go语言，这门语言是一个非常强大的编译型语言，从我接触起，便一直在记录，但愿这些能够帮助到想学习Go语言的人。</p></blockquote><p><a href="https://www.liwenzhou.com/">博客</a></p><p><a href="https://studygolang.com/pkgdoc">文档</a></p><p><a href="http://shouce.jb51.net/gopl-zh/ch1/ch1-01.html">Go语言圣经</a></p><hr><h2 id="1-编译"><a href="#1-编译" class="headerlink" title="1.编译"></a>1.编译</h2><p>使用<code>go build</code></p><p>​    1.在项目目录下执行<code>go build</code></p><p>​    2.在其他路径下执行<code>go build</code>，需要在后面加上项目的路径(项目路径从GOPATH/src后开始写起，编译之后的可执行文件就保存在当前目录下)</p><p>​    3.<code>go build -o ***.exe</code>生成编译文件时执行名字</p><h3 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h3><p>像执行脚本文件一样执行go代码</p><h3 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h3><p><code>go install</code>分为两步：</p><p>​    1.先编译得到一个可执行文件</p><p>​    2.将可执行文件拷贝到GOPATH/bin</p><hr><h4 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h4><p>Go支持跨平台编译</p><p>例如：在windows平添编译一个能在linux平台执行的可执行文件</p><pre class="language-bash" data-language="bash"><code class="language-bash">SET CGO_ENABLED=0 //禁用CGOSET GOOS=linux //目标平台是linuxSET GOARCH=amd64 //目标处理器架构是amd64</code></pre><p>如果要编译可执行文件，必须要有main包和main函数(入口函数，无参数无返回值)</p><hr><h2 id="2-变量和常量"><a href="#2-变量和常量" class="headerlink" title="2.变量和常量"></a>2.变量和常量</h2><pre class="language-go" data-language="go"><code class="language-go">package main//导入语句import "fmt"//函数外只能放标识符(变量，常量，函数，类型)的声明//程序的入口函数func main() {fmt.Println("hello world")}</code></pre><h4 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h4><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p><blockquote><p>如果标识符的首字母是大写的，就表示对外部可见,可以通过包导入</p></blockquote><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><pre class="language-go" data-language="go"><code class="language-go">break        default      func         interface    selectcase         defer        go           map          structchan         else         goto         package      switchconst        fallthrough  if           range        typecontinue     for          import       return       var</code></pre><p><code>nil</code>类似python的<code>null</code></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Go语言中的变量必须先声明再使用</p><p>注意，函数外的每个语句都必须以关键字开始(var，const，func等)</p><p>声明的变量必须使用，不使用就无法编译</p><p>同一个作用域中，不能重复声明同一个变量</p><p><code>var s1 string</code> ：声明了一个s1变量为字符串类型</p><p>批量声明:</p><pre class="language-go" data-language="go"><code class="language-go">var(    a string    b int    c bool)</code></pre><hr><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p><code>fmt.Scan()</code>代表用户输入,输入需要传指针来修改内存地址上的数据</p><pre class="language-go" data-language="go"><code class="language-go">var s stringfmt.Scan(&amp;s)fmt.Println("用户输入的内容：", s)</code></pre><p><code>fmt.Sanf</code>格式化输入</p><pre class="language-go" data-language="go"><code class="language-go">var s stringvar d stringfmt.Scanf(&amp;s &amp;d)fmt.Println("用户输入的内容：", s d)</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Printf(“name:%v”, “天听”)无论是什么类型，都能用%v来打印数值</p><pre class="language-go" data-language="go"><code class="language-go">func main() {fmt.Print("AAA")   //输出打印内容fmt.Println("BBB") //打印完内容之后会加一个换行符    fmt.Printf("name:%s", "天听") //%s:占位符，等于格式化输出}</code></pre><hr><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>占位符%T可以查看类型</p><pre class="language-go" data-language="go"><code class="language-go">fmt.Printf("%T\n", 111)fmt.Printf("%d\n", i1)fmt.Printf("%b\n", i1) //转换为二进制fmt.Printf("%o\n", i1) // 转换为八进制fmt.Printf("%x\n", i1) //转换为十六进制</code></pre><pre class="language-go" data-language="go"><code class="language-go">// %d 十进制// %c 字符// %s 字符串// %p 指针// %v 值// %f 浮点数// %t 布尔值</code></pre><blockquote><p>%%代表的才是%，不能用\转义</p></blockquote><hr><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化</p><pre class="language-go" data-language="go"><code class="language-go">var name = "Q1mi"var age = 18 //根据值判断该变量是什么类型</code></pre><hr><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p><pre class="language-go" data-language="go"><code class="language-go">package mainimport ("fmt")// 全局变量mvar m = 100func main() {n := 10m := 200 // 此处声明局部变量mfmt.Println(m, n)}</code></pre><hr><h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，(<code>_</code>多用于占位，表示忽略值。)例如：</p><pre class="language-go" data-language="go"><code class="language-go">func foo() (int, string) {return 10, "Q1mi"}func main() {x, _ := foo()_, y := foo()fmt.Println("x=", x)fmt.Println("y=", y)}</code></pre><hr><h3 id="常量-const"><a href="#常量-const" class="headerlink" title="常量 const"></a>常量 const</h3><p>声明常量的关键字const</p><pre class="language-go" data-language="go"><code class="language-go">const PI = 3.1415926</code></pre><p>也可以批量声明常量，和批量声明变量一致，只不过关键字从var变为const</p><p>批量声明常量时，如果某一行声明后没有赋值，默认就和上一行一样</p><pre class="language-go" data-language="go"><code class="language-go">const(n1 = 100    n2    n3)</code></pre><hr><h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p><p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用</p><pre class="language-go" data-language="go"><code class="language-go">const (n1 = iota //0n2        //1n3        //2n4        //3)</code></pre><p>使用<code>_</code>跳过某些值</p><pre class="language-go" data-language="go"><code class="language-go">const (n1 = iota //0n2        //1_n4        //3)</code></pre><p><code>iota</code>声明中间插队</p><pre class="language-go" data-language="go"><code class="language-go">const (n1 = iota //0n2 = 100  //100n3 = iota //2n4        //3)const n5 = iota //0</code></pre><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p><pre class="language-go" data-language="go"><code class="language-go">const (_  = iotaKB = 1 &lt;&lt; (10 * iota)MB = 1 &lt;&lt; (10 * iota)GB = 1 &lt;&lt; (10 * iota)TB = 1 &lt;&lt; (10 * iota)PB = 1 &lt;&lt; (10 * iota))</code></pre><p>多个<code>iota</code>定义在一行</p><pre class="language-go" data-language="go"><code class="language-go">const (a, b = iota + 1, iota + 2 //1,2c, d                      //2,3e, f                      //3,4)</code></pre><hr><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p><p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint8</td><td align="center">无符号 8位整型 (0 到 255)</td></tr><tr><td align="center">uint16</td><td align="center">无符号 16位整型 (0 到 65535)</td></tr><tr><td align="center">uint32</td><td align="center">无符号 32位整型 (0 到 4294967295)</td></tr><tr><td align="center">uint64</td><td align="center">无符号 64位整型 (0 到 18446744073709551615)</td></tr><tr><td align="center">int8</td><td align="center">有符号 8位整型 (-128 到 127)</td></tr><tr><td align="center">int16</td><td align="center">有符号 16位整型 (-32768 到 32767)</td></tr><tr><td align="center">int32</td><td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="center">int64</td><td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h4 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h4><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint</td><td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td></tr><tr><td align="center">int</td><td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td></tr><tr><td align="center">uintptr</td><td align="center">无符号整型，用于存放一个指针</td></tr></tbody></table><p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p><p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code></p><p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p><pre class="language-go" data-language="go"><code class="language-go">package mainimport (        "fmt"        "math")func main() {        fmt.Printf("%f\n", math.Pi)        fmt.Printf("%.2f\n", math.Pi)}</code></pre><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p><p><strong>注意：</strong></p><ol><li>布尔类型变量的默认值为<code>false</code>。</li><li>Go 语言中不允许将整型强制转换为布尔型.</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li></ol><hr><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Go语言中字符串是用<strong>双引号</strong>包裹的</p><p>单引号包裹的是字符，字符是单独的字母、汉字、符号</p><h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5><p>转义：</p><p>\代表转义，如果单纯的想打印一个\，需要在前面再加一个\</p><table><thead><tr><th align="center">转义符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>\r</code></td><td align="center">回车符（返回行首）</td></tr><tr><td align="center"><code>\n</code></td><td align="center">换行符（直接跳到下一行的同列位置）</td></tr><tr><td align="center"><code>\t</code></td><td align="center">制表符</td></tr><tr><td align="center"><code>\'</code></td><td align="center">单引号</td></tr><tr><td align="center"><code>\"</code></td><td align="center">双引号</td></tr><tr><td align="center"><code>\\</code></td><td align="center">反斜杠</td></tr></tbody></table><p>多行字符串:    `，使用此符号时，无需用\转义</p><pre class="language-go" data-language="go"><code class="language-go">s1 := `aaabbbccc`</code></pre><table><thead><tr><th align="center">方法</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">len(str)</td><td align="center">求长度</td></tr><tr><td align="center">+或fmt.Sprintf</td><td align="center">拼接字符串</td></tr><tr><td align="center">strings.Split</td><td align="center">分割</td></tr><tr><td align="center">strings.contains</td><td align="center">判断是否包含</td></tr><tr><td align="center">strings.HasPrefix,strings.HasSuffix</td><td align="center">前缀/后缀判断</td></tr><tr><td align="center">strings.Index(),strings.LastIndex()</td><td align="center">子串出现的位置(下标)</td></tr><tr><td align="center">strings.Join(a[]string, sep string)</td><td align="center">join操作</td></tr></tbody></table><p> byte和rune类型</p><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><pre class="language-go" data-language="go"><code class="language-go">var a := '中'var b := 'x'</code></pre><p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code></p><p>修改字符串：</p><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><pre class="language-go" data-language="go"><code class="language-go">func changeString() {s1 := "big"// 强制类型转换byteS1 := []byte(s1)byteS1[0] = 'p'fmt.Println(string(byteS1))s2 := "白萝卜"runeS2 := []rune(s2)runeS2[0] = '红'fmt.Println(string(runeS2))}</code></pre><p>类型转换：</p><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p><p>强制类型转换的基本语法如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">T(表达式)</code></pre><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组的长度是数组类型的一部分，例如<code>var al [3]bool</code>，代表了al是一个长度为3元素类型为布尔的数组</p><h5 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h5><pre class="language-go" data-language="go"><code class="language-go">var a1 [3]bool//初始化a1 = [3]bool{true, true, false}//根据初始值自动推断数组的长度是多少a2 := [...]int{1, 2, 3, 4, 5, 6, 7}fmt.Println(a2)//根据索引初始化a3 := [5]int{0:2,4:3}fmt.Println(a3)</code></pre><h5 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h5><pre class="language-go" data-language="go"><code class="language-go">citys := [...]string{"北京", "上海", "深圳"}for i := 0; i &lt; len(citys); i++ {fmt.Println(citys[i])}</code></pre><pre class="language-go" data-language="go"><code class="language-go">//range遍历for i, v := range citys {fmt.Println(i, v)}</code></pre><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><blockquote><p>多维数组就是数组的嵌套，如[[1,2],[2,3],[3,4]]</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">var a4 [3][2]int//[3]是外层数组，[2]int是该数组的数据类型，元素为两个inta4 = [3][2]int{[2]int{1, 2},[2]int{3, 4},[2]int{5, 6},}fmt.Println(a4)</code></pre><h5 id="多维数组的遍历"><a href="#多维数组的遍历" class="headerlink" title="多维数组的遍历"></a>多维数组的遍历</h5><pre class="language-go" data-language="go"><code class="language-go">var a4 [3][2]inta4 = [3][2]int{[2]int{1, 2},[2]int{3, 4},[2]int{5, 6},}for _, v := range a4 {for _, i := range v {fmt.Println(i)}}</code></pre><hr><h2 id="4-if与for"><a href="#4-if与for" class="headerlink" title="4.if与for"></a>4.if与for</h2><h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><pre class="language-go" data-language="go"><code class="language-go">age := 16if age &gt;= 18 {fmt.Println("成年")} else {fmt.Println("未成年")}</code></pre><p>也可以将变量定义到if的作用域中,这样，该变量只会在if作用域中</p><pre class="language-go" data-language="go"><code class="language-go">if age := 16; age &gt;= 18 {fmt.Println("成年")} else {fmt.Println("未成年")}</code></pre><p>else if</p><pre class="language-go" data-language="go"><code class="language-go">if age := 16; age &gt;= 18 {fmt.Println("成年")} else if age &gt;= 16 {fmt.Println("小成年")} else {fmt.Println("未成年")}</code></pre><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>基本格式</p><p>for 初始语句;条件;结束语句{}</p><pre class="language-go" data-language="go"><code class="language-go">for i := 0; i &lt; 10; i++ {fmt.Println(i)}</code></pre><p>省略初始语句的写法 **;**不能少</p><pre class="language-go" data-language="go"><code class="language-go">var i=5for ;i&lt;10;i++{    fmt.Println(i)}</code></pre><p>省略结束语句的写法,如果不加条件，则是无限循环，由于go语言运行速度极快，不要轻易尝试</p><pre class="language-go" data-language="go"><code class="language-go">var i=5for ;i&lt;10;{    fmt.Println(i)    i++}</code></pre><p>for range循环，有两个变量接收，第一个是索引，第二个是值</p><pre class="language-go" data-language="go"><code class="language-go">s:= "hello天听"for i,v := range s{    fmt.Printf("%d,%c\n",i,v)}</code></pre><p>break：跳出for循环</p><p>contiune：跳过本次循环，继续下一次</p><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>简化大量的判断</p><pre class="language-go" data-language="go"><code class="language-go">var a = 3switch a {case 1:fmt.Println("1")case 2:fmt.Println("2")case 3:fmt.Println("3")case 4:fmt.Println("4")    default:        fmt.Println("无效") }</code></pre><hr><h2 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5.运算符"></a>5.运算符</h2><p>Go语言是<code>强类型</code>,相同类型的变量才能比较</p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">相加</td></tr><tr><td align="center">-</td><td align="center">相减</td></tr><tr><td align="center">*</td><td align="center">相乘</td></tr><tr><td align="center">/</td><td align="center">相除</td></tr><tr><td align="center">%</td><td align="center">求余</td></tr></tbody></table><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td align="center">!=</td><td align="center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td align="center">&gt;</td><td align="center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&gt;=</td><td align="center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&lt;</td><td align="center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&lt;=</td><td align="center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">||</td><td align="center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td align="center">!</td><td align="center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符对整数在内存中的<code>二进制</code>位进行操作。</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td></tr><tr><td align="center">|</td><td align="center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td></tr><tr><td align="center">^</td><td align="center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><table><thead><tr><th>=</th><th>简单的赋值运算符，将一个表达式的值赋给一个左值</th></tr></thead><tbody><tr><td>+=</td><td>相加后再赋值</td></tr><tr><td>-=</td><td>相减后再赋值</td></tr><tr><td>*=</td><td>相乘后再赋值</td></tr><tr><td>/=</td><td>相除后再赋值</td></tr><tr><td>%=</td><td>求余后再赋值</td></tr><tr><td>&lt;&lt;=</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;=</td><td>右移后赋值</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td></tr><tr><td>|=</td><td>按位或后赋值</td></tr><tr><td>^=</td><td>按位异或后赋值</td></tr></tbody></table><hr><h2 id="6-切片"><a href="#6-切片" class="headerlink" title="6.切片"></a>6.切片</h2><p><code>len</code>代表长度</p><p><code>cap</code>代表容量</p><blockquote><p>切片必须初始化分配内存</p><p>切片不存值，指向同一个底层数组，所以，怎样赋值切片之后改变，都会使同样的底层数组发生改变，类似浅拷贝</p></blockquote><h4 id="自定义切片"><a href="#自定义切片" class="headerlink" title="自定义切片"></a>自定义切片</h4><pre class="language-go" data-language="go"><code class="language-go">var s1 []int //定义一个存放int类型元素的切片//初始化s1 = []int{1,2,3}</code></pre><h4 id="由数组得到切片"><a href="#由数组得到切片" class="headerlink" title="由数组得到切片"></a>由数组得到切片</h4><pre class="language-go" data-language="go"><code class="language-go">a1 :=[...]int{1,2,3,4,5}s3 := a1[0:4]</code></pre><h4 id="make函数创建切片"><a href="#make函数创建切片" class="headerlink" title="make函数创建切片"></a>make函数创建切片</h4><blockquote><p>make([]int,元素数量,容量)</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">s1 := make([]int, 5,10)fmt.Printf("s1=%v len(s1)=%d cap(s1)=%d\n", s1, len(s1), cap(s1))</code></pre><p>切片的本质就是一个框，框住了一块连续的内存，属于引用类型，真正的数据都保存在底层数组里</p><p>切片不能<strong>直接比较</strong>，只能和<strong>nil</strong>比较</p><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><h4 id="append函数添加"><a href="#append函数添加" class="headerlink" title="append函数添加"></a>append函数添加</h4><blockquote><p>调用append函数必须使用原来的切片变量接收返回值</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">s1 := []string{"龙潭", "四海门", "空境"}s1 = append(s1, "洞天")fmt.Println(s1)//多个元素添加，用...进行拆开s1 := []string{"龙潭", "四海门", "空境"}s2 := []string{"望苍城", "天下城", "万象城"}s1 = append(s1, s2...)fmt.Println(s1)</code></pre><h4 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h4><pre class="language-go" data-language="go"><code class="language-go">首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</code></pre><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><pre class="language-go" data-language="go"><code class="language-go">//此处，将s1的值拷贝给了s3，深拷贝，此时s1如何修改都与s3无关s1 := []string{"龙潭", "四海门", "空境"}s2 := s1var s3 = make([]string, 3, 3)fmt.Println(s1, s2, s3)copy(s3, s1)fmt.Println(s1, s2, s3)</code></pre><h4 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h4><pre class="language-go" data-language="go"><code class="language-go">// 从切片中删除元素a := []int{30, 31, 32, 33, 34, 35, 36, 37}// 要删除索引为2的元素a = append(a[:2], a[3:]...)fmt.Println(a) //[30 31 33 34 35 36 37]</code></pre><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7.指针"></a>7.指针</h2><p>在Go语言中对于引用类型的变量，在使用的时候不仅要声明它，还要为它分配内存空间，否则值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。Go语言中new和make是内建的两个函数，主要用来分配内存。</p><blockquote><p>go语言中不存在指针操作，只需要记住两个符号</p><p><code>&amp;</code>：取地址</p><p><code>*</code>：根据地址取值</p></blockquote><ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li></ul><pre class="language-go" data-language="go"><code class="language-go">//&amp;a := 20fmt.Println(&amp;a)//*p := &amp;am := *pfmt.Println(m)</code></pre><h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p>new函数是一个内置的函数，可以申请一个内存地址</p><p>new很少用，一般用来给基本数据类型申请内存，int/string等</p><pre class="language-go" data-language="go"><code class="language-go">var a *int  //声明一个变量fmt.Println(a)var a2 = new(int) // new函数申请内存地址fmt.Println(*a2)*a2 = 100 //重新赋值fmt.Println(*a2)</code></pre><blockquote><p>返回的是指针</p></blockquote><h3 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h3><blockquote><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针。</p></blockquote><hr><h2 id="8-map"><a href="#8-map" class="headerlink" title="8.map"></a>8.<strong><code>map</code></strong></h2><blockquote><p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p></blockquote><blockquote><p>map是一种<strong>无序</strong>的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p></blockquote><p>map[键类型]值类型</p><pre class="language-go" data-language="go"><code class="language-go">var a map[string]int // 声明一个mapa = make(map[string]int, 10) //初始化a["天听"] = 20//添加数据a["并轩"] = 30a["冰冰"] = 16fmt.Println(a)v, ok := a["冰冰"]  //返回两个值，一个是数据，一个是布尔值，约定成俗是okif !ok { //如果ok为false，则查找不到fmt.Println("查无此人")} else {fmt.Println(v)}</code></pre><h3 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h3><pre class="language-go" data-language="go"><code class="language-go">for k, v := range a {fmt.Println(k, v)}</code></pre><p>如果只用一个参数接收，默认接收k</p><pre class="language-go" data-language="go"><code class="language-go">for k := range a {fmt.Println(k)}</code></pre><p>如果只是单纯的想拿到值，可以用_接收k</p><pre class="language-go" data-language="go"><code class="language-go">for _, v := range a {fmt.Println(v)}</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>用delete删除</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">delete(a,键)</code></pre><h2 id="9-函数"><a href="#9-函数" class="headerlink" title="9.函数"></a>9.函数</h2><p>函数是一段代码的<strong>封装</strong></p><blockquote><p>在go语言中，函数格式为<code>func 函数名(参数)(返回值){}</code></p><p>并且要指定参数类型和返回值类型</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func sum(x int, y int) (ret int) {return x * y}func main() {a := sum(2, 55)fmt.Println(a)}</code></pre><blockquote><p>无参数有返回值</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func a1() string {return "jajajaj"}</code></pre><blockquote><p>返回值可以命名也可以不命名，但是，需要声明返回值</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func a2(x int,y int)(ret int){ //声明ret    ret = x+y //直接可以使用}//也可以不命名返回值func a2(x int,y int) int{    ret := x+y //声明    return ret //使用}</code></pre><blockquote><p>返回值可以有多个，需要用()括起来</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func a2(x int,y int)(int,string){    return 1,"天听"}</code></pre><blockquote><p>参数类型简写</p><p>当参数中，连续两个参数类型一致，可以将前边的参数类型省略</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func a2(x,y int)(ret int){    ret = x+y}</code></pre><blockquote><p>可变长参数</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func a2(x string,y ...int){ //...int，可变长，但是，都得是int类型    fmt.Println(x)    fmt.Println(y)}</code></pre><blockquote><p>注意，go语言中函数传参永远是深拷贝</p></blockquote><h3 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h3><blockquote><p><code>defer</code>语句会将其后边跟随的语句进行延迟处理，在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行</p><p>也就是说，有多个<code>defer</code>语句时，最先写的<code>defer</code>最后被执行，最后写的<code>defer</code>最先被执行</p></blockquote><blockquote><p>defer多用于函数结束之前释放资源</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func deferDemo() {fmt.Println("start")defer fmt.Println("AAA")defer fmt.Println("BBB")defer fmt.Println("CCC")fmt.Println("end")}/*执行结果为startendCCCBBBAAA*/</code></pre><p>Go语言中的<strong>return</strong>不是原子操作，在底层是分为两步来执行</p><blockquote><p>第一步：返回值赋值</p><p>第二步：真正的RET返回</p><p>函数中如果存在defer，那么defer执行的时机是在第一步和第二步之间</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func f1() (x int) {    x = 5   //返回值赋值defer func() {x++  //执行defer}()return x //RET返回}</code></pre><pre class="language-go" data-language="go"><code class="language-go">func f1() int {   //此时的返回值没有命名x := 5defer func() {  //defer修改的是x而不是返回值x++}()return x  }</code></pre><blockquote><p>函数也可以作为参数和返回值</p><p>只要是满足参数和返回值的类型要求</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func f1(){ //类型为func()    }func f2() int{  // 类型为func()int    return 100}func f3(x func()){ //此处可以将类型为func()的函数传进来    }func f4(x func()int){//此处可以将类型为func()int的函数传进来    }</code></pre><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><blockquote><p>因为函数内部无法声明有名字的函数，所以，在匿名函数多用于在函数内部</p></blockquote><p>匿名函数定义：<code>func(){}</code></p><pre class="language-go" data-language="go"><code class="language-go">func main(){    func(x,y int){        fmt.Println(x+y)    }(1,2)//如果只是调用一次的函数，可以简写成立即执行函数，加个括号}</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p>闭包的本质就是一个函数，函数可以作为返回值，因为函数内部查找变量的顺序是由内而外，所以，在自己内部找不到变量就得去外层找，包含了一个外部作用域变量的特殊函数</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func f1(a int) (func(int) int, func(int) int) {//声明一个函数，有参数a，两个有参有返的函数返回值add := func(i int) int {a += ireturn a}    //内部声明匿名函数sub := func(i int) int {a -= ireturn a}    //内部声明匿名函数return add, sub    //满足了条件}func main() {q1, q2 := f1(10) //  q1,q2的类型为func(int) int// 参数a是10fmt.Println(q1(1), q2(2)) //11 9}</code></pre><blockquote><p>上面的例子中为什么不是8而是9，因为传的参数a并不是内部匿名函数的参数，所以，按照返回值的顺序，先执行了add，再执行sub</p></blockquote><h2 id="10-作用域"><a href="#10-作用域" class="headerlink" title="10.作用域"></a>10.作用域</h2><blockquote><p>和python相同点，全局作用域和局部作用域</p><p>不同点为，Go语言的if…else，switch..case等都会产生<strong>语句块作用域</strong></p></blockquote><h2 id="11-内置函数"><a href="#11-内置函数" class="headerlink" title="11.内置函数"></a>11.内置函数</h2><table><thead><tr><th align="center">内置函数</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">close</td><td align="center">主要用来关闭channel</td></tr><tr><td align="center">len</td><td align="center">用来求长度，比如string、array、slice、map、channel</td></tr><tr><td align="center">new</td><td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td align="center">make</td><td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td align="center">append</td><td align="center">用来追加元素到数组、slice中</td></tr><tr><td align="center">panic和recover</td><td align="center">用来做错误处理</td></tr></tbody></table><h3 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a>panic/recover</h3><blockquote><p>Go语言中目前是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func f2() {defer func() {err := recover()fmt.Println(err)fmt.Println("关闭程序")}()fmt.Println("B")panic("错误")}</code></pre><blockquote><p>注意，<code>recover</code>一定要搭配<code>defer</code>使用</p></blockquote><h2 id="12-自定义类型和类型别名"><a href="#12-自定义类型和类型别名" class="headerlink" title="12.自定义类型和类型别名"></a>12.自定义类型和类型别名</h2><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><p><code>type 自定义类型 内置类型</code></p><pre class="language-go" data-language="go"><code class="language-go">type ssint int</code></pre><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p><code>type 别名 = 内置类型</code></p><pre class="language-go" data-language="go"><code class="language-go">type yourInt = int</code></pre><h2 id="13-结构体"><a href="#13-结构体" class="headerlink" title="13.结构体"></a>13.结构体</h2><blockquote><p>结构体的内存地址是连续的，并不是每个字段一个内存</p></blockquote><blockquote><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p></blockquote><p>Go语言中通过<code>struct</code>来实现面向对象</p><blockquote><p>使用<code>type</code>和<code>struct</code>关键字来定义结构体</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">type 类型名 struct{    字段名 字段类型    字段名 字段类型}type person struct{    name string    age int    gender string}//实例化"对象"var a persona.name = "天听"a.age = 18a.gender = "男"</code></pre><h4 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h4><pre class="language-go" data-language="go"><code class="language-go">var s struct{    name string    age int}</code></pre><blockquote><p>和定义结构体不同的是，匿名结构体是在声明变量，而不是声明结构体类型</p></blockquote><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><blockquote><p>结构体可以当做值传进函数内，通过指针，也可以将某个值的内存地址传过去</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func f1(x person) {  //此时传的是结构体x.gender = "女"}func f2(x *person) { // 此时，传的是结构体的指针(*x).gender = "女"    //x.gender = "女"   //两种写法都可以}func main() {var a persona.name = "天听"a.gender = "男"f1(a)fmt.Println(a.gender) //由于传过去的是深拷贝，所以，修改不会成功f2(&amp;a)fmt.Println(a.gender)//通过指针修改了内存地址上的值，所以，修改成功了}</code></pre><h4 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h4><pre class="language-go" data-language="go"><code class="language-go">var b = persson{name:   "并轩",gender: "女",}fmt.Println(b)</code></pre><pre class="language-go" data-language="go"><code class="language-go">var c = persson{"狮子","男",}fmt.Println(c)</code></pre><blockquote><p>注意，以上两种方法不能混用</p></blockquote><blockquote><p>当结构体比较大的时候尽量使用结构体指针，减少程序的内存开销</p></blockquote><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote><p>返回一个结构体变量的函数</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func newDog(name string) dog {    return dog{        name:name,    }}</code></pre><h4 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h4><blockquote><p>方法是作用域特定类型的函数</p></blockquote><blockquote><p>接收者表示的是调用该方法的具体类型变量，多用类型名首字母小写表示，写在函数名前面</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">type dog struct{    name string}func (d dog)wang(){    fmt.Printf("%s:汪汪汪~",d.name)}func main(){    d1 := newDog("哈士奇")    d1.wang()}</code></pre><h5 id="接收者"><a href="#接收者" class="headerlink" title="接收者"></a>接收者</h5><pre class="language-go" data-language="go"><code class="language-go">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {    函数体}</code></pre><p>什么时候需要用指针接收者：</p><blockquote><p>需要修改接收者的值，需要用指针接收者</p></blockquote><blockquote><p>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者</p></blockquote><blockquote><p>接收者是拷贝代价比较大的大对象</p></blockquote><h4 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h4><blockquote><p>结构体中只有类型没有名字的字段，并且类型不能重复</p><p>当字段比较少也比较简单时使用</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">type person struct{    string    int    //string  此时再写string就会报错，因为类型不能重复}</code></pre><h4 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h4><blockquote><p>结构体嵌套结构体</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">type address struct{  //类型1    name string    age int}type ren struct{    gender string    addr address   // 嵌套了类型1}func main(){    f1 := ren{        gender:"男",        addr:address{   //嵌套结构体构造数据            name:"天听",            age:20,        }    }}</code></pre><h4 id="匿名嵌套结构体"><a href="#匿名嵌套结构体" class="headerlink" title="匿名嵌套结构体"></a>匿名嵌套结构体</h4><pre class="language-go" data-language="go"><code class="language-go">type address struct{      name string    age int}type ren struct{    gender string    address   // 匿名嵌套}func main(){    f1 := ren{        gender:"男",        addr:address{               name:"天听",            age:20,        }    }    // fmt.Println(f1.addr.name)    fmt.Println(f1.name)}</code></pre><blockquote><p>匿名嵌套结构体的好处是可以直接调用被嵌套结构体中的字段</p><p>但是，如果嵌套了两个结构体，而这两个结构体中有一样的字段，这种写法会有字段冲突，解决办法就是写全</p></blockquote><h4 id="结构体模拟“继承”"><a href="#结构体模拟“继承”" class="headerlink" title="结构体模拟“继承”"></a>结构体模拟“继承”</h4><pre class="language-go" data-language="go"><code class="language-go">//动物类type animal struct {name string}//动物的方法func (a animal) move() {fmt.Printf("%s会动\n", a.name)}//狗类，继承动物类type dog struct {id uint8animal}//狗类的方法func (d dog) wang() {fmt.Printf("%s在叫", d.name)}func main() {d1 := dog{id:     1,animal: animal{name: "哈士奇"},}d1.wang()d1.move()  //动物类的方法，狗类同样也能使用}</code></pre><h4 id="结构体与JSON"><a href="#结构体与JSON" class="headerlink" title="结构体与JSON"></a>结构体与JSON</h4><blockquote><p>序列化：把go语言中的结构体变量转换为json格式的字符串</p><p>反序列化：json格式的字符串转换为go语言中能够识别的结构体变量</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">import "encoding/json"func main(){    f1 := person{        name:"天听",        age:18,    }    b,err := json.Marshal(f1)}</code></pre><h2 id="14-接口"><a href="#14-接口" class="headerlink" title="14.接口"></a>14.接口</h2><p>关键字：<code>interface</code></p><blockquote><p>注意：接口是一种类型,他规定了数据有哪些方法</p></blockquote><p>例如，结构体Dog可以walk和bark， 如果一个接口声明了walk和bark的方法签名，而Dog实现了walk和bark方法，那么Dog就实现了该接口。<br> 接口的主要工作是仅提供由方法名称，输入参数和返回类型组成的方法签名集合。 由类型（例如struct结构体）来声明方法并实现它们。</p><pre class="language-go" data-language="go"><code class="language-go">//造接口，只要是有speak方法的变量，他就是speaker类型的接口type speaker interface {speak()}//造两个结构体type dog struct{}type cat struct{}//各有一个speak方法func (d dog) speak() {fmt.Println("汪汪汪")}func (c cat) speak() {fmt.Println("喵喵喵")}//只需要将接口传进来即可func da(x speaker) {x.speak()}func main() {var c catvar d dogda(c)da(d)}</code></pre><blockquote><p>一个接口中可以有多个方法，但是需要全部实现才算是这个接口类型的变量，只实现其中的某个方法不算这个接口变量.</p><p>同一个结构体可以实现多个接口</p></blockquote><p> 使用<strong>值接收者</strong>和<strong>指针接收者</strong>实现接口区别：</p><pre><code>1. 使用**值接收者**实现接口，结构体类型和结构体指针类型的变量都能存2. **指针接收者**实现接口，只能存结构体指针类型的变量</code></pre><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><pre class="language-go" data-language="go"><code class="language-go">interface{}   // 空接口</code></pre><blockquote><p>所有的类型都实现了空接口，也就是任意类型的变量都能保存在空接口中</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func main(){    var m1 map[string]interface{}//注意加括号，否则只是关键字    m1 = make(map[string]interface{})    m1["name"] = "天听"    m1["age"] = 18}</code></pre><blockquote><p>在上面的例子中，既可以保存字符串，又能保存整型</p></blockquote><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p><code>x.(T)</code> </p><ul><li>x:表示类型为<code>interface{}</code>的变量</li><li>T:表示断言，x可能是的类型</li></ul><pre class="language-go" data-language="go"><code class="language-go">func ss(a interface{}){    str,ok := a.(string) //类型断言    if !ok{        fmt.Println("猜错了")    }else{        fmt.Println("字符串")    }}</code></pre><pre class="language-go" data-language="go"><code class="language-go">func ss(a interface{}){    switch t := a.(type){        case string:        fmt.Println("字符串")        case int:        fmt.Println("整型")        case bool:        fmt.Println("布尔")    }}</code></pre><h2 id="15-包"><a href="#15-包" class="headerlink" title="15.包"></a>15.包</h2><p>包中的<code>标识符</code>首字母大写才可以对外部可见</p><blockquote><p>根据自己的需要创建自己的包。一个包可以简单理解为一个存放<code>.go</code>文件的<strong>文件夹</strong>。 该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">package 包名   //包的定义</code></pre><ul><li>一个文件夹下面直接包含的文件只能归属一个<code>package</code>，同样一个<code>package</code>的文件不能在多个文件夹下。</li><li>包名可以不和文件夹的名字一样，包名不能包含 <code>-</code> 符号。</li><li>包名为<code>main</code>的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含<code>main</code>包的源代码则不会得到可执行文件。</li></ul><blockquote><p>要在代码中引用其他包的内容，需要使用<code>import</code>关键字导入使用的包</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">import "包的路径"   // 包的导入</code></pre><p>注意事项：</p><ul><li>import导入语句通常放在文件开头包声明语句的下面。</li><li>导入的包名需要使用双引号包裹起来。</li><li>包名是从<code>$GOPATH/src/</code>后开始计算的，使用<code>/</code>进行路径分隔。</li><li>Go语言中禁止循环导入包。</li></ul><h4 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a>匿名导入包</h4><blockquote><p>如果只希望导入包，而不使用包内部的数据时，可以使用匿名导入包</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">import _ "包的路径"</code></pre><blockquote><p>匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中</p></blockquote><h4 id="init初始化函数"><a href="#init初始化函数" class="headerlink" title="init初始化函数"></a>init初始化函数</h4><blockquote><p>在Go语言程序执行时导入包语句会自动触发包内部<code>init()</code>函数的调用。需要注意的是： <code>init()</code>函数没有参数也没有返回值。 <code>init()</code>函数在程序运行时自动被调用执行，不能在代码中主动调用它</p></blockquote><h2 id="16-文件操作"><a href="#16-文件操作" class="headerlink" title="16.文件操作"></a>16.文件操作</h2><blockquote><p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>和一个<code>err</code>。对得到的文件实例调用，<code>close()</code>方法能够关闭文件。</p></blockquote><blockquote><p>为了防止文件忘记关闭，通常使用defer注册文件关闭语句</p></blockquote><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><pre class="language-go" data-language="go"><code class="language-go">//打开文件，返回两个参数fileobj, err := os.Open("./main.go")if err != nil {fmt.Println("错误为:", err)return}defer fileobj.Close()var tmp = make([]byte, 128)//var tmp = [128]bytefor {n, err := fileobj.Read(tmp[:])if err != nil {fmt.Println("读取错误为：", err)return}fmt.Println("读取的字节数为：", n)fmt.Println(string(tmp[:n]))if n &lt; 128 {return}}</code></pre><h4 id="file-Read"><a href="#file-Read" class="headerlink" title="file.Read()"></a>file.Read()</h4><blockquote><p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code></p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func (f *File) Read(b []byte) (n int, err error)//Read方法定义</code></pre><h4 id="bufio"><a href="#bufio" class="headerlink" title="bufio"></a>bufio</h4><blockquote><p>bufio是在file的基础上封装了一层API，支持更多的功能</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">fileobj, err := os.Open("./main.go")if err != nil {fmt.Println("错误为：", err)return}defer fileobj.Close()//创建一个用来从文件中读取内容的对象reader := bufio.NewReader(fileobj)for {line, err := reader.ReadString('\n')if err == io.EOF {return}if err != nil {fmt.Println("！！！！", err)return}fmt.Print(line)}</code></pre><h4 id="ioutil"><a href="#ioutil" class="headerlink" title="ioutil"></a>ioutil</h4><p><code>io/ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入</p><pre class="language-go" data-language="go"><code class="language-go">content, err := ioutil.ReadFile("./main.go")if err != nil {    fmt.Println("read file failed, err:", err)    return}fmt.Println(string(content))</code></pre><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能</p><p><code>name</code>：要打开的文件名</p><p> <code>flag</code>：打开文件的模式：</p><table><thead><tr><th align="center">模式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>os.O_WRONLY</code></td><td align="center">只写</td></tr><tr><td align="center"><code>os.O_CREATE</code></td><td align="center">创建文件</td></tr><tr><td align="center"><code>os.O_RDONLY</code></td><td align="center">只读</td></tr><tr><td align="center"><code>os.O_RDWR</code></td><td align="center">读写</td></tr><tr><td align="center"><code>os.O_TRUNC</code></td><td align="center">清空</td></tr><tr><td align="center"><code>os.O_APPEND</code></td><td align="center">追加</td></tr></tbody></table><h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><blockquote><p>写入字节切片数据</p></blockquote><h4 id="WriteString"><a href="#WriteString" class="headerlink" title="WriteString"></a>WriteString</h4><blockquote><p>直接写入字符串数据</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">fileobj, err := os.OpenFile("./ss.txt", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)if err != nil {fmt.Println(err)return}fileobj.Write([]byte("执子之魂，与子共生\n"))fileobj.WriteString("那些逃离死亡的人，其生命，早已停滞不前")defer fileobj.Close()</code></pre><h4 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h4><pre class="language-go" data-language="go"><code class="language-go">fileobj, err := os.OpenFile("./ss.txt", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)if err != nil {fmt.Println(err)return}wr := bufio.NewWriter(fileobj)//将数据先写入缓存wr.WriteString("明天，只是一个希望，不是一个承诺")//将缓存中的内容写入文件wr.Flush()defer fileobj.Close()</code></pre><h4 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h4><pre class="language-go" data-language="go"><code class="language-go">str := "hello 龙潭"err := ioutil.WriteFile("./xx.txt", []byte(str), 0666)if err != nil {    fmt.Println("write file failed, err:", err)    return}</code></pre><h2 id="17-时间模块"><a href="#17-时间模块" class="headerlink" title="17.时间模块"></a>17.时间模块</h2><h4 id="time包"><a href="#time包" class="headerlink" title="time包"></a><code>time</code>包</h4><blockquote><p>time包是时间模块</p></blockquote><blockquote><p>当前时间</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func main(){    now := time.Now()    fmt.Println(now)    fmt.Println(now.Year())}</code></pre><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><blockquote><p><code>Unix()</code></p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func main(){    now := time.Now()    fmt.Println(now.Unix()) //时间戳    fmt.Println(now.UnixNano()) //纳秒时间戳}</code></pre><h4 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h4><p><code>time.Duration</code>是<code>time</code>包定义的一个类型，它代表两个时间点之间经过的时间，以<strong>纳秒</strong>为单位。</p><p>time包中定义的时间间隔类型的常量如下：</p><pre class="language-go" data-language="go"><code class="language-go">const (    Nanosecond  Duration = 1    Microsecond          = 1000 * Nanosecond    Millisecond          = 1000 * Microsecond    Second               = 1000 * Millisecond    Minute               = 60 * Second    Hour                 = 60 * Minute)</code></pre><blockquote><p><code>time.Duration</code>表示1纳秒，<code>time.Second</code>表示1秒。</p></blockquote><h4 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h4><blockquote><p>在日常编码可能会遇到要求时间+时间间隔需求，这时，需要用到<code>Add</code></p></blockquote><pre class="language-go" data-language="go"><code class="language-go">fmt.Println(time.Second)//当前时间+24小时fmt.Println(now.Add(24*time.Hour))</code></pre><h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><blockquote><p>通俗的讲，就是把语言中的时间对象转换成字符串类型的时间</p></blockquote><blockquote><p>格式化时间模板不是常见的<code>Y-m-d H:M:S</code>而是使用Go的诞生时间2006年1月2号15点04分（记忆口诀为2006 1 2 3 4）</p></blockquote><p><code>now.Format</code></p><pre class="language-go" data-language="go"><code class="language-go">// 注意，格式化是从2006-01-02开始，这个值不可变fmt.Println(now.Format("2006-01-02"))fmt.Println(now.Format("2006-01-02 15:04:05"))</code></pre><h4 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h4><blockquote><p>按照对应的格式解析字符串类型的时间</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">time.Parse("2006-01-02","2020-8-20")</code></pre><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><blockquote><p>使用<code>time.Tick(时间间隔)</code>来设置定时器，定时器的本质上是一个通道（channel）</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func tickDemo() {ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器for i := range ticker {fmt.Println(i)//每秒都会执行的任务}}</code></pre><h2 id="18-log日志服务"><a href="#18-log日志服务" class="headerlink" title="18.log日志服务"></a>18.log日志服务</h2><blockquote><p>Go语言内置的<code>log</code>包实现了简单的日志服务。</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">log.Println("打印的日志")//输入结果//2020/08/20 16:28:50 打印的日志</code></pre><p><code>log.SetOutput()</code>设置输出位置</p><h2 id="19-反射"><a href="#19-反射" class="headerlink" title="19.反射"></a>19.反射</h2><blockquote><p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p></blockquote><blockquote><p>反射类似于ORM</p></blockquote><h4 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h4><blockquote><p>在Go语言的反射机制中，任何接口值都由是<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成</p></blockquote><blockquote><p>在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p><p>注意，无论是<code>TypeOf</code>还是<code>ValueOf</code>，都有一个kind方法，要注意。</p></blockquote><h4 id="type-name-和-type-kind"><a href="#type-name-和-type-kind" class="headerlink" title="type name 和 type kind"></a>type name 和 type kind</h4><p>在反射中类型具体划分为两种，一种是类型(Type)， 一种是种类(Kind)</p><pre class="language-go" data-language="go"><code class="language-go">type Cat struct{  Name string}</code></pre><p>一个结构体，此时，我们如果要打印他的类型的话，他是一个Cat类型，但是，同时他也属于struct，struct就属于他的种类(Kind)，Cat就是他的类型(Type)，</p><h2 id="20-高并发"><a href="#20-高并发" class="headerlink" title="20.高并发"></a>20.高并发</h2><blockquote><p>都知道，golang天生支持高并发，语言特性使得他是一个并发的杀器。</p></blockquote><h4 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h4><p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p><p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p><p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p><p>举个例子：</p><pre class="language-go" data-language="go"><code class="language-go">package mainimport ("fmt""time")func newTask()  {i := 0for {i++fmt.Println("newTask",i)time.Sleep(1 * time.Second)}}func main() {go newTask()i := 0for {i++fmt.Println("main", i)time.Sleep(1 * time.Second)}}</code></pre><blockquote><p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p><p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是权利的游戏中的夜王，其他的<code>goroutine</code>都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序用户认证逻辑</title>
      <link href="/posts/9000/"/>
      <url>/posts/9000/</url>
      
        <content type="html"><![CDATA[<p><strong>调用</strong></p><ol><li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.login.html">wx.login()</a>获取临时登录凭证code，并回传到开发者服务器。</li><li>调用<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/code2Session.html">code2Session</a>接口，换取用户唯一标识 OpenID和会话密钥 session_key。</li></ol><p>之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。</p><p><strong>注意：</strong></p><p>会话密钥<code>session_key</code>是对用户数据进行<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html">加密签名</a>的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。</p><p>临时登录凭证 code 只能使用一次</p><p><strong>总结:</strong><br>小程序端执行wx.login后在回调函数中就能拿到上图的code,然后把这个code传给我们后端程序，后端拿到这个这个code后，可以请求code2Session接口拿到用的openid和session_key,openid是用户在微信中唯一标识，我们就可以把这个两个值(val)存起来，然后返回一个键（key）给小程序端，下次小程序请求我们后端的时候，带上这个key，我们就能找到这个val,就可以，这样就把登入做好了。</p><p><strong>wx.login</strong></p><p>调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户的唯一标识（openid）及本次登录的会话<br>密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。[/code]</p><p>参数</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th><th align="left">最低版本</th></tr></thead><tbody><tr><td align="left">timeout</td><td align="left">number</td><td align="left"></td><td align="left">否</td><td align="left">超时时间，单位ms</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.9.90</a></td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td><td align="left"></td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td><td align="left"></td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td><td align="left"></td></tr></tbody></table><p>object.success 回调函数</p><p>参数</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">code</td><td align="left">string</td><td align="left">用户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/code2Session.html">code2Session</a>，使用 code 换取 openid 和 session_key 等信息</td></tr></tbody></table><p><strong>code2Session</strong></p><p>本接口应在服务器端调用，详细说明参见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/backend-api.html">服务端API</a>。</p><p>登录凭证校验。通过<a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.login.html">wx.login()</a>接口获得临时登录凭证 code 后传到开发者服务器调用此接口完成登录流程。更多使用方法详见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">小程序登录</a>。</p><p>请求地址</p><p>GET <a href="https://api.weixin.qq.com/sns/jscode2sessionappid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code">https://api.weixin.qq.com/sns/jscode2sessionappid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code</a></p><p>请求参数</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">appid</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">小程序 appId</td></tr><tr><td align="left">secret</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">小程序 appSecret</td></tr><tr><td align="left">js_code</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">登录时获取的 code</td></tr><tr><td align="left">grant_type</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">授权类型，此处只需填写 authorization_code</td></tr></tbody></table><p>返回值</p><p>Object</p><p>返回的 JSON 数据包</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">openid</td><td align="left">string</td><td align="left">用户唯一标识</td></tr><tr><td align="left">session_key</td><td align="left">string</td><td align="left">会话密钥</td></tr><tr><td align="left">unionid</td><td align="left">string</td><td align="left">用户在开放平台的唯一标识符，在满足 UnionID 下发条件的情况下会返回，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html">UnionID 机制说明</a>。</td></tr><tr><td align="left">errcode</td><td align="left">number</td><td align="left">错误码</td></tr><tr><td align="left">errmsg</td><td align="left">string</td><td align="left">错误信息</td></tr></tbody></table><p>errcode 的合法值</p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-1</td><td align="left">系统繁忙，此时请开发者稍候再试</td></tr><tr><td align="left">0</td><td align="left">请求成功</td></tr><tr><td align="left">40029</td><td align="left">code 无效</td></tr><tr><td align="left">45011</td><td align="left">频率限制，每个用户每分钟100次</td></tr></tbody></table><p><strong>二.信息授权wx.getUserInfo</strong></p><p>获取用户信息。</p><p>参数</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">withCredentials</td><td align="left">boolean</td><td align="left"></td><td align="left">否</td><td align="left">是否带上登录态信息。当 withCredentials 为 true 时，要求此前有调用过 wx.login 且登录态尚未过期，此时返回的数据会包含 encryptedData, iv 等敏感信息；当 withCredentials 为 false 时，不要求有登录态，返回的数据不包含 encryptedData, iv 等敏感信息。</td></tr><tr><td align="left">lang</td><td align="left">string</td><td align="left">en</td><td align="left">否</td><td align="left">显示用户信息的语言</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p>object.lang 的合法值</p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">en</td><td align="left">英文</td></tr><tr><td align="left">zh_CN</td><td align="left">简体中文</td></tr><tr><td align="left">zh_TW</td><td align="left">繁体中文</td></tr></tbody></table><p>object.success 回调函数</p><p>参数</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">userInfo</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/api/UserInfo.html">UserInfo</a></td><td align="left">用户信息对象，不包含 openid 等敏感信息</td></tr><tr><td align="left">rawData</td><td align="left">string</td><td align="left">不包括敏感信息的原始数据字符串，用于计算签名</td></tr><tr><td align="left">signature</td><td align="left">string</td><td align="left">使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html">用户数据的签名验证和加解密</a></td></tr><tr><td align="left">encryptedData</td><td align="left">string</td><td align="left">包括敏感数据在内的完整用户信息的加密数据，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95">用户数据的签名验证和加解密</a></td></tr><tr><td align="left">iv</td><td align="left">string</td><td align="left">加密算法的初始向量，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95">用户数据的签名验证和加解密</a></td></tr></tbody></table><p>注意:</p><p>1.小程序端获取授权信息要用button按钮触发</p><p>2.小程序端需要将 encryptedData, iv, login_key 传到后端用于解密</p><p><strong>案例:</strong></p><p>登录:</p><p>当小程序第一次执行的时候就调用wx.login</p><p>小程序端:apps.js</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">App({ onLaunch: function () { var _this=this // 登录 wx.login({  success: res =&gt; {  // 发送 res.code 到后台换取 openId, sessionKey, unionId  wx.request({   url: _this.globalData.Url+'/login/', // 后端路径   data:{"code":res.code}, // code   header:{"content-type":"application/json"},   method:"POST",   success:function(res){   console.log(res)   // 小程序端存储login_key   wx.setStorageSync("login_key",res.data.data.login_key)   }  })  } }) }, globalData: { Url:"http://127.0.0.1:8000", userInfo: null }})</code></pre><p>后端 django</p><pre class="language-none"><code class="language-none">wx ├── settings.py  # 小程序id,code2Session等配置 ├── wx_login.py  # 用于调用code2Session拿到openid等 └── WXBizDataCrypt.py # 获取用户授权信息的解密算法,官方下载</code></pre><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95">微信官方解密算法代码</a></p><p>项目/settings.py</p><pre class="language-python" data-language="python"><code class="language-python"># 配置数据库DATABASES = { 'default': {  'ENGINE': 'django.db.backends.mysql',  'NAME': 'wx',  'USER':'root',  'PASSWORD':'root',  'HOST':'127.0.0.1',  'PORT': 3306,  'OPTIONS': {'charset': 'utf8mb4'}, # 微信用户名可能有标签,所以用utf8mb4 }}# 配置 django-redisCACHES = { 'default': {  'BACKEND': 'django_redis.cache.RedisCache',  'LOCATION': 'redis://127.0.0.1:6379',  "OPTIONS": {   "CLIENT_CLASS": "django_redis.client.DefaultClient",    "PASSWORD": "",  }, },}</code></pre><p>wx/settings.py</p><pre class="language-python" data-language="python"><code class="language-python"># 小程序开发者idAppId="..."# 小程序的AppSecretAppSecret="..."code2Session="https://api.weixin.qq.com/sns/jscode2session?appid={}&amp;secret={}&amp;js_code={}&amp;grant_type=authorization_code"pay_mchid ='...'pay_apikey = '...'</code></pre><p>wx/wx_login.py</p><pre class="language-python" data-language="python"><code class="language-python">from app01.wx import settingsimport requests# 调用微信code2Session接口,换取用户唯一标识 OpenID 和 会话密钥 session_keydef login(code): response = requests.get(settings.code2Session.format(settings.AppId,settings.AppSecret,code)) data = response.json() if data.get("openid"):  return data else:  return False</code></pre><p>项目/views.py</p><pre class="language-python" data-language="python"><code class="language-python">from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom app01.wx import wx_loginfrom django.core.cache import cachefrom app01 import modelsimport time, hashlibclass Login(APIView): def post(self, request):  param = request.data  # 拿到小程序端提交的code  if param.get('code'):   # 调用微信code2Session接口,换取用户唯一标识 OpenID 和 会话密钥 session_key   data = wx_login.login(param.get('code'))   if data:    # 将openid 和 session_key拼接    val = data['openid'] + "&amp;" + data["session_key"]    key = data["openid"] + str(int(time.time()))    # 将 openid 加密    md5 = hashlib.md5()    md5.update(key.encode("utf-8"))    key = md5.hexdigest()    # 保存到redis内存库,因为小程序端后续需要认证的操作会需要频繁校验    cache.set(key, val)    has_user = models.Wxuser.objects.filter(openid=data['openid']).first()    # 用户不存在则创建用户    if not has_user:     models.Wxuser.objects.create(openid=data['openid'])    return Response({     "code": 200,     "msg": "ok",     "data": {"login_key": key} # 返回给小程序端    })   else:    return Response({"code": 401, "msg": "code无效"})  else:   return Response({"code": 401, "msg": "缺少参数"})</code></pre><p><strong>用户信息授权</strong></p><p>小程序端test.wxml</p><pre class="language-html" data-language="html"><code class="language-html">&lt;!--用户信息授权--&gt;&lt;button open-type="getUserInfo" bindgetuserinfo="info"&gt;授权登录&lt;/button&gt;</code></pre><p>test.js</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">Page({info: function (res) { // console.log(res) wx.checkSession({  success() {  //session_key 未过期，并且在本生命周期一直有效  wx.getUserInfo({   success: function (res) {   // console.log(res)   wx.request({    url: app.globalData.Url + "/getinfo/",    data: { "encryptedData": res.encryptedData, "iv": res.iv, "login_key": wx.getStorageSync("login_key") },    method: "POST",    header: { "content-type": "application/json" },    success: function (res) {    console.log(res)    }   })   }  })})</code></pre><p>后端 django</p><p>wx/WXBizDataCrypt.py</p><pre class="language-python" data-language="python"><code class="language-python">import base64import jsonfrom Crypto.Cipher import AESfrom app01.wx import settingsclass WXBizDataCrypt: def __init__(self, appId, sessionKey):  self.appId = appId  self.sessionKey = sessionKey def decrypt(self, encryptedData, iv):  # base64 decode  sessionKey = base64.b64decode(self.sessionKey)  encryptedData = base64.b64decode(encryptedData)  iv = base64.b64decode(iv)  cipher = AES.new(sessionKey, AES.MODE_CBC, iv)  decrypted = json.loads(self._unpad(cipher.decrypt(encryptedData)))  if decrypted['watermark']['appid'] != self.appId:   raise Exception('Invalid Buffer')  return decrypted def _unpad(self, s):  return s[:-ord(s[len(s)-1:])] @classmethod def getInfo(cls,encryptedData,iv,session_key):  return cls(settings.AppId,session_key).decrypt(encryptedData, iv)</code></pre><p>项目/serializer.py</p><pre class="language-python" data-language="python"><code class="language-python">from rest_framework.serializers import ModelSerializerfrom app01 import modelsclass User_ser(ModelSerializer): class Meta:  model=models.Wxuser  fields="__all__"</code></pre><p>项目/views.py</p><pre class="language-python" data-language="python"><code class="language-python">from app01.wx import WXBizDataCryptfrom app01 import serializerfrom app01 import modelsclass GetInfo(APIView): def post(self,request):  param=request.data  # 需要小程序端将 encryptedData iv login_key 的值传到后端  # encryptedData iv seesion_key 用于解密获取用户信息  # login_key 用于校验用户登录状态  if param['encryptedData'] and param['iv'] and param['login_key']:   # 从redis中拿到login_key并切分拿到 openid 和 session_key   openid,seesion_key=cache.get(param['login_key']).split("&amp;")   # 利用微信官方提供算法拿到用户的开放数据   data=WXBizDataCrypt.WXBizDataCrypt.getInfo(param['encryptedData'] ,param['iv'] ,seesion_key)   save_data={    "name":data['nickName'],    "avatar":data['avatarUrl'],    "language":data['language'],    "province":data['province'],    "city":data['city'],    "country":data['country'],   }   # 将拿到的用户信息更新到用户表中   models.Wxuser.objects.filter(openid=openid).update(**save_data)   # 反序列化用户对象,并返回到小程序端   data=models.Wxuser.objects.filter(openid=openid).first()   data=serializer.User_ser(instance=data,many=False).data   return Response({"code":200,"msg":"缺少参数","data":data})  else:   return Response({"code":200,"msg":"缺少参数"})</code></pre><p>到此，微信小程序实现后端授权登录就结束了</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uvicorn+Gunicorn部署</title>
      <link href="/posts/17778/"/>
      <url>/posts/17778/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是wsgi"><a href="#什么是wsgi" class="headerlink" title="什么是wsgi"></a>什么是wsgi</h2><blockquote><p>Wsgi是同步通信服务规范，客户端请求一项服务，并等待服务完成，只有当它收到服务的结果时，它才会继续工作。当然了，可以定义一个超时时间，如果服务在规定的时间内没有完成，则认为调用失败，调用方继续工作。</p></blockquote><img src="/posts/17778/image-20210120124037533.png" alt style="zoom:50%;" loading="lazy"><p>wsgi简单工作图</p><h2 id="什么是asgi"><a href="#什么是asgi" class="headerlink" title="什么是asgi"></a>什么是asgi</h2><p>Asgi是异步通信服务规范。客户端发起服务呼叫，但不等待结果。调用方立即继续其工作，并不关心结果。如果调用方对结果感兴趣，有一些机制可以让其随时被回调方法返回结果。</p><img src="/posts/17778/image-20210120124131615.png" alt style="zoom:75%;" loading="lazy"><p>简单总结一下：Asgi是异步的，Wsgi是同步的，而基于Wsgi的Flask是同步框架，基于Asgi的FastAPI是异步框架，就这么简单。</p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><blockquote><p>普及一下小知识，下面我们进入正题，什么是Uvicorn，Uvicorn 是基于 uvloop 和 httptools 构建的非常快速的 ASGI 服务器。目前，Python 仍缺乏异步网关协议接口，ASGI 的出现填补了这一空白，现在开始，我们能够使用共同的标准为所有的异步框架来实现一些工具，ASGI 帮助 Python 在 Web 框架上和 Node.Js 及 Golang 相竞争，目标是获得高性能的 IO 密集型任务，ASGI 支持 HTTP2 和 WebSockets，WSGI 是不支持的。</p></blockquote><h4 id="进程管理器"><a href="#进程管理器" class="headerlink" title="进程管理器"></a>进程管理器</h4><blockquote><p>使用进程管理器确保你以弹性方式运行运行多个进程，你可以执行服务器升级而不会丢弃客户端的请求。</p><p>一个进程管理器将会处理套接字设置，启动多个服务器进程，监控进程活动，监听进程重启、关闭等信号。</p><p>Uvicorn 提供一个轻量级的方法来运行多个工作进程，比如 <code>--workers 4</code>，但并没有提供进行的监控。</p></blockquote><p>Gunicorn 是成熟的，功能齐全的服务器，Uvicorn 内部包含有 Guicorn 的 workers 类，允许你运行 ASGI 应用程序，这些 workers 继承了所有 Uvicorn 高性能的特点，并且给你使用 Guicorn 来进行进程管理。</p><p>这样的话，你可能动态增加或减少进程数量，平滑地重启工作进程，或者升级服务器而无需停机。</p><p>在生产环境中，Guicorn 大概是最简单的方式来管理 Uvicorn 了，生产环境部署我推荐使用 Guicorn 和 Uvicorn</p><h2 id="简单部署fastapi"><a href="#简单部署fastapi" class="headerlink" title="简单部署fastapi"></a>简单部署fastapi</h2><pre class="language-python" data-language="python"><code class="language-python">from fastapi import FastAPIfrom fastapi.responses import RedirectResponseapp = FastAPI()@app.get("/items/")async def update_item(assetid:str):    print(assetid)    assetid = assetid.strip()    url = 'https://god_hearing.gitee.io/myhexo/?assetid=%s'%assetid    print(url)    return RedirectResponse(url=url)if __name__ == '__main__':    import uvicorn    uvicorn.run(        app='transfer:app',        host='0.0.0.0',        port=8000,        workers=5,        debug=False                )</code></pre><p>我们简单的写了一个接口，这里，我是使用了跳转重定向，可以直接return一个response</p><p>然后启动的这里，我们采用的是启动五个进程，并且关闭debug模式，不过我还没有发现这个debug关不关的区别在哪</p><p>这时候，我们直接运行即可。</p><p>但是，这样是阻塞式的，并且在关闭控制台之后就会停止，所以，我们使用gunicorn来解决</p><ol><li><p>安装</p><pre class="language-python" data-language="python"><code class="language-python">pip install gunicorn </code></pre></li><li><p>在项目文件下</p><pre class="language-python" data-language="python"><code class="language-python">gunicorn main:app -b 0.0.0.0:8000  -w 5 -k uvicorn.workers.UvicornH11Worker --daemon</code></pre></li></ol><p>然后，我们的项目就已经在运行了，然后访问一下你的域名+<code>items/assetid=asfdg</code></p><h3 id="关闭gunicron进程"><a href="#关闭gunicron进程" class="headerlink" title="关闭gunicron进程"></a>关闭gunicron进程</h3><pre class="language-python" data-language="python"><code class="language-python"># 查询pstree -ap|grep gunicorn</code></pre><p>结果为：</p><img src="/posts/17778/image-20210120134339197.png" alt style="zoom:67%;" loading="lazy"><p>关闭进程</p><pre class="language-python" data-language="python"><code class="language-python">kill -9 15624...</code></pre><p>ok，部署完成，就是这么简单</p>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> FastAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue生成图片并下载</title>
      <link href="/posts/22175/"/>
      <url>/posts/22175/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近，碰到了一个很尴尬的需求，在我使用python苦苦支撑却实现不了的时候，vue就像一道光，哗啦啦的就来了，这个需求就是合成一张图片，然后把这张图片下载下来，而python我又不会使用opencv等库，所以，只能使用PIL强行搞，但是效果并不好。然后，我求助了我的小伙伴，她很轻易的就帮助我搞定了，(太感谢我的小伙伴了。)，但是下载这个图片，成了一个事。所以，今天这篇攻略带来如何生成图片并且下载</p></blockquote><h2 id="html2canvas"><a href="#html2canvas" class="headerlink" title="html2canvas"></a>html2canvas</h2><blockquote><p>这就是我们要使用到的库，我们通过npm或者yarn来进行下载</p></blockquote><ol><li>安装</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript">npm install --save html2canvas</code></pre><p>或者：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">yarn add html2canvas</code></pre><ol start="2"><li>将html2canvas引入到组件中</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript">import html2canvas from "html2canvas"</code></pre><ol start="3"><li>将你想生成的区域转成图片，你需要让html2canvas获取到你想要转换的节点内容，因此，你需要添加ref标记。</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;div class="container" ref="imageDom"&gt;&lt;/div&gt;</code></pre><blockquote><p>imageDom需要是你想转换的页面内容的父容器，即你想转换的页面内容需要全部包含在imageDom节点内。</p></blockquote><ol start="4"><li>转换</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript">clickGeneratePicture(){      html2canvas(this.$refs.imageDom).then(canvas =&gt; {        // 转成图片，生成图片地址        this.imgUrl = canvas.toDataURL("image/png");        console.log(this.imgUrl)      });    },</code></pre><blockquote><p>返回的canvas参数就是一个生成好的canvas元素，如果你想将他转成图片，直接使用toDataURL方法即可，将转换的图片地址赋值给你想显示的图片元素，就可以在页面上看到转换后的图片。</p></blockquote><ol start="5"><li>直接触发方法， 将图片下载下来</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript">clickGeneratePicture(){    html2canvas(this.$refs.imageDom).then(canvas =&gt; {        // 转成图片，生成图片地址        this.imgUrl = canvas.toDataURL("image/png");        // 创建隐藏的可下载链接        var eleLink = document.createElement("a");        eleLink.href = this.imgUrl; // 转换后的图片地址        eleLink.download = "pictureName";        // 触发点击        document.body.appendChild(eleLink);        eleLink.click();        // 然后移除        document.body.removeChild(eleLink);    });},</code></pre><p>随便做个点击事件就好了，不过图片如果展示的过大的话，就会只下载显示的部分，还未解决，待补</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastAPI学习之路-3  模型与校验</title>
      <link href="/posts/22249/"/>
      <url>/posts/22249/</url>
      
        <content type="html"><![CDATA[<h2 id="预设值"><a href="#预设值" class="headerlink" title="预设值"></a>预设值</h2><blockquote><p>如果你有一个接收路径参数的路径操作，但你希望预先设定可能的有效参数值，则可以使用标准的 Python <code>Enum</code> 类型。</p><p>就类似于choise枚举，举个栗子，你现在可能要接收一个性别</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from enum import Enumclass ModelName(str, Enum):    nan = "男"    nv = "女"    lenet = "未知"@app.post("/Yawp/")async def transfer(model_name: ModelName):    return {'msg':model_name}</code></pre><p>这样，我们需要传的model_name，只剩下这三个选项</p><p>同时，他也可以声明路径参数</p><blockquote><p>补充关于参数的一点，如果你想要让这个参数是一个必填的参数，只需要将其不设置默认值即可，例如：</p><p><code>async def read_user_item(item_id: str, needy: str=None):</code></p><p>像这种情况，item_id，就是必须填进的一个参数了，而needy有默认值，None，所以，他并不是一个必填的参数</p></blockquote><p>另外一个小技巧，在fastapi交互式文档上操作，可以最大限度的避免一些基础错误，所以，要养成使用交互式文档的习惯哦</p><h2 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h2><blockquote><p>请求体就不用过多介绍了，这是基础中的基础了，如果不懂请自行百度</p><p>我们需要先导入BaseModel，来创建数据模型</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from pydantic import BaseModelclass Item(BaseModel):    name:str    description: Optional[str] = None    price:float    tax:Optional[float] = Noneasync def main(item:Item):    print(item.dict())    print(item.name)    return </code></pre><p>和声明查询参数时一样，当一个模型属性具有默认值时，它不是必需的。否则它是一个必需属性。将默认值设为 <code>None</code> 可使其成为可选属性。</p><p>我们可以在函数内通过某个字段来进行查看，或者直接dict，获取所有数据</p><p>值得说的一点是，请求体传值并不影响url传参，也就是说，我们依旧可以使用路径参数</p><p>函数参数将依次按如下规则进行识别：</p><ul><li>如果在<strong>路径</strong>中也声明了该参数，它将被用作路径参数。</li><li>如果参数属于<strong>单一类型</strong>（比如 <code>int</code>、<code>float</code>、<code>str</code>、<code>bool</code> 等）它将被解释为<strong>查询</strong>参数。</li><li>如果参数的类型被声明为一个 <strong>Pydantic 模型</strong>，它将被解释为<strong>请求体</strong>。</li></ul><p>如果你不想使用 Pydantic 模型，你还可以使用 <strong>Body</strong> 参数。稍后介绍</p><h2 id="约束校验"><a href="#约束校验" class="headerlink" title="约束校验"></a>约束校验</h2><p>Query(查询参数)<br>Query第一个参数用来定义默认值</p><blockquote><p>可用于限制长度或者正则表达式</p></blockquote><blockquote><p>#q参数必须为字符串，默认值为None，如果为…,则这个参数必须给值，最小长度3，最大长度50<br><code>async def reds(q:str = Query(None,min_length=3,max_length=50)</code></p><p><code>async def read_items(q: Optional[List[str]] = Query(None)):</code>这种情况，是可以接收多个q参数的，?q=foo&amp;q=bar</p></blockquote><h2 id="声明必须参数"><a href="#声明必须参数" class="headerlink" title="声明必须参数"></a>声明必须参数</h2><blockquote><p>之前说过，我们声明必须传的参数，只需要将其不设默认即可，现在可以有第二种方法，就是<code>...</code>，</p><p>将其默认值设置为<code>...</code>时，他就是一个必须传入的参数了</p></blockquote><h2 id="请求体字段验证"><a href="#请求体字段验证" class="headerlink" title="请求体字段验证"></a>请求体字段验证</h2><p>与使用 <code>Query</code>、<code>Path</code> 和 <code>Body</code> 在<em>路径操作函数</em>中声明额外的校验和元数据的方式相同，你可以使用 Pydantic 的 <code>Field</code> 在 Pydantic 模型内部声明校验和元数据。像这样</p><pre class="language-python" data-language="python"><code class="language-python">class Item(BaseModel):    name:str    description: Optional[str] = Field(None, title="The description of the item", max_length=300)    price:float    tax:Optional[float] = None</code></pre><h2 id="模型嵌套"><a href="#模型嵌套" class="headerlink" title="模型嵌套"></a>模型嵌套</h2><blockquote><p>在我们声明模型的时候，他的值不只是单一的字符串，数字等， 像一些列表，集合也同样可以定义，像这样</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">class Item(BaseModel):    name: str    description: Optional[str] = None    price: float    tax: Optional[float] = None    tags: list = []</code></pre><p>这将使 <code>tags</code> 成为一个由元素组成的列表。不过它没有声明每个元素的类型。</p><p>但是 Python 有一种特定的方法来声明具有子类型的列表。</p><p>我们需要从<code>typing</code>导入<code>List</code>，将模型内部改为<code>tags: List[str] = []</code></p><p>Pydantic 模型的每个属性都具有类型。</p><p>但是这个类型本身可以是另一个 Pydantic 模型。</p><p>因此，你可以声明拥有特定属性名称、类型和校验的深度嵌套的 JSON 对象。</p><p>上述这些都可以任意的嵌套。</p><blockquote><p>最后，有一点很重要，我们如果希望传一种像这样的数据:<code>[{a:1},{a:2}]</code>，则可以在路径操作函数的参数中声明此类型，就像声明 Pydantic 模型一样：<code>images: List[Image]</code></p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from pydantic import BaseModel,Field,HttpUrlclass img(BaseModel):    url:HttpUrl    name:str@app.post("/Yawp/")async def transfer(*,a:List[img]):    for i in a:        print(i.name)        print(i.url)    # for i in a:    #     print(i)    return {'msg':a}</code></pre>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序授权登录</title>
      <link href="/posts/33717/"/>
      <url>/posts/33717/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在开发小程序的过程中， 用户的认证是必不可少的，而微信又取消了小程序的自己认证，所以，我们只能通过微信进行授权登录，而如果将微信授权的信息录入到自己的表中，则需要做一点点的开发，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/">官方文档</a></p></blockquote><p>微信小程序的后端开发和普通的restful API 大致上相同，只不过要注意以下几点限制</p><ul><li>必须使用HTTPS协议请求后端服务器</li><li>不支持COOKIE</li><li>不支持django内置的user登录, 因为它使用的是微信的用户系统</li></ul><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><img src="/posts/33717/image-20210115133429492.png" alt style="zoom:70%;" loading="lazy"><blockquote><p>只获取<code>openid</code>，只调用<code>wx.login</code>获取code交给后台即可，如果还要获取用户详细信息还要接着调用<code>wx.getUserInfo</code>获取<code>encryptedData</code>，<code>iv</code>提交后台解密用户信息</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">@api_view(['GET','POST'])def wx_login(request):    openidUrl = 'https://api.weixin.qq.com/sns/jscode2session?'    code = request.GET['code']    res = requests.get(        url = openidUrl,        params = {            'appid':APPID,            'secret':APP_SECRET,            'js_code':code,            'grant_type':'authorization_code'        }    ).json()    openid = res['openid']    return Response(openid</code></pre><p>这样，我们便获取到了openid，然后返回给前端即可</p><p>如果要换取用户信息，则需要前端再次请求我们服务器，需要传入<code>encryptedData  iv</code>和<code>session_key</code>来获取用户的信息，</p><p><code>encryptedData</code>就是获取到的用户信息，只是得解密一下，通过iv</p><pre class="language-python" data-language="python"><code class="language-python">#  解密类class WXBizDataCrypt:    def __init__(self, appId, sessionKey):        self.appId = appId        self.sessionKey = sessionKey    def decrypt(self, encryptedData, iv):        # base64 decode        sessionKey = base64.b64decode(self.sessionKey)        encryptedData = base64.b64decode(encryptedData)        iv = base64.b64decode(iv)        cipher = AES.new(sessionKey, AES.MODE_CBC, iv)        decrypted = json.loads(self._unpad(cipher.decrypt(encryptedData)))        if decrypted['watermark']['appid'] != self.appId:            raise Exception('Invalid Buffer')        return decrypted    def _unpad(self, s):        return s[:-ord(s[len(s)-1:])]</code></pre><pre class="language-python" data-language="python"><code class="language-python">def main():    appId = '你的appid'    sessionKey = '获取到的sessionkey'    encryptedData = '获取openid那里的数据'    iv = '获取openid那里的数据'    pc = WXBizDataCrypt(appId, sessionKey)    res = pc.decrypt(encryptedData, iv)    print(res)</code></pre><p>res就是解密出来的内容，就是用户的信息</p><img src="/posts/33717/image-20210116220241505.png" alt style="zoom:67%;" loading="lazy"><p>至此，前台将openid存下，而后台，获取了用户信息，该入库还是该做怎样的操作，就可以自定义了，我是将其入库了，完整代码如下：</p><pre class="language-python" data-language="python"><code class="language-python">class Applets_RegisterView(APIView):    def post(self,request):        session_key = request.data.get('session_key')        encryptedData = request.data.get("encryptedData")        iv = request.data.get("iv")        pc = WXBizDataCrypt(APPID, session_key)        data = pc.decrypt(encryptedData, iv)        username = data['nickName']        avatar = data['avatarUrl']        gender = data['gender']        user_data = {            'username':username,            'avatar':avatar,            'gender':gender,        }        with transaction.atomic():            try:                userobj = RegisterSerializer(data=user_data)                if userobj.is_valid() and secretobj.is_valid():                    userobj.save()                    return Response({'code': 1000, 'msg': '注册成功'})                else:                    return Response({'code':1004,'msg':'网络错误，请稍后再试'})            except Exception as exc:                print(exc)                return Response({'code': 1004, 'msg': '网络错误，请稍后再试'})</code></pre><blockquote><p>被一个小小的登录绊倒，我也是没想到的，感谢有位大神孜孜不倦的一直给我讲解。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python获取微信公众号历史文章</title>
      <link href="/posts/34767/"/>
      <url>/posts/34767/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们经常能够在微信公众号上看到各种的文章，而如果我们需要保存到自己本地，难道还需要一个个去复制粘贴吗，答案，根本不需要，只需要一个小小的调用接口，即可将文章悉数拿到，也算一个小爬虫吧</p></blockquote><h2 id="获取assetoken"><a href="#获取assetoken" class="headerlink" title="获取assetoken"></a>获取assetoken</h2><blockquote><p>我们通过微信的<a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html">开发者平台</a>，可以看到，我们只需要调用一个接口，即可获取assettoken</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">def access_token():    appid = 'APPID'    secret = 'SECRET'    url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%s&amp;secret=%s'%(appid,secret)    res = requests.get(url=url)    res = json.loads(res.text)    return res['access_token']</code></pre><blockquote><p>appid和secret就不用细说了，获取这个是很简单的一件事，不仅仅是获取这个文章，调用任何微信公众号的接口，都需要先获取了这个asset_token</p></blockquote><h2 id="获取素材"><a href="#获取素材" class="headerlink" title="获取素材"></a>获取素材</h2><p>获取素材就非常的让我暴躁了，因为他的编码格式问题，让我头疼了好久，我们先来看一下这个官方的<a href="https://developers.weixin.qq.com/doc/offiaccount/Asset_Management/Get_materials_list.html">文档</a>,</p><p>需要三个参数，type，offset，count，我们要获取的是图文，所以，type使用news，offset和count就是从哪一个开始返回和返回的个数，不过需要注意的是，返回的个数最大值是20</p><pre class="language-python" data-language="python"><code class="language-python">token = access_token()    url = 'https://api.weixin.qq.com/cgi-bin/material/batchget_material?access_token=%s'%(token)    data = {    "type":'news',    "offset":1,    "count":1    }    data = json.dumps(data)    res = requests.post(url=url,data=data)    r = res.text.encode('ISO-8859-1').decode('utf8')    r = json.loads(r)</code></pre><blockquote><p>这里，我们接入他的接口，但是返回的是<code>ISO-8859-1</code>编码，所以我们需要进行解码</p><p>如何查看返回的编码，有一个小技巧，就是打印一下<code>res.encoding</code> 即可</p><p>由于这个编码的特殊性，我们需要先对其进行编码，在进行解码</p></blockquote><p>我们再根据他的数据格式，存入到我们的数据库</p><img src="/posts/34767/image-20210114151117113.png" alt style="zoom:50%;" loading="lazy"><p>完善代码</p><pre class="language-python" data-language="python"><code class="language-python">def obtain_article():    token = access_token()    url = 'https://api.weixin.qq.com/cgi-bin/material/batchget_material?access_token=%s'%(token)    data = {    "type":'news',    "offset":1,    "count":1    }    data = json.dumps(data)    res = requests.post(url=url,data=data)    r = res.text.encode('ISO-8859-1').decode('utf8')    r = json.loads(r)    conn = pymysql.connect(host='127.0.0.1',port=3306,user='root',password='mySQL',database='blue_lake_user',charset='utf8')    cursor = conn.cursor()    for i in range(len(r['item'])):        title = r['item'][i]['content']['news_item'][0]['title']        link = r['item'][i]['content']['news_item'][0]['url']        img_url = r['item'][i]['content']['news_item'][0]['thumb_url']        create_time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time()))        sql = "insert into article(title,img,link,create_time,status) values(%s,%s,%s,%s,'1')" % (conn.escape(title),conn.escape(img_url),conn.escape(link),conn.escape(create_time),)        cursor.execute(sql)        conn.commit()        conn.close()</code></pre><p>由于之前说过，数据过长的话，会导致错误，所以，我们采用了<code>escape</code>来进行处理</p><p>一个编码整半天，哎，心累</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提问的智慧(下)</title>
      <link href="/posts/17401/"/>
      <url>/posts/17401/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接上节，较长，请耐心观看</p><h3 id="低声下气不能代替你的功课"><a href="#低声下气不能代替你的功课" class="headerlink" title="低声下气不能代替你的功课"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="描述问题症状而非你的猜测"><a href="#描述问题症状而非你的猜测" class="headerlink" title="描述问题症状而非你的猜测"></a>描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p><h3 id="按发生时间先后列出问题症状"><a href="#按发生时间先后列出问题症状" class="headerlink" title="按发生时间先后列出问题症状"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， 但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id="别要求使用私人电邮回复"><a href="#别要求使用私人电邮回复" class="headerlink" title="别要求使用私人电邮回复"></a>别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p><h3 id="清楚明确的表达你的问题以及需求"><a href="#清楚明确的表达你的问题以及需求" class="headerlink" title="清楚明确的表达你的问题以及需求"></a>清楚明确的表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="询问有关代码的问题时"><a href="#询问有关代码的问题时" class="headerlink" title="询问有关代码的问题时"></a>询问有关代码的问题时</h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 ，但实际出现的是 </code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="别把自己家庭作业的问题贴上来"><a href="#别把自己家庭作业的问题贴上来" class="headerlink" title="别把自己家庭作业的问题贴上来"></a>别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p><h3 id="去掉无意义的提问句"><a href="#去掉无意义的提问句" class="headerlink" title="去掉无意义的提问句"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html">是或否类型的回答</a>。</p><h3 id="即使你很急也不要在标题写紧急"><a href="#即使你很急也不要在标题写紧急" class="headerlink" title="即使你很急也不要在标题写紧急"></a>即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id="礼多人不怪，而且有时还很有帮助"><a href="#礼多人不怪，而且有时还很有帮助" class="headerlink" title="礼多人不怪，而且有时还很有帮助"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h2><h3 id="RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM 和 STFW：如何知道你已完全搞砸了"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **<a href="http://lmgtfy.com/">Google 是你的朋友</a>**！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="如果还是搞不懂"><a href="#如果还是搞不懂" class="headerlink" title="如果还是搞不懂"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="处理无礼的回应"><a href="#处理无礼的回应" class="headerlink" title="处理无礼的回应"></a>处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id="如何避免扮演失败者"><a href="#如何避免扮演失败者" class="headerlink" title="如何避免扮演失败者"></a>如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 —— 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="不该问的问题"><a href="#不该问的问题" class="headerlink" title="不该问的问题"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q1">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q2">我怎样用 X 做 Y？</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q3">如何设定我的 shell 提示？</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q5">我的程序/设定/SQL 语句没有用</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q9">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p><hr><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="http://www.google.com/">Google</a> 吗？</p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#RTFM">RTFM</a>，然后自己去找出来。</p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p><blockquote><p>问题：我的{程序/设定/SQL 语句}不工作</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我屁事？</li></ul><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到使用者群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id="好问题与蠢问题"><a href="#好问题与蠢问题" class="headerlink" title="好问题与蠢问题"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#RTFM">STFW</a> 这样的回答。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong>聪明问题</strong>：</p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p><h2 id="如何更好地回答问题"><a href="#如何更好地回答问题" class="headerlink" title="如何更好地回答问题"></a>如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章真的给予了我很大的启发，也希望能够帮助到任何观看到这篇文章的人，<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提问的智慧(上)</title>
      <link href="/posts/54264/"/>
      <url>/posts/54264/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p><p>不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><h2 id="在提问之前"><a href="#在提问之前" class="headerlink" title="在提问之前"></a>在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（搜索 <a href="http://groups.google.com/">Google 论坛</a>和网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h2><h3 id="慎选提问的论坛"><a href="#慎选提问的论坛" class="headerlink" title="慎选提问的论坛"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 —— 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p><h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p><p>近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>Stack Exchange 已经成长到<a href="http://stackexchange.com/sites">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id="网站和-IRC-论坛"><a href="#网站和-IRC-论坛" class="headerlink" title="网站和 IRC 论坛"></a>网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id="第二步，使用项目邮件列表"><a href="#第二步，使用项目邮件列表" class="headerlink" title="第二步，使用项目邮件列表"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id="使用有意义且描述明确的标题"><a href="#使用有意义且描述明确的标题" class="headerlink" title="使用有意义且描述明确的标题"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p></blockquote><blockquote><p>聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p></blockquote><blockquote><p>更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id="使问题容易回复"><a href="#使问题容易回复" class="headerlink" title="使问题容易回复"></a>使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id="用清晰、正确、精准且语法正确的语句"><a href="#用清晰、正确、精准且语法正确的语句" class="headerlink" title="用清晰、正确、精准且语法正确的语句"></a>用清晰、正确、精准且语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it's</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox">Alan Cox</a> 也许可以这样做，但你不行）。</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E7%99%BD">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%96%87">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的： [译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法。</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me; I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请寄信/私讯给我；我需要有人协助我翻译我的问题。</li></ul><blockquote><p>I am familiar with the technical terms, but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English. I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li></ul><h3 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id="精确地描述问题并言之有物"><a href="#精确地描述问题并言之有物" class="headerlink" title="精确地描述问题并言之有物"></a>精确地描述问题并言之有物</h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="话不在多而在精"><a href="#话不在多而在精" class="headerlink" title="话不在多而在精"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。 第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加； 第二，简化问题使你更有可能得到<strong>有用</strong>的答案； 第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="别动辄声称找到-Bug"><a href="#别动辄声称找到-Bug" class="headerlink" title="别动辄声称找到 Bug"></a>别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><hr><p>未完待续….</p>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python使用RSA非对称加密</title>
      <link href="/posts/45949/"/>
      <url>/posts/45949/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。RSA就是他们三人姓氏开头字母拼在一起组成的。<br>RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><p>RSA算法的原理，目前网络上有许多优秀的文章，特别推荐阅读阮一峰老师的文章：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理1</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理2</a></li></ul><p>本文主要描述如何使用RSA来对文件进行不对称加密。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>crypto这个模块的安装比较特殊，可能会有点小坑，安装时需要注意。</p><p>crypto，pycrypto，pycryptodome的功能是一样的。crypto与pycrypto已经没有维护了，后面可以使用pycryptodome。</p><p>但是，三个名字，再分Linux和Windows操作系统，再分Python2和Python3，叠加起来就有12种情况了，非常复杂。</p><p>在 Windows 中，不管是 Python2 和 Python3 ，都不能用 crypto 和 pycrypto ，可以用 pycryptodome 。</p><p>在 Linux 中，不管是 Python2 和 Python3 ，都不能用 crypto ，可以用 pycrypto 和 pycryptodome 。</p><p>所以，总结一句话，直接都用 pycryptodome 就行了，(保证pip正常能用的情况下)安装命令如下：</p><pre class="language-none"><code class="language-none">pip install pycryptodome</code></pre><blockquote><p>安装之前，最好先把 crypto 和 pycrypto 卸载了(uninstall)，避免不必要的麻烦。</p></blockquote><h2 id="生成RSA公钥和私钥"><a href="#生成RSA公钥和私钥" class="headerlink" title="生成RSA公钥和私钥"></a>生成RSA公钥和私钥</h2><pre class="language-python" data-language="python"><code class="language-python">from Crypto import Randomfrom Crypto.PublicKey import RSAdef generate_Key():    random_generator = Random.new().read    rsa = RSA.generate(2048, random_generator)    private_key = rsa.exportKey()    # 写入私钥文件    with open('private_rsa_key.bin', 'wb') as f:        f.write(private_key)    public_key = rsa.publickey().exportKey()    # 写入公钥文件    with open('rsa_public.pem', 'wb') as f:        f.write(public_key)</code></pre><p>上面的代码中，生成了一对公钥和私钥。</p><p>导入了 RSA ，通过 RSA 的 generate() 方法实例化一个对象 rsa 。再通过 rsa 的 exportKey() 方法和 publickey() 方法生成公钥和私钥。</p><p>执行这个函数，可以看到，生成了一对公钥和私钥</p><blockquote><p>当然每次运行的结果都不一定，公钥是公开的，任何人都可以看到，但是私钥一定要保存好，否则一旦泄露，意味着你的信息也不安全了。</p></blockquote><h2 id="进行加密和解密"><a href="#进行加密和解密" class="headerlink" title="进行加密和解密"></a>进行加密和解密</h2><pre class="language-python" data-language="python"><code class="language-python">from Crypto import Randomfrom Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5 as PKCS1_cipherimport base64# 加密def encryption(keys):    with open('rsa_public.pem') as f:        key = f.read()        pub_key = RSA.importKey(str(key))        cipher = PKCS1_cipher.new(pub_key)        rsa_text = base64.b64encode(cipher.encrypt(bytes(keys.encode("utf8"))))        return rsa_text.decode('utf-8')# 解密def decrypt(keys):    with open('private_rsa_key.bin') as f:        key = f.read()        pri_key = RSA.importKey(key)        cipher = PKCS1_cipher.new(pri_key)        back_text = cipher.decrypt(base64.b64decode(keys),0)        return back_text.decode('utf-8')</code></pre><blockquote><p>上面的函数，我们将保存的公钥和私钥读出来，然后进行加密和解密的过程，不过千万要注意的是，私钥不要泄露。</p></blockquote><h2 id="签名和验签"><a href="#签名和验签" class="headerlink" title="签名和验签"></a>签名和验签</h2><blockquote><p>RSA还可以用来签名和验签，正好与加密相反的是，他是使用私钥来签名，公钥来验签</p><p>废话不多说，上代码</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from Crypto.PublicKey import RSAfrom Crypto.Hash import SHAimport base64from Crypto.Signature import PKCS1_v1_5 as PKCS1_signaturemessage = "需要加密的信息"# 使用私钥生成签名with open('private_rsa_key.bin') as f:    key = f.read()    pri_key = RSA.importKey(key)    signer = PKCS1_signature.new(pri_key)    digest = SHA.new()    digest.update(message.encode("utf8"))    sign = signer.sign(digest)    signature = base64.b64encode(sign)    print(signature.decode('utf-8'))# 使用公钥验证签名with open('rsa_public.pem') as f:    key = f.read()    pub_key = RSA.importKey(key)    verifier = PKCS1_signature.new(pub_key)    digest = SHA.new()    digest.update(message.encode("utf8"))    print(verifier.verify(digest, base64.b64decode(signature)))</code></pre><blockquote><p>继续使用之前写入文件中的私钥和公钥，使用私钥来生成信息的签名，然后使用公钥来验证签名。</p><p>生成签名时，使用 RSA 的 importKey() 方法对(从文件中读取的)私钥字符串进行处理，处理成可用的私钥用于生成签名。</p><p>从 Crypto.Signature 中导入 PKCS1_v1_5 ，重命名为 PKCS1_signature 。然后实例化一个签名对象 signer ，传入的参数是私钥，通过的 signer 的 sign() 方法对信息生成签名。</p><p>信息需要先转换成 sha 字符串，使用 Crypto.Hash 中的 SHA 来转换。生成的签名是字节串，为了显示得更友好，可以将结果转换成 base64 字符串。</p><p>验证签名时，使用 RSA 的 importKey() 方法对(从文件中读取的)公钥字符串进行处理，处理成可用的公钥用于验证签名。</p><p>实例化一个验证对象 verifier ，传入的参数是公钥，通过的 verifier 的 verify() 方法对签名进行验证。验证结果是一个布尔值，验证成功返回 True , 不成功返回 False 。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pymysql的坑以及django多个数据库迁移</title>
      <link href="/posts/28786/"/>
      <url>/posts/28786/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>今日有个爬虫的需求，就在我把各个组件都测试完毕，将他们自信的组装到一起，结果，除了意外，这个意外就是显示sql语句有错误，可是，在我反复的在终端试验，却没有任何的错误，于是我开始了漫长的资料查询。</p></blockquote><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><blockquote><p>pymysql在储存长文本，有时会出现转义字符，可能导致两个连续的数据会被挤到一起</p></blockquote><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>我研究了很多的解决办法，选出两种最为方便的</p></blockquote><ol><li><p>在连接时，将编码格式改为<code>utf8mb4</code></p></li><li><p>在需要转义的对象用<code>连接.escape(value)</code>方法转义</p><pre class="language-none"><code class="language-none">sql = "insert into article(title,img,link,create_time,status) values(%s,%s,%s,%s,'1')" % (conn.escape(title),conn.escape(img),conn.escape(link),conn.escape(create_time),)</code></pre></li></ol><h2 id="django多数据库的迁移"><a href="#django多数据库的迁移" class="headerlink" title="django多数据库的迁移"></a>django多数据库的迁移</h2><blockquote><p>首先，我们需要在settings中链接上多个数据库，并且指定app</p></blockquote><img src="/posts/28786/image-20201230181824302.png" alt style="zoom:50%;" loading="lazy"><p>然后指定哪个模型使用哪个数据库</p><pre class="language-python" data-language="python"><code class="language-python">DATABASE_APPS_MAPPING = {    # 'app_name':'database_name',    'user': 'user',}</code></pre><p>如果不想每个应用同步到特定数据库，可以定义 <a href="https://docs.djangoproject.com/zh-hans/3.1/topics/db/multi-db/#topics-db-multi-db-routing">database router</a> ，它实施限制特定模型可用性的策略。</p><p>在迁移时，生成迁移文件，命令不变</p><pre class="language-python" data-language="python"><code class="language-python">python manage.py makemigrations</code></pre><p>迁移时需要指定哪个app进行数据迁移</p><pre class="language-python" data-language="python"><code class="language-python">python manage.py migrate --database=user</code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维码与python</title>
      <link href="/posts/93509896/"/>
      <url>/posts/93509896/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在二维码泛滥无比的今天，我们作为开发者，怎样生成二维码可谓是基础了，今天带来一篇python生成二维码的攻略</p></blockquote><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h2 id="qrcode"><a href="#qrcode" class="headerlink" title="qrcode"></a><strong>qrcode</strong></h2><p>首先安装这个库</p><pre class="language-js" data-language="js"><code class="language-js">pip install qrcode</code></pre><p>这个库的GitHub地址也给大家，方便大家更进一步了解</p><pre class="language-js" data-language="js"><code class="language-js">https://github.com/lincolnloop/python-qrcode</code></pre><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a><strong>简单使用</strong></h3><p>用这个库来生成二维码，简直不要太简单了，只需一行代码！</p><pre class="language-js" data-language="js"><code class="language-js">img = qrcode.make(data="你好")</code></pre><p>当然我们还需要导入库以及保存为图片格式：</p><pre class="language-j" data-language="j"><code class="language-j">import qrcode# 生成二维码img = qrcode.make(data="昊烨向你问好")# 将二维码保存为图片with open('test.png', 'wb') as f:    img.save(f)</code></pre><p>运行一下代码，就可以看到生成了一张<code>test.png</code>的图片：</p><img src="/posts/93509896/image-20201224171159835.png" alt style="zoom:50%;" loading="lazy"><blockquote><p>当然你不仅仅能放文本在里面，你还能让它跳转链接，你只需要把data里的数据改为url即可。</p></blockquote><img src="/posts/93509896/image-20201224171310611.png" alt style="zoom:50%;" loading="lazy"><h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a><strong>高级使用</strong></h3><p>除了简单生成二维码外，我们还能够自定义一些属性。</p><pre class="language-js" data-language="js"><code class="language-js">import qrcodeqr = qrcode.QRCode(    version=20,    error_correction=qrcode.constants.ERROR_CORRECT_L,    box_size=10,    border=4,)qr.add_data('Some data')qr.make(fit=True)img = qr.make_image(fill_color="black", back_color="white")with open('test1.png', 'wb') as f:    img.save(f)</code></pre><p>可以看到，属性都在QRCode对象中设置，下面我来简单介绍一下上面的参数。</p><ol><li><code>version</code>：二维码大小，用1~40之间的整数来设置。最小的version=1，是一个21x21的矩阵。如果你想自动生成，将值设置为 None 并使用 fit=True 参数即可。</li><li><code>error_correction</code>: 二维码的纠错范围，可以选择4个常量：</li><li>ERROR_CORRECT_L 7%以下的错误会被纠正</li><li>ERROR_CORRECT_M (default) 15%以下的错误会被纠正</li><li>ERROR_CORRECT_Q 25 %以下的错误会被纠正</li><li>ERROR_CORRECT_H. 30%以下的错误会被纠正</li><li><code>box_size</code>：每一个点中的像素个数</li><li><code>border</code>：二维码距图像外围边框距离，默认为4，而且相关规定最小为4</li><li><code>fill_color</code>和<code>back_color</code>：可以更改QR的背景和绘画颜色。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seaweedfs</title>
      <link href="/posts/15028/"/>
      <url>/posts/15028/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p> <code>Saeweedfs</code>是一个由<code>golang</code>语言开发的分布式对象存储系统，很适合做图片服务器，性能很好，并且可兼容挂载提供路径访问的方式，使得文件储存在云端变得非常方便。</p></blockquote><p><code>seaweedfs</code>的特点： </p><ol><li>可以成存储上亿的文件（根据你硬盘大小变化） </li><li>速度刚刚的</li></ol><p><a href="https://github.com/chrislusf/seaweedfs">github地址</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装呢，需要从官网上下载对应系统的版本，<a href="https://github.com/chrislusf/seaweedfs/releases">地址</a>，我以windows为例，可以看到，下载下来的是个压缩包，解压后就是一个exe安装包，但是我们直接点是没有用的，所以，我们通过命令来进行</p><p>首先呢，我们查看一下所有的命令，得知，可以使用master命令来进行启动</p><pre class="language-python" data-language="python"><code class="language-python">weed master -ip=127.0.0.1</code></pre><img src="/posts/15028/image-20201222171848122.png" alt style="zoom:50%;" loading="lazy"><p>master节点设置好了之后，继续看文档，来设置volume节点</p><blockquote><p>如果没有data这个文件夹，就自己创建一个</p><p><code>mserver</code>是master节点地址</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">weed volume -dir="./data" -max=10 -mserver="127.0.0.1:9333" -port=9000 -index=leveldb</code></pre><img src="/posts/15028/image-20201222172215662.png" alt style="zoom:50%;" loading="lazy"><p>然后访问一下<code>http://localhost:9333/</code>即可，好，一切ok，再查看一下状态</p><pre class="language-python" data-language="python"><code class="language-python">"http://127.0.0.1:9333/cluster/status?pretty=y"</code></pre><img src="/posts/15028/image-20201222172408636.png" alt style="zoom:50%;" loading="lazy"><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>继续看文档，如果要写入文件，则需要发送请求到<code>/dir/assign</code>来获取<code>fid</code>和volume服务器url</p><img src="/posts/15028/image-20201222173140239.png" alt style="zoom:50%;" loading="lazy"><p>然后将fid拼接，发送文件，这里用postman测试一下</p><img src="/posts/15028/image-20201222175621056.png" alt style="zoom:50%;" loading="lazy"><p>发送成功，这时候你可以将<code>fid</code>存下</p><blockquote><p><code>fid</code>：</p><p>开头的数字3表示卷ID。逗号后是一个文件密钥01和一个文件<code>cookie 637037d6</code>。</p><p>卷ID是32位无符号整数。文件密钥是一个无符号的64位整数。文件cookie是32位无符号整数，用于防止URL猜测。</p><p>文件密钥和文件cookie均以十六进制编码。可以使用自己的格式存储&lt;卷ID，文件密钥，文件cookie&gt;元组，也可以将<code>fid</code>存储。</p></blockquote><p>然后，怎么访问呢，当然是通过刚刚保存的fid啦，不过要<strong>注意</strong>，一定要先查找卷服务器的url，<code>http://localhost:9333/dir/lookup?volumeId=卷ID</code>，然后通过返回的<code>publicUrl</code>这个域名来进行查找</p><img src="/posts/15028/image-20201222180246784.png" alt style="zoom:50%;" loading="lazy"><p>要注意，这时，不只是可以用这个方式来访问，还可以使用</p><pre class="language-none"><code class="language-none"># 卷id/密钥+文件cookie/文件名http://localhost:8080/3/01637037d6/my_preferred_name.jpg# 卷id/密钥+文件你cookie.后缀名http://localhost:8080/3/01637037d6.jpg还有其他方法，不一一列举啦http://localhost:8080/3,01637037d6.jpghttp://localhost:8080/3/01637037d6http://localhost:8080/3,01637037d6</code></pre><p>如果要获取图像的缩放版本，则可以添加一些参数：</p><pre class="language-none"><code class="language-none">http://localhost:8080/3/01637037d6.jpg?height=200&amp;width=200http://localhost:8080/3/01637037d6.jpg?height=200&amp;width=200&amp;mode=fithttp://localhost:8080/3/01637037d6.jpg?height=200&amp;width=200&amp;mode=fill</code></pre><p>要更新，请发送另一个具有更新文件内容的POST请求，就是fid不变的情况下，再发一个新的文件，它就会自动给覆盖掉</p><p>删除的话，直接发送delete请求到相同的地址，删除成功会给你返回一个size，文件不存在的话这个size的值为0</p><p>何谓分布式，当然是可以分布啦，它本身提供了机架感知和数据中心感知复制，SeaweedFS在卷级别应用复制策略。因此，在获取文件ID时，可以指定复制策略。例如：</p><pre class="language-none"><code class="language-none">curl http://localhost:9333/dir/assign?replication=001</code></pre><p>复制参数选项包括：</p><pre class="language-none"><code class="language-none">000:无复制001:在同一机架上复制一次010:在不同机架上复制一次，但数据中心相同100:在不同的数据中心复制一次200:在两个不同的数据中心复制两次110:在不同的机架上复制一次，在不同的数据中心复制一次</code></pre><p>还可以在启动主服务器时设置默认复制策略。额..暂时没有搞，稍后补</p><h2 id="python中使用seaweedfs"><a href="#python中使用seaweedfs" class="headerlink" title="python中使用seaweedfs"></a>python中使用seaweedfs</h2><blockquote><p>我们如果要在python中使用这个seaweedfs，则需要先安装一个包<code>pip install pyseaweed</code></p></blockquote><p>使用的方法，非常的简单，在GitHub上，作者也给写的相当明白了</p><pre class="language-python" data-language="python"><code class="language-python">from pyseaweed import WeedFS# File uploadw = WeedFS("localhost", 9333) # weed-fs master address and portfid = w.upload_file("n.txt") # path to file# Get file urlfile_url = w.get_file_url(fid)# Delete fileres = w.delete_file(fid)# res is boolean (True if file was deleted)</code></pre><p>我们简单的封装一下</p><pre class="language-python" data-language="python"><code class="language-python">from pyseaweed import WeedFS# 上传文件def upload_file(seaweed_address,file,name):    w = WeedFS(*seaweed_address)    fid = w.upload_file(stream=file,name=name)    if fid:        return fid    else:        return False## 查看文件的域名def get_file_url(seaweed_address, fid):    w = WeedFS(*seaweed_address)    file_url = w.get_file_url(fid)    if file_url:        return file_url    else:        return '该资源不存在'def del_file(seaweed_address,fid):    w = WeedFS(*seaweed_address)    res = w.delete_file(fid)    return res  # True or False</code></pre><blockquote><p>这里为什么要指定stream和name呢，这是因为如果传一个参数，就必须是文件的路径，如果不传文件路径，就只能将他的数据流和名字传进来。</p></blockquote><p>我们使用视图来测试一下吧,<code>seaweed_address</code>是我自己配置的一个地址，这个可以写死，也可以写成元组，然后像我这样使用</p><pre class="language-python" data-language="python"><code class="language-python">class avatar_upload(APIView):    def post(self,request):        avatar = request.FILES.get('avatar')        # 调用文件存储系统，将返回的fid存下        for chunk in avatar.chunks():            fid = upload.upload_file(USER_AVATAR,chunk,avatar.name)            print(fid)            return Response({})</code></pre><p>ok，完美，不过需要注意的是，在本地是没法测的，我也在找这个问题，服务器上是没有问题</p>]]></content>
      
      
      <categories>
          
          <category> 文件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bigchaindb安装</title>
      <link href="/posts/14822/"/>
      <url>/posts/14822/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在很久没有更新博客以及自己技术的前提下，感受到了来自编程界的毒打，接受新事物，本是开发者应该作为本能的一件事，但实际上，我并没有坚持多久，很拒绝的接受新事物，所以，今日起，重铸开发荣光，我辈义不容辞。</p><p>今天带来的是<code>BigChainDB</code>，这是一个可用的<strong>去中心</strong>数据库，听到这个词，是不是意识到另一样某个同样是去中心的东西，是的，区块链。</p><p><code>BigChainDB</code>是一个区块链数据库，它具有每秒百万次写操作，储存PB级别的数据和亚秒级响应时间的性能。<code>BigChainDB</code>的设计起始于分布式数据库，通过创新加入了很多区块链的特性，像区中心控制、不可改变性、数字资产的创建和移动。</p><p><code>BigChainDB</code>继承了现代分布式数据库的特性：吞吐量和容量都是与节点数量线性相关，功能齐全的NoSQL查询语言，高效的查询和权限管理。因为构建在已有的分布式数据库上，它在代码层面也继承了企业级的健壮性。可扩展的容量意味着具有法律效力的合同和认证可以直接存储在区块链数据库里。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>安装我采用的是docker</p></blockquote><p>在安装了docker的前提下，直接拉取镜像</p><pre class="language-none"><code class="language-none">docker pull  bigchaindb/bigchaindb:all-in-one</code></pre><p>大概有300M左右，可以执行命令启动一下</p><pre class="language-none"><code class="language-none">docker run -it -d -p 9984:9984 镜像id</code></pre><p>访问一下9984，可以看到你的版本号</p><img src="/posts/14822/image-20201220154358244.png" alt style="zoom:67%;" loading="lazy"><p>安装一些依赖</p><pre class="language-none"><code class="language-none">sudo apt-get updatesudo apt-get install libffi-devpip install --upgrade setuptoolspip3 install pytest-runner</code></pre><p>然后安装驱动，对应你的版本号</p><img src="/posts/14822/image-20201220154540628.png" alt style="zoom:67%;" loading="lazy"><pre class="language-none"><code class="language-none">pip install -U bigchaindb-driver==版本号</code></pre><p>不过，可能会找不到这个包啊这些错误，没关系，我们直接去github上拉取他源码<code>git clone https://github.com/bigchaindb/bigchaindb-driver.git</code></p><p>然后进入这个文件夹，执行<code>python setup.py install</code>，强行给他装上，不只是这个包，任何包都可以通过这个办法来进行安装</p><p>之后，在docker内重新启动服务，命令为：</p><pre class="language-none"><code class="language-none">$ docker run \  --detach \  --name bigchaindb \  --publish 9984:9984 \  --publish 9985:9985 \  --publish 27017:27017 \  --publish 26657:26657 \  --volume $HOME/bigchaindb_docker/mongodb/data/db:/data/db \  --volume $HOME/bigchaindb_docker/mongodb/data/configdb:/data/configdb \  --volume $HOME/bigchaindb_docker/tendermint:/tendermint \  bigchaindb/bigchaindb:all-in-one</code></pre><blockquote><p>含义为：</p><ul><li><p><code>docker run</code> 告诉Docker运行一些映像</p></li><li><p><code>--detach</code> 在后台运行容器</p></li><li><pre><code>publish 9984:9984 将主机端口映射9984到容器端口9984<pre class="language-none"><code class="language-none">   （BigchainDB API服务器）  - `9985` BigchainDB Websocket服务器  - `27017` MongoDB的默认端口  - `26657` Tendermint RPC服务器- ```  --volume "$HOME/bigchaindb_docker/mongodb:/data"</code></pre>将主机目录映射 <pre class="language-none"><code class="language-none">$HOME/bigchaindb_docker/mongodb</code></pre>到容器目录<pre class="language-none"><code class="language-none">/data</code></pre>; 这使我们能够将数据持久保存在主机上，您可以在[官方Docker文档中](https://docs.docker.com/engine/tutorials/dockervolumes)阅读更多内容- `$HOME/bigchaindb_docker/tendermint:/tendermint` 保留Tendermint数据。</code></pre></li><li><p><code>bigchaindb/bigchaindb:all-in-one</code>要使用的图像。容器名称之后的所有选项都将传递到容器内部的入口点。</p></li></ul></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>官方文档可以说是非常详细了，我们从创建开始</p></blockquote><pre class="language-python" data-language="python"><code class="language-python"># 创建用户的密钥与公钥alice, bob = generate_keypair(), generate_keypair()# 链接def conn():    bdb = BigchainDB('http://127.0.0.1:9984')    return bdb# 创建一个链接bdb = conn()# 构造交易数据bicycle_asset = {    'data': {        'bicycle': {            'serial_number': 'abcd1234',            'manufacturer': 'bkfab'        },    },}# 元数据bicycle_asset_metadata = {    'planet': 'earth'}# 准备交易(operation是操作，create代表创建，singners是公钥，创建出来供谁拥有，asset是交易的东西，metadata是元数据)prepared_creation_tx = bdb.transactions.prepare(    operation='CREATE',    signers=alice.public_key,    asset=bicycle_asset,    metadata=bicycle_asset_metadata)# 通过私钥签名来完成交易(拥有者的私钥来进行交易签名)fulfilled_creation_tx = bdb.transactions.fulfill(    prepared_creation_tx,    private_keys=alice.private_key)# 发送到bigchaindb节点sent_creation_tx = bdb.transactions.send_commit(fulfilled_creation_tx)# 完成创建txid = fulfilled_creation_tx['id']</code></pre><p>这样，我们就创建好了一个可交易的资产</p>]]></content>
      
      
      <categories>
          
          <category> bigchaindb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> bigchaindb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobaXterm操作prometheus和grafana搭建监控预警</title>
      <link href="/posts/59705/"/>
      <url>/posts/59705/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>MobalXterm又名MobalXVT，是一款增强型终端，X服务器和Unix命令集工具箱，可以用它来连接服务器</p></blockquote><p><strong>MobaXterm主要功能：</strong></p><ul><li>支持各种连接 SSH，X11，RDP，VNC，FTP，MOSH</li><li>支持 Unix 命令(bash，ls，cat，sed，grep，awk，rsync，…)</li><li>连接 SSH 终端后支持 SFTP 传输文件</li><li>各种丰富的插件(git/dig/aria2…)</li><li>可运行 Windows 或软件</li></ul><h2 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h2><p><a href="https://mobaxterm.mobatek.net/">官网地址</a>，安装过程不再阐述，解压会比较慢，后续就正常了</p><p>然后打开，连接服务器</p><img src="/posts/59705/image-20201207170236919.png" alt style="zoom:80%;" loading="lazy"><ul><li>先点击session，连接设置可以按需选择，这里我用了SSH，输入你服务器的公网IP即可</li></ul><img src="/posts/59705/image-20201207170459123.png" alt style="zoom:67%;" loading="lazy"><ul><li>然后登录，就可以进入你的服务器内</li></ul><img src="/posts/59705/image-20201207170844756.png" alt style="zoom:67%;" loading="lazy"><p>左边是主机文件，右边是操作台，也就是终端勾选左下角的 <code>Follow terminal folder</code>可以让两个的工作路径保持一致。</p><blockquote><p>文件传输和下载，可以采用直接拖拽的方式，或者采用鼠标右键选择相应功能。</p><p>但是，有一个问题，就是编码，编码问题是一个难以看出的问题，基本上，一些根本找不出错误的代码，一运行就出错，这就有可能是编码的问题，今天我在服务器上修改docker容器内的配置文件，但是由于想偷个懒，在主机上将配置文件拖出来，然后修改完再挂载回去，可是呢，报了一个及其恶心的错误</p></blockquote><pre class="language-none"><code class="language-none">level=error ts=2018-12-07T07:16:42.642Z caller=main.go:808 err="error loading config from \"/etc/prometheus/prometheus.yml\": one or more errors occurred while applying the new configuration (--config.file=\"/etc/prometheus/prometheus.yml\")"</code></pre><p>这个呢，找了很久也没有找到问题，最后灵机一动，是不是编码有问题，然后又转头回来整编码，结果还是没用，没办法，只能使用服务器里唯一的一个神一样的编辑器<strong>VIM</strong>，来进行一个字一个字的敲，最后神奇的是，问题解决了</p><p>虽然呢，编码都是<code>utf8</code>，但是，总有些说不上来的错误，反正呢，乖乖的用内部的<strong>VIM</strong>，一点问题没有。</p><p>还有一点是，在使用MobaXerm中的vim时，在修改文件的时候，经常会遇到<code>readonly option is set （add！to override）</code>这样的错误，解决办法也非常简单，如果是root权限，可以直接<code>:wq!</code>，或者按下ESC，输入<code>set noreadonly</code>，然后就正常保存就可以了</p><p>在服务器上部署，用docker是很方便的，我之前也有过几篇攻略，虽然可能说的很磕磕绊绊，但是还是希望能帮到大家。</p><h2 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h2><p><code>Prometheus</code>，是自动化运维领域很常用的软件，它中文名为普罗米修斯，它的作用就是监控告警</p><p>话不多说，路程还长，首先是安装问题，安装呢，我们在MobalXterm的终端中，使用docker来进行安装</p><pre class="language-python" data-language="python"><code class="language-python">#升级yumsudo yum update#卸载旧版本dockersudo yum remove docker  docker-common docker-selinux docker-engine#安装依赖sudo yum install -y yum-utils device-mapper-persistent-data lvm2#设置源sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposudo yum makecache fast#安装dockersudo yum install docker-ce#启动服务sudo systemctl start docker</code></pre><p>安装成功后查看版本:</p><pre class="language-python" data-language="python"><code class="language-python">docker -v</code></pre><p>显示版本号即为成功</p><p>然后可以换国内源来提升下载速度</p><pre class="language-python" data-language="python"><code class="language-python">1.先执行sudo vim /etc/docker/daemon.json2.添加如下代码{    "registry-mirrors": ["https://d7grpode.mirror.aliyuncs.com"]}</code></pre><p>重启docker</p><pre class="language-python" data-language="python"><code class="language-python">sudo systemctl restart docker</code></pre><p>随后拉取普罗米修斯的镜像</p><pre class="language-python" data-language="python"><code class="language-python">docker pull prom/prometheus:latest</code></pre><p>这里我们以监控Redis数据库为例子，所以还需要拉取redis和redis状态收集器两个镜像：</p><pre class="language-python" data-language="python"><code class="language-python">docker pull redisdocker pull oliver006/redis_exporter:latest</code></pre><p>然后启动一下</p><pre class="language-python" data-language="python"><code class="language-python">docker run -d --name redis -p 6379:6379 redis    docker run -d --name redis_exporter -p 9121:9121 oliver006/redis_exporter:latest --redis.addr redis://公网ip:6379</code></pre><p>随后创建普罗米修斯的配置文件</p><pre class="language-none"><code class="language-none"># 执行这条命令vim /tmp/prometheus.yml# 加入下面代码scrape_configs:  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.  - job_name: 'redis'     # Override the global default and scrape targets from this job every 5 seconds.    scrape_interval: 5s    static_configs:      - targets: ['公网ip:9121']</code></pre><p>这里每隔5秒获取一下运行的信息，然后启动</p><pre class="language-python" data-language="python"><code class="language-python">docker run -d -p 9090:9090 -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus:latest</code></pre><p>然后可以访问一下<code>http://公网ip:9090/targets</code></p><p>然后，我们新创建一个机器人</p><img src="/posts/59705/image-20201207190120623.png" alt style="zoom:50%;" loading="lazy"><p>需要注意的是，要将公网ip写上</p><img src="/posts/59705/image-20201207190245136.png" alt style="zoom:50%;" loading="lazy"><p>然后再拉取一个告警模块以及顶顶机器人的插件</p><p>如果普罗米修斯的告警模块检测到异常，就会通过钉钉机器人的webhook的地址发送消息</p><p>编写告警配置文件</p><pre class="language-none"><code class="language-none">global:  resolve_timeout: 5mroute:  receiver: webhook  group_wait: 30s  group_interval: 5m  repeat_interval: 5m  group_by: [alertname]  routes:  - receiver: webhook    group_wait: 10sreceivers:- name: webhook  webhook_configs:  - url: http://公网ip:8060/dingtalk/webhook1/send    send_resolved: true</code></pre><p>编写警告规则</p><pre class="language-none"><code class="language-none"># 运行这条命令vim /tmp/redis.rules# 添加代码groups:- name: redis  rules:  - alert: redis    expr: up{job="redis"} == 0    for: 15s    labels:      severity: 1      team: node    annotations:      summary: "Redis服务在您的帮助下已经成功死机，老板限你一小时之内把它救回来。"</code></pre><p>修改普罗米修斯的配置文件，将告警设置配置好</p><pre class="language-none"><code class="language-none"># 执行这条命令vim /tmp/prometheus.yml# 追加这些代码alerting:  alertmanagers:  - static_configs:    - targets:      - 公网ip:9093rule_files:  - "/etc/prometheus/redis.rules"</code></pre><p>重启普罗米修斯服务，我们需要再次挂载一个redis.rules。</p><pre class="language-none"><code class="language-none">docker run -d -p 9090:9090 -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml -v /tmp/redis.rules:/etc/prometheus/redis.rules  prom/prometheus:latest</code></pre><p>启动告警模块</p><pre class="language-none"><code class="language-none">docker run -d --name alertmanager -p 9093:9093 -v /tmp/alertmanager.yml:/etc/alertmanager/alertmanager.yml prom/alertmanager:latest</code></pre><p>启动钉钉插件</p><pre class="language-none"><code class="language-none">docker run -d -p 8060:8060 --name webhook timonwong/prometheus-webhook-dingtalk --ding.profile="webhook1=https://oapi.dingtalk.com/robot/send?access_token=钉钉token"</code></pre><p>然后访问一下<code>http://公网ip:9090/rules</code></p><img src="/posts/59705/MobaXterm操作prometheus和grafana搭建监控预警\image-20201207192642565.png" alt style="zoom:80%;" loading="lazy"><p>然后我们关闭<code>redis_exporter</code>，来模拟redis宕机</p><pre class="language-none"><code class="language-none">docker stop redis_exporter</code></pre><p>普罗米修斯的监控立刻就发现了问题</p><img src="/posts/59705/image-20201207192944667.png" alt style="zoom:67%;" loading="lazy"><p>然后可以看到，机器人会发送一个消息</p><img src="/posts/59705/image-20201207193106577.png" alt style="zoom:50%;" loading="lazy"><p>ok，完毕</p><h2 id="Grafana可视化界面"><a href="#Grafana可视化界面" class="headerlink" title="Grafana可视化界面"></a>Grafana可视化界面</h2><p>这是一个很酷炫的可视化界面，可以将我们的监控界面导入到里面，隔壁小孩崇拜的很</p><p>首先拉取镜像：</p><pre class="language-none"><code class="language-none">sudo docker pull grafana/grafana</code></pre><p>然后启动</p><pre class="language-none"><code class="language-none">sudo docker run -d -p 3000:3000 --name grafana grafana/grafana</code></pre><ul><li>登录<code>http://公网ip:3000</code></li><li>默认账号和密码都是admin</li></ul><img src="/posts/59705/image-20201207194652625.png" alt style="zoom:50%;" loading="lazy"><img src="/posts/59705/image-20201207194725114.png" alt style="zoom:50%;" loading="lazy"><p>写入公网IP和端口</p><img src="/posts/59705/image-20201207194844677.png" alt style="zoom:50%;" loading="lazy"><img src="/posts/59705/image-20201207195444512.png" alt style="zoom:50%;" loading="lazy"><p>ok完美，莫得问题</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> MobaXerm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu系统下安装mysql8.0以及Django与mysql交互的问题</title>
      <link href="/posts/49687/"/>
      <url>/posts/49687/</url>
      
        <content type="html"><![CDATA[<h2 id="Django-运行时出错总结"><a href="#Django-运行时出错总结" class="headerlink" title="Django 运行时出错总结"></a>Django 运行时出错总结</h2><h4 id="一、利用mysql作为数据库时，会报的错："><a href="#一、利用mysql作为数据库时，会报的错：" class="headerlink" title="一、利用mysql作为数据库时，会报的错："></a>一、利用mysql作为数据库时，会报的错：</h4><pre class="language-none"><code class="language-none">#macospip install Django             #version==3.1pip install PyMySQL        #Pure Python MySQL Driver version==0.10.0brew install mysqlpip install mysqlclient  # version==2.0.1</code></pre><p>直接运行会报错:</p><pre class="language-none"><code class="language-none">version_info, _mysql.version_info, _mysql.__file__ NameError: name '_mysql' is not defined</code></pre><p>原因：Django连接MySQL时默认使用MySQLdb驱动，但MySQLdb不支持Python3，因此这里将MySQL驱动设置为pymysql</p><p>解决方法：需要在Django项目的<code>__init__.py</code>文件添加以下</p><pre class="language-none"><code class="language-none">import pymysqlpymysql.install_as_MySQLdb()</code></pre><p>此时，仍会报错：</p><pre class="language-none"><code class="language-none">'mysqlclient 1.4.0 or newer is required; you have 0.10.0.'</code></pre><p>是因为将MySQL驱动设置为pymysql，MySQLdb的版本为0.10.0，所以不够，但实际上不影响使用。因此将报错的位置注释掉就可以了。</p><p>出错文件在：<code>/Users/xinzipanghuang/Anaconda/anaconda3/lib/python3.7/site-packages/django/db/backends/mysql/base.py</code></p><p>注释掉这几句:</p><pre class="language-none"><code class="language-none">if version &lt; (1, 4, 0):  raise ImproperlyConfigured('mysqlclient 1.4.0 or newer is required; you have %s.' % Database.__version__)</code></pre><p>即可。</p><h4 id="二、运行时可能出现的问题"><a href="#二、运行时可能出现的问题" class="headerlink" title="二、运行时可能出现的问题"></a>二、运行时可能出现的问题</h4><p>1、<code>python manage.py runserver</code>，打开时产生的链接会报错：</p><pre class="language-none"><code class="language-none">You're accessing the development server over HTTPS, but it only supports HTTP.</code></pre><p>浏览器会出现：<code>This site can’t provide a secure connection</code></p><p>解决方法：<br><code>setting.py</code>中<code>INSTALLED_APPS</code>添加<code>'sslserver'</code>;<br>运行命令改为:<code>python manage.py runsslserver</code></p><p>2、pycharm可以新建一个Django项目，做个小APP改动几个地方就可以。</p><p>新建<code>views.py</code>在app目录下，定义返回函数（html内容）<br>同时在<code>templates</code>目录下，添加返回的html。<br>修改<code>urls.py</code>中<code>urlpatterns</code>,添加刚加入的<code>views.py</code>函数</p><p>3、css和js路径设置问题</p><p>Django静态style文件会放在<code>static</code>文件夹下，需要在<code>setting.py</code>中添加：</p><pre class="language-none"><code class="language-none">STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static/')]</code></pre><p>html文件也需要相对应改为<code>/static/***.css</code></p><h2 id="ubuntu升级mysql"><a href="#ubuntu升级mysql" class="headerlink" title="ubuntu升级mysql"></a>ubuntu升级mysql</h2><h3 id="1-升级前的检查准备"><a href="#1-升级前的检查准备" class="headerlink" title="1 升级前的检查准备"></a>1 升级前的检查准备</h3><p>在终端运行命令：</p><pre class="language-none"><code class="language-none">mysqlcheck -u root -p --all-databases --check-upgrade</code></pre><p>返回结果如果全部都是OK, 就表示检查没问题，进入下一步。如果有错误，看这里：<a href="https://dev.mysql.com/doc/refman/8.0/en/upgrade-prerequisites.html">https://dev.mysql.com/doc/refman/8.0/en/upgrade-prerequisites.html</a></p><h3 id="2-备份"><a href="#2-备份" class="headerlink" title="2 备份"></a>2 备份</h3><p><strong>备份数据库</strong><br>之前都没有使用过备份数据库，参考的这个命令：</p><pre class="language-none"><code class="language-none">mkdir mysql-backupcd mysql-backupmysqldump --all-databases --single-transaction --quick --lock-tables=false &gt; full-backup-$(date +%F).sql -u root -p</code></pre><p>该命令各个参数解释：</p><p>–all-databases ： 表示导出全部数据库</p><p>–single-transaction ： 这个不太懂，网上的解释也没看明白，需要补充补充数据库基础了。。</p><p>–quick ： 导出时不会将数据加载到缓存，而是直接输出。默认就是启用状态。可以使用–skip-quick 取消该选项。</p><p>–lock-tables：开始导出前，锁定所有表。当导出多个数据库时，–lock-tables分别为每个数据库锁定表。</p><p>$(date+%F)表示获取当前时间，在Linux Shell中：</p><pre class="language-none"><code class="language-none">date       //获取时间2019年 08月 08日 星期四 11:40:20 CSTdate +%F   //获取日期2019-08-08date +%s   //获取时间戳1565235736</code></pre><p>–user, –u指定连接的用户名</p><p>–password, –p连接数据库密码</p><p><strong>备份MySQL设置</strong></p><pre class="language-none"><code class="language-none">cd mysql-backupsudo tar zcvf mysql_config.tar.gz /etc/mysql/</code></pre><h3 id="3-添加MySQL-APT"><a href="#3-添加MySQL-APT" class="headerlink" title="3 添加MySQL APT"></a>3 添加MySQL APT</h3><p>下载mysql-apt-config_0.8.13-1_all.deb：<a href="https://dev.mysql.com/downloads/repo/apt/">https://dev.mysql.com/downloads/repo/apt/</a></p><p>安装：</p><pre class="language-none"><code class="language-none">sudo dpkg -i mysql-apt-config_0.8.13-1_all.debsudo apt-get update</code></pre><h3 id="4-安装新版的MySQL"><a href="#4-安装新版的MySQL" class="headerlink" title="4 安装新版的MySQL"></a>4 安装新版的MySQL</h3><pre class="language-none"><code class="language-none">service mysql stop  # 先停了MySQL servicesudo apt-get install mysql-serversudo service mysql start  # 开启MySQL service</code></pre><p>最后检查下升级后的版本：</p><pre class="language-none"><code class="language-none">mysql -V</code></pre><p>显示：</p><pre class="language-none"><code class="language-none">mysql  Ver 8.0.17 for Linux on x86_64 (MySQL Community Server - GPL)</code></pre><p>已经升级成功。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgrelSQL</title>
      <link href="/posts/21188/"/>
      <url>/posts/21188/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>自从mysql被oracle收购以后，PostgrelSQL逐渐成为开源关系型数据库的首选。并且就算mysql没有被收购，它所暴露出的问题也很难让人不追求新的数据库</p><p>比如，Emoji表情坑随后推出这个utfmb4</p><p>与时俱进之下，我们不采用普通的安装方式，而使用Docker来进行安装使用</p></blockquote><h2 id="Docker安装PostgrelSQL"><a href="#Docker安装PostgrelSQL" class="headerlink" title="Docker安装PostgrelSQL"></a>Docker安装PostgrelSQL</h2><p>第一步，拉取镜像</p><pre class="language-python" data-language="python"><code class="language-python">docker pull postgres:11.1</code></pre><p>然后，启动</p><pre class="language-python" data-language="python"><code class="language-python">docker run -d --name dev-postgres -e POSTGRES_PASSWORD=root -p 6432:5432 postgres:11.1</code></pre><blockquote><p>这里的<code>POSTGRES_PASSWORD</code>是PostgrelSQL的用户密码，自己制定一个就可以了。</p></blockquote><p>进入命令行操作一下</p><pre class="language-python" data-language="python"><code class="language-python">docker exec -it dev-postgres bashpsql -h localhost -U postgres</code></pre><p>这样就进入了容器内部的命令行</p><p>下面来介绍一下PostgrelSQL的一些命令</p><h2 id="PostgrelSQL命令"><a href="#PostgrelSQL命令" class="headerlink" title="PostgrelSQL命令"></a>PostgrelSQL命令</h2><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><p>建立数据库</p><pre class="language-python" data-language="python"><code class="language-python">create database 库名</code></pre><p>使用数据库</p><pre class="language-none"><code class="language-none">\c 库名</code></pre><p>查看所有数据库</p><pre class="language-none"><code class="language-none">\l</code></pre><p>查看所有数据库，并且展示详细信息</p><pre class="language-none"><code class="language-none">\l+</code></pre><p>删除数据库</p><pre class="language-none"><code class="language-none">drop database 库名</code></pre><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><p>创建表</p><pre class="language-none"><code class="language-none">create table 表名(字段 类型 属性)例子：create table empsal(id int4 not null,name varchar(20) not null,primary key(id))with(oids=FALSE);</code></pre><blockquote><p><code>primary key</code>代表的是主键，和其他的关系型数据库一致，不过，他可以建立一个或者多个主键，</p></blockquote><p>查看所有表</p><pre class="language-none"><code class="language-none">\d</code></pre><p>删除表</p><pre class="language-none"><code class="language-none">drop table 表名</code></pre><p>更新表结构</p><pre class="language-none"><code class="language-none">alter table 表名 add 字段名 类型 属性;例子：alter table article add email varchar(40);</code></pre><p>查看表结构</p><pre class="language-none"><code class="language-none">\d 表名</code></pre><h4 id="PostgreSQL-模式（schema）"><a href="#PostgreSQL-模式（schema）" class="headerlink" title="PostgreSQL 模式（schema）"></a>PostgreSQL 模式（schema）</h4><blockquote><p>PostgreSQL 模式（SCHEMA）可以看着是一个表的集合。一个模式可以包含视图、索引、数据类型、函数和操作符等。相同的对象名称可以被用于不同的模式中而不会出现冲突，例如 schema1 和 myschema 都可以包含名为 mytable 的表。</p></blockquote><p>使用模式的优势：</p><ul><li>允许多个用户使用一个数据库并且不会互相干扰。</li><li>将数据库对象组织成逻辑组以便更容易管理。</li><li>第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突。</li></ul><blockquote><p>模式类似于操作系统层的目录，但是模式不能嵌套。</p></blockquote><p>创建模式</p><pre class="language-none"><code class="language-none">create schema myschema;</code></pre><p>在指定模式里创建表，如：</p><pre class="language-none"><code class="language-none">CREATE TABLE myschema.user (...);</code></pre><p>删除一个空的schema，如：</p><pre class="language-none"><code class="language-none">drop schema myschema;</code></pre><p>删除一个模式以及模式里面所有的对象，如：</p><pre class="language-none"><code class="language-none">drop schema myschema CASCADE;</code></pre><p>在创建表时，如果没有指定schema，则会自动被归属到一个叫做<code>public</code>的模式中，也就是公共的。</p><p>所以，我们创建表时，这两种创建方式是一样的效果。</p><pre class="language-none"><code class="language-none">create table tablename();create table public.tablename();</code></pre><h3 id="模式权限的更改"><a href="#模式权限的更改" class="headerlink" title="模式权限的更改"></a>模式权限的更改</h3><blockquote><p>缺省时，用户看不到模式中不属于他们所有的对象。为了让他们看得见，模式的所有者需要在模式上赋予 USAGE 权限。为了让用户使用模式中的对象，我们可能需要赋予额外的权限， 只要是适合该对象的。<br> 用户也可以允许在别人的模式里创建对象。要允许这么做， 我们需要赋予在该模式上的 CREATE 权限。 请注意，缺省时，每个人都在 public 模式上 有 CREATE 权限。这样就允许所有可以连接到 指定数据库上的用户在这里创建对象。如果你不允许这么做， 你可以撤销这个权限：</p></blockquote><pre class="language-none"><code class="language-none">REVOKE create on schema public from PUBLIC;</code></pre><p>我们可以通过GRANT和REVOKE命令来分别的添加或撤销模式中的相应权限。这条命令中，我们移除了public模式中的CREATE权限。注意，我们使用了两个public，分别为一个大写和一个小写。小写的public指的是模式，实际使用中可以被替换为数据库中其他任意有效的模式名。<br>而大写的PUBLIC是一个特殊的关键字，代表了all users。实际使用中可以被替换为一个特定的角色名或者以逗号分隔的角色名列表。<br>使用<code>\dn+</code>命令查询修改后的权限，发现权限信息中第二行里的C权限已经被移除，证明之前的REVOKE命令是有效的。现在，除了postgres用户以外的用户将不再能在public模式中创建表、视图或其他对象。</p><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><p>插入数据</p><pre class="language-none"><code class="language-none">insert into 表名 values(对应数据)也可以根据字段来进行添加insert into 表名(字段名) values(对应数据)</code></pre><blockquote><p>这里要提一点，如果想使用可视化工具来操作PostgrelSQL的话，(例如navicat)，无法像mysql一样手动设置属性自增长，而是使用序列的形式来实现自增长</p></blockquote><p>创建序列</p><pre class="language-none"><code class="language-none">create sequence serial start 1这句话的意思是，创建一个名为serial的序列，从1开始计数</code></pre><p>查看结构</p><img src="/posts/21188/image-20201203105005032.png" alt style="zoom:67%;" loading="lazy"><p>随后，将需要设置的字段的默认值设为序列增长即可</p><pre class="language-none"><code class="language-none">alter table 表名 alter column 要自增长的字段 set default nextval(序列名)例子：ALTER TABLE "public"."article" ALTER COLUMN "id" SET DEFAULT nextval('serial');</code></pre><img src="/posts/21188/image-20201203105601012.png" alt style="zoom:50%;" loading="lazy"><p>删除数据</p><pre class="language-none"><code class="language-none">delete from 表名 where 条件例子：delete from user where name='李四'</code></pre><p>更新数据</p><pre class="language-none"><code class="language-none">update 表名 set 修改后的字段对应的数据 where 条件例子：update user set name='张三' where name='李四'</code></pre><h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><blockquote><p>聚合函数相信大家都用过，像sum、min、avg等，一般是和group by搭配使用，窗口函数和聚合函数类似，也是计算一些行集合的数据，和常规的聚合函数不同的是，窗口函数不会将参与计算的行合并成一行输出，而是将计算出来的结果带回到了计算行上。</p></blockquote><p>注意，<strong>窗口函数必须和over字句搭配使用</strong>，over字句包含<code>partition by</code>和<code>order by</code>两部分，分别用来分组和确定组内输出顺序，他们都是可选的</p><p>如果两个都省略，整个表会被作为一个分组</p><p>我们来举个例子吧，假设我们有一张表，分别有部门，员工，工资三个字段</p><p>假设我们要查询每个部门的平均工资以及所有员工的对比，在传统做法下，我们需要先通过group by分组，再用表连接统计一下上面的结果</p><p>而使用窗口函数，可以简化很多</p><img src="/posts/21188/image-20201203113052844.png" alt style="zoom:67%;" loading="lazy"><p>而使用<code>order by</code>的话，会造成怎样的结果呢</p><img src="/posts/21188/image-20201203113136091.png" alt style="zoom:67%;" loading="lazy"><p>可以看到，第一个是人事部门的平均工资，第二个，是研发和人事的平均工资，第三个，就是所有部门的平均工资。使用的时候要特别注意。</p><h2 id="python使用PostgrelSQL"><a href="#python使用PostgrelSQL" class="headerlink" title="python使用PostgrelSQL"></a>python使用PostgrelSQL</h2><p>和使用mysql一样，先装三方库</p><pre class="language-none"><code class="language-none">pip3 isntall psycopg2</code></pre><p>然后和mysql一样使用</p><pre class="language-python" data-language="python"><code class="language-python">import psycopg2.extrasconn = psycopg2.connect(host='localhost', port=6432, user='postgres', password='root', database='mytest')cursor = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)cursor.execute('SELECT * FROM empsal;')result = cursor.fetchone()print(result)</code></pre><p>ok，完成</p>]]></content>
      
      
      <categories>
          
          <category> PostgrelSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgrelSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket</title>
      <link href="/posts/26563/"/>
      <url>/posts/26563/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是websocket"><a href="#1-什么是websocket" class="headerlink" title="1.什么是websocket"></a>1.什么是<code>websocket</code></h2><blockquote><p><code>websocket</code>是<code>HTML5</code>出的协议，和HTTP协议没有什么关系，它的目的在于，在浏览器和服务器之间建立一个不受限制的双向实时通信的通道，比如服务器可以任意时刻向浏览器主动的推送消息</p><p> 它基于TCP，先通过HTTP/<code>HTTPS</code>协议发起一条特殊的HTTP请求进行握手后创建一个用于交换数据的TCP连接</p><p>他们是并行的关系</p></blockquote><p>HTTP和<code>WebScoket</code>的区别</p><ul><li>HTTP不支持常久的连接(长连接\循环连接等不算)</li><li><code>WebScket</code>和服务器只要一次握手动作，HTTP协议每次链接都需要三次握手才能发送消息</li><li>服务器和浏览器都可以在任意时刻相互的推送消息，HTTP的缺点就在于此，浏览器不主动请求，服务器就没法给浏览器发送数据</li><li>HTTP协议每次请求都要发送请求头，<code>websocket</code>一旦建立连接，之后请求都不用发送请求头</li></ul><blockquote><p>虽然HTTP可以用轮询或者comet机制实现<code>WebSocket</code>的功能，但是，每次轮询，就算是再快，也需要间隔时间，这样就造成了它的实时性不够，而且， 频繁的发送请求，会给服务器造成很大的压力，一般情况下，没人会这么做</p></blockquote><ul><li>轮询：<code>js</code>启动定时发送请求，间隔性的请求服务器是否有新的数据</li><li>comet：请求没有超过预定时间或者没有返回数据，一直保持连接状态，等有了数据再进行推送</li></ul><blockquote><p>comet虽然是实时性够了，但是，长时间挂起线程，会浪费服务器的资源，如果长时间没有数据，链路上的任何一个网关都可能关闭这个链接。</p><p>所以，会造成两个后果，要么，你不知道什么时候断开了，要么，你就定期发ping，检查连接是否正常</p></blockquote><h2 id="2-什么是三次握手，四次挥手"><a href="#2-什么是三次握手，四次挥手" class="headerlink" title="2.什么是三次握手，四次挥手"></a>2.什么是三次握手，四次挥手</h2><p>这是基于TCP协议的规则，建立TCP需要三次握手才能建立，而断开连接则需要四次挥手</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一次握手，客户端发送一个待SYN表之的TCP报文到服务器</p><p>第二次握手，服务器回应客户端，发送一个带有SYN和<code>ACK</code>标志的报文，表示它对客户端SYN报文的回应，同时询问客户端是否准备好进行数据通讯</p><p>第三次握手，客户端必须再次回应服务器一个<code>ACK</code>报文</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>第一次挥手，客户端发送一个FIN，用来关闭客户到服务器的数据传送</p><p>第二次挥手，服务器收到这个FIN，它发回一个<code>ACK</code>，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</p><p>第三次挥手，服务器关闭客户端的连接，发送一个FIN给客户端</p><p>第四次挥手，客户段发回<code>ACK</code>报文确认，并将确认序号设置为收到序号加1</p><blockquote><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p></blockquote><h2 id="3-WebSocket的使用"><a href="#3-WebSocket的使用" class="headerlink" title="3.WebSocket的使用"></a>3.<code>WebSocket</code>的使用</h2><p>1.首先需要一个<code>dwebsocket</code>依赖，安装非常简单，直接<code>pip install dwebsocket</code></p><p>2.在<code>settings</code>中需要注册加载，<code>INSTALLED_APPS</code>注册<code>dwebsocket</code></p><blockquote><p><code>dwebsocket</code>在<code>django3.1</code>之后自动加载，在这之前，都需要进行注册这一步骤</p></blockquote><p>3.导包<code>from dwebsocket.decorators import accept_websocket</code></p><p>4.写一个视图函数，需要用**<code>@accept_websocket</code>**，这样，声明了他是一个<code>webscoket</code>连接，这只是链接，不是发送消息，这里，定义了一个公共字典clients，一会儿要用，记住它</p><pre class="language-python" data-language="python"><code class="language-python">clients = {{@accept_websocketdef websocketlink(request):    if request.is_websocket():userid = uuid.uuid1()        while True:            message = request.websocket.wait()            if not message:                break            else:                clients[userid] = request.websocket</code></pre><blockquote><p><code>dwebsocket</code>有两种装饰器：<code>require_websocket</code>和<code>accept_websocekt</code><br>使用<code>require_websocket</code>装饰器会导致视图函数无法接收导致正常的<code>http</code>请求，一般情况使用<code>accept_websocket</code>方式就可以了</p></blockquote><p>5.在前端，发送一个连接，<strong>注意</strong>，此时后端的链接不是<code>http</code>，而是<code>ws</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">// websocket连接if('WebSocket' in window){    //  生成websocket链接    var ws = new WebSocket('ws://127.0.0.1:8000/websocketlink/');    // 发送链接        ws.onopen = function(){            ws.send('你好啊世界');        {    // 发送消息    ws.onmessage=(evt)=&gt;{        // 将获取信息打印        var received_msg = evt.data;                this.$notification.open({                message:received_msg            {)        ws.onclose = function(){            console.log('链接已关闭')        {    {</code></pre><p>6.推送消息接口，一个函数视图举例：</p><pre class="language-python" data-language="python"><code class="language-python">def sendmessage(request):# 获取消息    msg = request.GET.get('msg')    # 循环公共字典clients，遍历内部所有的链接，    for client in clients:        clients['client'].send(msg.encode('utf-8'))    return HttpResponse({'message':"ok"{)</code></pre><p>然后，链接成功后，再新打开一个页面，访问这个<code>sendmessage</code>方法，就可以在你的前端页面看到你发送的数据啦</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerhub部署Centos+Nginx+gunicorn+django独立架构</title>
      <link href="/posts/43087/"/>
      <url>/posts/43087/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在win10简单的使用Docker打包那纯属玩蛇，真正的部署还是要在Centos，这里为什么要用gunicorn呢，因为uwsgi还要编写配置文件，比较麻烦，所以我偷个懒使用gunicorn，日后有时间再讲解uwsgi</p><p>Nginx呢，就好像一层缓冲墙，使用Nginx来反向代理，就相当于用户不能直接访问服务器，而是先访问Nginx，由Nginx来负责分发。</p><p>Nginx的默认策略就是轮询，按照顺序发送，如果服务器要横向扩展，按照顺序一个个的发送，如果服务器配置高低不一，可以将策略改为加权。根据服务器的配置来设置阈值，增加容灾性。</p></blockquote><h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><ul><li><p>首先呢，就是将项目打包，具体流程不再赘述了，请观阅拙作：Docker部署Django项目</p></li><li><p>然后，注册Dockerhub，类似gitee和github的仓库：[地址][<a href="https://hub.docker.com/]">https://hub.docker.com/]</a></p></li></ul><img src="/posts/43087/image-20201204215728237.png" alt style="zoom:67%;" loading="lazy"><ul><li>创建仓库</li></ul><img src="/posts/43087/image-20201204215832694.png" alt style="zoom:50%;" loading="lazy"><ul><li>然后呢，我们需要对本地的镜像名重命名</li></ul><pre class="language-python" data-language="python"><code class="language-python">docker tag 本地镜像名 仓库拥有者/仓库名例如：docker tag mydjango godhearing/mydjango</code></pre><ul><li>之后在命令行输入命令</li></ul><pre class="language-none"><code class="language-none">docker login</code></pre><ul><li>使用dockerhub的账号密码登录</li></ul><img src="/posts/43087/image-20201204220231612.png" alt style="zoom:50%;" loading="lazy"><blockquote><p>这里我是登录过了，输入账号密码后出来这个就是登录成功了</p></blockquote><ul><li><p>然后将本地镜像上传到dockerhub中</p><pre class="language-python" data-language="python"><code class="language-python">docker push godhearing/mydjango</code></pre></li><li><p>然后登录你的云服务器，然后安装docker服务</p><pre class="language-python" data-language="python"><code class="language-python">#升级yumsudo yum update#卸载旧版本dockersudo yum remove docker  docker-common docker-selinux docker-engine#安装依赖sudo yum install -y yum-utils device-mapper-persistent-data lvm2#设置源sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposudo yum makecache fast#安装dockersudo yum install docker-ce#启动服务sudo systemctl start docker</code></pre></li><li><p>安装完成后键入 <code>docker -v</code></p><blockquote><p>如果出来版本号就说明没有问题</p></blockquote><p>然后从dockerhub把镜像拉下来</p><img src="/posts/43087/image-20201204220900919.png" alt style="zoom:67%;" loading="lazy"></li><li><p>采用后台守护进程模式起服务</p><pre class="language-python" data-language="python"><code class="language-python">sudo docker run -d -p 8000:8000 --name 自定义镜像名 镜像名例如：sudo docker run -d -p 8000:8000 --name testdjango godhearing/mydjango</code></pre><img src="/posts/43087/image-20201204221251956.png" alt style="zoom:67%;" loading="lazy"><p>可以使用<code>docker ps</code>来查看是否运行成功</p></li><li><p>然后访问一下</p><img src="/posts/43087/image-20201204221517697.png" alt style="zoom:50%;" loading="lazy"><p>ok，没有问题，额。。。也不能叫没有问题，因为我的mysql是本地的，没有更改，不过也还可以啦，总之，项目呢，是部署的没有问题了。不要在意这些细节</p></li><li><p>然后呢，我们安装Nginx服务</p><pre class="language-python" data-language="python"><code class="language-python">docker pull nginx</code></pre></li><li><p>然后启动</p><pre class="language-python" data-language="python"><code class="language-python">docker run -d -p 80:80 nginx</code></pre><img src="/posts/43087/image-20201204221944665.png" alt style="zoom:50%;" loading="lazy"></li><li><p>现在，我们将运行Nginx容器里的配置文件copy到宿主机里面(拉到本地)</p><pre class="language-python" data-language="python"><code class="language-python">docker cp 容器id:/etc/nginx/conf.d/default.conf /root/default.conf</code></pre></li><li><p>复制出来之后，输入命令修改这个nginx配置</p><pre class="language-python" data-language="python"><code class="language-python">vim /root/default.conf</code></pre></li><li><p>将Gunicorn配置加到里面</p><pre class="language-none"><code class="language-none">server {    listen       80;    server_name  localhost;    #charset koi8-r;    #access_log  /var/log/nginx/host.access.log  main;     location / {        proxy_pass http://你的服务器公网ip:5000; # 这里是指向 gunicorn host 的服务地址        proxy_set_header Host $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    }    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   /usr/share/nginx/html;    }}</code></pre></li><li><p>修改完配置文件之后，关掉运行的nginx服务容器，并且删掉它</p><pre class="language-none"><code class="language-none">docker stop 容器iddocker rm $(docker ps -a -q)</code></pre></li><li><p>然后再次启动nginx，通过-v来进行挂载，就是将宿主机的文件替换Docker容器内部的文件，达到修改的效果</p><pre class="language-python" data-language="python"><code class="language-python">docker run --name mynginx -d -p 80:80 -v /root/default.conf:/etc/nginx/conf.d/default.conf nginx</code></pre></li><li><p>重新启动成功后，访问服务器ip即可</p></li></ul><p>ok完毕，比原始命令行shell安装不知快了多少倍</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-compons搭建redis集群-哨兵模式</title>
      <link href="/posts/1307/"/>
      <url>/posts/1307/</url>
      
        <content type="html"><![CDATA[<h2 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h2><blockquote><p>Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施。</p><p>它有几个好处：</p><ul><li>高性能，集群的性能和单节点的性能是同一个级别，并不会降低</li><li>高可用，在使用集群承担高负载的同时，也能进行高可用的容灾机制</li><li>易扩展，向集群添加新的节点，或者移除节点，都是透明化操作，不需要停机</li><li>原生，不需要其他代理或工具，和单机redis几乎完全兼容</li></ul></blockquote><h2 id="何为哨兵模式"><a href="#何为哨兵模式" class="headerlink" title="何为哨兵模式"></a>何为哨兵模式</h2><blockquote><p>哨兵模式，是监控redis集群状态的工具，就好像一个监控器，监控着主从服务器是否健康，是redis的高可用性解决方案，当某个主服务器宕机时，它会选举出一个最优的从服务器来充当主服务器，这样，用户体验不会改变</p><p>需要注意的是，虽然哨兵模式支持创建多个，但是一般建议采取奇数台，道理很简单，假如选举的两个从服务器票数一样，就会使场面瞬间尬住，主从间的切换有可能会崩掉</p><p>还有一点是，哨兵也不是不会出错的，如果哨兵出错，没有下一个哨兵出战，那么程序有可能会出错</p></blockquote><h2 id="使用docker创建镜像"><a href="#使用docker创建镜像" class="headerlink" title="使用docker创建镜像"></a>使用docker创建镜像</h2><ol><li><p>建一个文件夹，进入项目文件夹，再建一个专门存放哨兵的脚本sentinel，cd  sentinel</p></li><li><p>建立sentinel.conf配置文件</p><pre class="language-none"><code class="language-none">sentinel monitor mymaster redis-master 6379 2sentinel down-after-milliseconds mymaster 5000sentinel parallel-syncs mymaster 1sentinel failover-timeout mymaster 5000</code></pre><blockquote><p>该配置的意思是，监控主服务器的6379端口并启动两个实例，如果5秒内没有收到主节点的心跳，则哨兵就认为主节点宕机了，默认是30秒，如果5秒以上连接不上主库同步，则在5秒后进行选举，对其他从服务器进行角色转换</p></blockquote></li><li><p>建立sentinel-entypoint.sh脚本</p><pre class="language-none"><code class="language-none">#!/bin/shsed -i "s/$SENTINEL_QUORUM/$SENTINEL_QUORUM/g" /etc/redis/sentinel.confsed -i "s/$SENTINEL_DOWN_AFTER/$SENTINEL_DOWN_AFTER/g" /etc/redis/sentinel.confsed -i "s/$SENTINEL_FAILOVER/$SENTINEL_FAILOVER/g" /etc/redis/sentinel.confexec docker-entrypoint.sh redis-server /etc/redis/sentinel.conf --sentinel</code></pre><blockquote><p>该脚本文件会对配置文件进行同步，用来启动哨兵</p></blockquote></li><li><p>建立Dockerfile指定基础镜像，同时拷贝配置文件到镜像内部</p><pre class="language-none"><code class="language-none">FROM redisEXPOSE 26379ADD sentinel.conf /etc/redis/sentinel.confRUN chown redis:redis /etc/redis/sentinel.confCOPY sentinel-entrypoint.sh /usr/local/bin/RUN chmod +x /usr/local/bin/sentinel-entrypoint.shENTRYPOINT ["sentinel-entrypoint.sh"]</code></pre></li><li><p>最后退到项目的根目录，建<code>docker-compose.yml</code>配置文件</p><pre class="language-none"><code class="language-none">master:  image: redis  ports:    - "6379:6379"slave1:  image: redis  command: redis-server --slaveof redis-master 6379  links:    - master:redis-master  ports:    - "6380:6379"slave2:  image: redis  command: redis-server --slaveof redis-master 6379  links:    - master:redis-master  ports:    - "6381:6379"sentinel1:  build: sentinel  environment:    - SENTINEL_DOWN_AFTER=5000    - SENTINEL_FAILOVER=5000      links:    - master:redis-master    - slave1sentinel2:  build: sentinel  environment:    - SENTINEL_DOWN_AFTER=5000    - SENTINEL_FAILOVER=5000      links:    - master:redis-master    - slave2</code></pre><blockquote><p> 意思是，我们起三台redis服务，分别跑在6379,6380,6381 ，一主两从，并且有两个哨兵实例来监控他们</p></blockquote><img src="/posts/1307/wwww.png" alt=" " style="zoom:90%;" loading="lazy"></li><li><p>在项目根目录下，启动服务：</p><pre class="language-python" data-language="python"><code class="language-python">docker-compose up --force-recreate# 如果希望在后台运行可以加-d参数</code></pre></li><li><p>测试一下，打开三个终端，分别进入redis-cli -p 6379，6380，6381<br>在主服务器6379下，添加一个数据，然后分别get</p></li><li><p>测试哨兵<br>手动停止主库的容器进程，来模拟宕机的情况</p><pre class="language-python" data-language="python"><code class="language-python">docker stop redissentinel_master_1</code></pre><p>使用<code>info</code>命令查询服务器的角色，可以看到，原本是slave，现在成为了master</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebHook机制</title>
      <link href="/posts/849/"/>
      <url>/posts/849/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是web-hook"><a href="#1-什么是web-hook" class="headerlink" title="1.什么是web hook"></a>1.什么是<code>web hook</code></h3><blockquote><p><code>webhook</code>是一个<code>API</code>概念，并且变得越来越流行，我们能用事件描述的事物越来越多，<code>webhook</code>的作用范围也就越大， <code>webhook</code>作为一个清凉的事件处理应用，正变得越来越有用</p></blockquote><p>我们在网上做的工作，大部分其实就是事件，<code>webhooks</code>已经成为了连接系统的主要方式，不管是用户创建，支付成功，<code>DockerHub</code>镜像推送或者<code>Git</code>仓库上的合并请求，这些都是非常有用并且轻量级的共享信息的方式</p><ul><li><p>简单来说，就是一种反向<code>API</code>，类似于触发器一样</p><ul><li><p>打个比方，比如项目A要从项目B获取数据，通常需要项目B提供一个<code>API</code>接口，然后项目A去请求项目B的接口，获取数据</p></li><li><blockquote><p>通过<code>webhook</code>机制，对客户端和服务端的模式进行逆转</p></blockquote></li><li><p>继续新增加一个需求，项目A需要从项目B获取<strong>实时</strong>数据，如果按照传统做法，不停的去请求接口，就算是实现了这个功能，但是，效率和性能都非常的低</p></li><li><p>通过<code>webhook</code>机制，我们在项目B中加上一个触发器，在项目B每次创建新数据或者修改了某个数据，就会自动触发， 便会向项目B的hook地址进行请求，项目A收到项目B的请求，然后对数据进行处理</p></li></ul></li></ul><hr><h3 id="2-mysql外键的选择"><a href="#2-mysql外键的选择" class="headerlink" title="2.mysql外键的选择"></a>2.<code>mysql</code>外键的选择</h3><blockquote><p>所有的web开发都离不开性能和效率，我们就来聊聊<code>mysql</code>物理外键的性能问题</p></blockquote><p>为何说外键有性能问题，让我们慢慢分析一下</p><ol><li>数据库需要维护外键的内部管理，这样就给数据库增加了一些性能负担，尽管是些小负担，但是在数据量庞大的时候，和优化过的数据库差距也是很大的</li><li>外键等于把数据的一致性事务实现，全部交给数据库服务器完成，同样也会增加数据库服务器的压力</li><li>有了外键，当做一些设计外键字段的增删改等操作之后，需要触发相关操作去检查，从而不得不消耗资源</li><li>外键还会因为需要的请求对其他表内部加锁而容易出现死锁的情况</li></ol><p>虽然很多人不推荐你使用物理外键，但你听到更多的是mysql，而不是SQL server或者其他，比较公认的是，他的外键设计得确实不怎么好，限制多功能不强大等等</p><blockquote><p>还有，最重要的一点是，万一主键所在的表需要拆分，重构，那么，物理外键对应的表，也要进行一系列繁琐的操作，另一方面，数据库帮你保证级联关系，自己不保证思路清晰啊</p></blockquote><p>所以，逻辑外键在业界是比较成熟的，不适用物理外键，我们也可以约定逻辑外键，不再数据库中声明，外键，只在程序中实现关联</p><p>那么，逻辑外键实现了物理外键的功能，这，才是开发人员的第一选择</p><hr><p>说到这里，在数据库的策略上，我们也可以选择逻辑删除</p><blockquote><p>逻辑删除，就是，只对表进行更新增加操作，不进行删除，不再使用的历史数据，定期的归档来减少压力</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> mysql </tag>
            
            <tag> WebHook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写Celery</title>
      <link href="/posts/33958/"/>
      <url>/posts/33958/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>众所周知，celery是一个基于python开发的任务消息队列，轻松实现任务的异步处理，如果对celery不了解，请观阅之前一篇文章Celery</p></blockquote><ul><li>关于celery，它的底层也不是很难，假如，我们在一个需要celery的场景下，例如，我们发送邮件，使用celery是不是有些过重了。这时候，与其调用celery，还不如自己动手去实现一下，这样既轻量，又好用</li><li>我们需要用到的东西，第一就是多线程，因为我们要进行异步操作，使用多线程模拟是最为合理的，然后就是redis，当然了，用List也是可以的，但是我们为了能够贴近真实操作，使用redis中的列表模拟</li></ul><h2 id="实现celery"><a href="#实现celery" class="headerlink" title="实现celery"></a>实现celery</h2><ul><li><p>要知道，celery的本质，是队列，所以，我们手动写一个队列</p><pre class="language-python" data-language="python"><code class="language-python">class MyQueue:    def __init__(self,kename:str,**redis_kwargs):        # 链接redis   decode_response的作用是，字符串不会转换成bytes        self.__db = redis.Redis(**redis_kwargs,decode_responses=True)        self.key = kename        self.queue = []    # 添加数据    def push(self,x:str) -&gt; None:        self.__db.rpush(self.key,x)    # 删除数据    def pop(self) -&gt; int:        return self.queue.pop(0)    # 获取数据    def peek(self) -&gt; str:        return self.__db.lpop(self.key)    # 判断是否执行完毕    def empty(self)-&gt;bool:        return self.__db.llen(self.key)</code></pre></li><li><p>实例化</p><pre class="language-python" data-language="python"><code class="language-python">task_queue = MyQueue('myqueue')</code></pre></li><li><p>我们就以模拟发送邮件为生产者</p><pre class="language-python" data-language="python"><code class="language-python">result = ['1111111@qq.com','22222@qq.com','3333333@qq.com','4444444444@qq.com','55555555555@qq.com']for i in result:    if i[0]:        task_queue.push(i[0])</code></pre></li><li><p>然后，我们使用多线程来模拟消费者</p><pre class="language-python" data-language="python"><code class="language-python">def task():    # 如果队列空了，证明任务完成    while task_queue.empty() != 0:        # 取出任务，模拟消费        print(task_queue.peek())        time.sleep(1)    return '执行完毕'if __name__ == '__main__':    t1 = threading.Thread(target=task)    t2 = threading.Thread(target=task)    t1.start()    t2.start()    t1.join()    t2.join()</code></pre><p>需要几个消费者，就可以开启多个线程，当然了，也可以通过继承threading.Thread创建新的子类，实例化后调用start方法启动新线程，即它调用了线程的<code>run()</code>方法</p><pre class="language-python" data-language="python"><code class="language-python">class Thread_test(threading.Thread):    def __init__(self,queue_task):        threading.Thread.__init__(self)        self.queue = queue_task    def run(self) -&gt; None:        print(self.queue)if __name__ == '__main__':    # 队列为空，即为停止    while task_queue.empty() != 0:        # 创建线程        for i in range(2):            a = Thread_test(task_queue.peek())            a.start()        time.sleep(1)</code></pre></li><li><p>如此，我们便简单的实现了celery的底层</p></li></ul><hr><p>总结，任何名字听起来高大上的工具，不要因为它的触不可及而放弃，我们也可以用很简单的方式实现它们该有的功能。</p>]]></content>
      
      
      <categories>
          
          <category> Celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Celery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件</title>
      <link href="/posts/62285/"/>
      <url>/posts/62285/</url>
      
        <content type="html"><![CDATA[<h2 id="1-组件定义"><a href="#1-组件定义" class="headerlink" title="1.组件定义"></a>1.组件定义</h2><ol><li><p>定义组件并引用 </p></li><li><p>父组件向子组件传值 </p></li><li><p>子组件向父组件传值 </p></li></ol><p>组件间传值：<a href="https://www.cnblogs.com/xiaonq/p/9697921.html">vuex</a></p><hr><h4 id="1-1-什么是组件"><a href="#1-1-什么是组件" class="headerlink" title="1.1  什么是组件"></a>1.1  什么是组件</h4><ul><li><code>Html</code>中有组件，是一段可以被复用的结构代码</li><li>Css中有组件，是一段可以被复用的样式</li><li>Js中有组件，是一段可以被复用的功能</li><li>Vue中的组件，指的就是一个模块，是一个独立的，完整的(包含<code>html，cssm，js</code>等)，可以直接拿来用</li></ul><h4 id="1-2-组件特性"><a href="#1-2-组件特性" class="headerlink" title="1.2  组件特性"></a>1.2  组件特性</h4><ul><li><p>组件的实例化对象，跟<code>vue</code>实例化对象一样，因此，我们也可以将<code>vue</code>实例化对象看成组件</p></li><li><p>组件间是独立的，因此数据要独立存储，方法要独立定义， **彼此间不能共享 **。</p></li></ul><hr><h2 id="2-父组件向子组件传值"><a href="#2-父组件向子组件传值" class="headerlink" title="2.父组件向子组件传值"></a>2.父组件向子组件传值</h2><h5 id="2-1-components-Child-vue-定义子组件"><a href="#2-1-components-Child-vue-定义子组件" class="headerlink" title="2.1  components/Child.vue 定义子组件"></a>2.1  <code>components/Child.vue</code> <strong>定义子组件</strong></h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;&lt;div style="color: red"&gt;        &lt;h1&gt;子组件内容&lt;/h1&gt;         &lt;p&gt;{{data{{&lt;/p&gt;     &lt;/div&gt; &lt;/template&gt; &lt;script&gt;     export default {         props: ['data'], // 接收父组件给子组件定义的属性     { &lt;/script&gt;</code></pre><blockquote><p>子组件要使用父组件的数据，只需要一步，在 props中接收父组件的属性</p></blockquote><h5 id="2-2-components-Father-vue-定义父组件"><a href="#2-2-components-Father-vue-定义父组件" class="headerlink" title="2.2   components/Father.vue 定义父组件"></a>2.2   <code>components/Father.vue</code> <strong>定义父组件</strong></h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt; &lt;div&gt;     &lt;h1&gt;父组件内容&lt;/h1&gt;     父组件显示:{{msg{{     &lt;!--3.第三步：把父组件的某一个属性传递给子组件--&gt;     &lt;Child :data='msg' &gt;&lt;/Child&gt;     &lt;/div&gt;&lt;/template&gt; &lt;script&gt;     // @指定的是src路径     import Child from '@/components/Child'     // 1.第一步：在父组件中导入子组件     export default {         // 2.第二步：父组件中注册子组件         components: {             Child         {,        data() {             return {                 msg: '父组件的信息'             {         {,        methods: {                     {     { &lt;/script&gt;</code></pre><blockquote><p><code>components</code>注册子组件</p></blockquote><h5 id="2-3-router-index-js-中注册路由"><a href="#2-3-router-index-js-中注册路由" class="headerlink" title="2.3  router/index.js 中注册路由"></a>2.3  <code>router/index.js</code> <strong>中注册路由</strong></h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript">import Father from '@/components/Father' // @修饰符指的是 src目录 export default new Router({     routes: [{         path: '/component',         name: 'Father',        component: Father     {,]{)</code></pre><blockquote><p>子组件中可以通过 定义 <code>props</code> 属性来接收父组件的数据</p></blockquote><h2 id="3-子组件向父组件传值"><a href="#3-子组件向父组件传值" class="headerlink" title="3.子组件向父组件传值"></a>3.<strong>子组件向父组件传值</strong></h2><h5 id="3-1-components-Child-vue-子组件通过触发方法-向父组件传值"><a href="#3-1-components-Child-vue-子组件通过触发方法-向父组件传值" class="headerlink" title="3.1  components/Child.vue 子组件通过触发方法, 向父组件传值"></a>3.1  <code>components/Child.vue</code> <strong>子组件通过触发方法, 向父组件传值</strong></h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;    &lt;div&gt;        &lt;h1&gt;子组件页面&lt;/h1&gt;        &lt;span&gt;子组件{{data{{&lt;/span&gt;        &lt;button @click="f1"&gt;调用父&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {    //用props接收父组件的属性    props:['data'],    methods:{        // 接收父组件给子组件定义的属性         f1(){         //1.子组件调用父组件方法，并传值 // $emit 触发当前实例上的事件，也可以简单的理解为触发父组件上的事件（向上冒泡）            this.$emit('changeMsg','子的信息')        {    {{&lt;/script&gt;</code></pre><h5 id="3-2-components-Father-vue给子组件添加事件及事件处理方法"><a href="#3-2-components-Father-vue给子组件添加事件及事件处理方法" class="headerlink" title="3.2 components/Father.vue给子组件添加事件及事件处理方法"></a>3.2 <code>components/Father.vue</code><strong>给子组件添加事件及事件处理方法</strong></h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;template&gt;    &lt;div&gt;        &lt;h1&gt;父组件页面&lt;/h1&gt;        {{msg{{        &lt;Child :data='msg' @changeMsg='f2'&gt;&lt;/Child&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from '@/components/Child'export default {    components:{        Child    {,    data(){        return{            msg:'父的数据'        {    {,    methods:{        // 在父组件中定义一个f2方法，可以在子组件中触发并传值给父组件         f2(data){            // data接收是子组件中传递的数据            this.msg = data// 更新父组件的内容         {    {{&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue优化之代码层面的优化</title>
      <link href="/posts/32848/"/>
      <url>/posts/32848/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vue 框架通过数据双向绑定和虚拟 DOM 技术，帮我们处理了前端开发中最脏最累的 DOM 操作部分， 我们不再需要去考虑如何操作 DOM 以及如何最高效地操作 DOM；但 Vue 项目中仍然存在项目首屏优化、Webpack 编译配置优化等问题，所以我们仍然需要去关注 Vue 项目性能方面的优化，使项目具有更高效的性能、更好的用户体验。</p></blockquote><h2 id="代码层面的优化"><a href="#代码层面的优化" class="headerlink" title="代码层面的优化"></a>代码层面的优化</h2><p>在vue中，有很多的功能相似，有略微区别的代码，正确的在使用场景下使用适合它的元素，会让代码运行的更加丝滑</p><h4 id="1-1-v-if和v-show使用场景"><a href="#1-1-v-if和v-show使用场景" class="headerlink" title="1.1 v-if和v-show使用场景"></a>1.1 v-if和v-show使用场景</h4><p><strong>v-if</strong> 是 <strong>真正</strong> 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p><strong>v-show</strong> 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><blockquote><p>比如，你的电脑</p><p>v-if就等于是你完全的将他关闭了，需要用时，再将他打开</p><p>v-show相当于是睡眠模式，他始终都开着，只是你看不到</p></blockquote><hr><h4 id="1-2-computed和watch使用场景"><a href="#1-2-computed和watch使用场景" class="headerlink" title="1.2 computed和watch使用场景"></a>1.2 computed和watch使用场景</h4><p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；</p><blockquote><p>简单来说就是，对计算结果会进行缓存，如果原始数据不改变，不需要重新计算，直接从缓存中读取结果</p><p>但是，方法必须有返回值，减少计算量，牺牲空间，来换取时间，对一些复杂的运算，使用计算属性会非常的有效率</p></blockquote><blockquote><p>假如，你经常的在一家商店购买十箱苹果， 在普通的函数计算中，需要每次取出苹果价格和数量，在计算属性中，只要你价格和数量没变化，就不需要计算，只需要从缓存中取值就好了</p></blockquote><p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><blockquote><p>监听属性简单来说就是数据一旦发生改变，会自动触发执行，watch属性中的对应的函数</p><p>如果函数中，有两个参数 a和b，a就是修改之后的新值，b是修改之前的旧值</p></blockquote><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><hr><h4 id="1-3-v-for遍历必须为item添加key，且避免同时使用v-if"><a href="#1-3-v-for遍历必须为item添加key，且避免同时使用v-if" class="headerlink" title="1.3 v-for遍历必须为item添加key，且避免同时使用v-if"></a>1.3 v-for遍历必须为item添加key，且避免同时使用v-if</h4><ul><li><p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 <code>Vue</code>内部机制精准找到该条列表数据。当 状态更新时，新的状态值和旧的状态值对比，较快地定位到这个循环 。</p></li><li><p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">// 推荐&lt;ul&gt;  &lt;li    v-for="user in activeUsers"    :key="user.id"&gt;    {{ user.name {{  &lt;/li&gt;&lt;/ul&gt;computed: {  activeUsers: function () {    return this.users.filter(function (user) { return user.isActive    {)  {{// 不推荐&lt;ul&gt;  &lt;li    v-for="user in users"    v-if="user.isActive"    :key="user.id"&gt;    {{ user.name {{  &lt;/li&gt;&lt;/ul&gt;</code></pre></li></ul><hr><h4 id="1-4-长列表性能的优化"><a href="#1-4-长列表性能的优化" class="headerlink" title="1.4 长列表性能的优化"></a>1.4 长列表性能的优化</h4><blockquote><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript">export default {  data: () =&gt; ({    users: {{  {),  async created() {    const users = await axios.get("/api/users");    this.users = Object.freeze(users);  {{;</code></pre><hr><h4 id="1-5-事件的销毁"><a href="#1-5-事件的销毁" class="headerlink" title="1.5 事件的销毁"></a>1.5 事件的销毁</h4><blockquote><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript">created() {  addEventListener('click', this.click, false){,beforeDestroy() {  removeEventListener('click', this.click, false){</code></pre><hr><h4 id="1-6-图片懒加载"><a href="#1-6-图片懒加载" class="headerlink" title="1.6 图片懒加载"></a>1.6 图片懒加载</h4><p>对于图片过多的页面，为了加速页面的加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载，等到滚动到可视区域再去加载，这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件</p><ol><li><p>安装插件</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">npm install vue-lazyload --save-dev</code></pre></li><li><p>在入口文件main.js中引入并使用</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">import VueLazyload from 'vue-lazyload'</code></pre></li><li><p>在vue中直接使用</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">Vue.use(VueLazyload)</code></pre><p>或者添加自定义选项</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">Vue.use(VueLazyload, {preLoad: 1.3,error: 'dist/error.png',loading: 'dist/loading.gif',attempt: 1{)</code></pre></li><li><p>在 vue 文件中将 img 标签的 :src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示</p><pre class="language-html" data-language="html"><code class="language-html">&lt;img v-lazy="/static/img/1.png"&gt;</code></pre></li></ol><hr><h4 id="1-7-提取公共代码"><a href="#1-7-提取公共代码" class="headerlink" title="1.7 提取公共代码"></a>1.7 提取公共代码</h4><blockquote><p>一个项目，不可能只有一个页面，而多个页面中，有相同资源的，重复加载会浪费用户的流量和服务器的成本，每个页面的加载资源太大，导致网页加载缓慢，影响用户体验</p><p>所以，我们需要提取公共的代码，抽离成单独的文件，以组件的方式在页面中灵活运用，组件间的应用，请参考<a href="https://god_hearing.gitee.io/myhexo/2020/10/30/vue-zu-jian/">这里</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支付宝支付</title>
      <link href="/posts/64484/"/>
      <url>/posts/64484/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>微信与支付宝，国内无现金交易的两个巨头，在我们做项目的过程中，肯定少不了与这两个打交道，但是，涉及到钱的问题，稍微的不谨慎，就会造成不可磨灭的影响，所以，今天带来支付宝支付的攻略</p></blockquote><h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a><code>openssl</code></h2><p>首先，安装一个<code>openssl</code>，<a href="http://slproweb.com/products/Win32OpenSSL.html">地址</a></p><p>选择64位还是32位，看自己电脑</p><p>然后，在命令行输入<code>openssl</code>，进入openssl程序，然后分别执行以下命令：</p><pre class="language-python" data-language="python"><code class="language-python">genrsa -out rsa_private_key.pem   2048  # 生成私钥rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem # 生成公钥</code></pre><blockquote><p>这样就在当前目录生成了两个文件rsa_private_key.pem和rsa_public_key.pem，将这两个秘钥集成到项目中，就可以进行支付宝支付业务的处理了，当然也可以根据阿里提供的支付开放平台来进行生成，具体流程可自行google，并不算难</p></blockquote><p>然后我们后台选择的是<code>django</code>，在Django中集成支付接口的前置操作就是需要安装alipay的sdk，顺便导入加密模块</p><pre class="language-none"><code class="language-none">pip install python-alipay-sdkpip install Crypto</code></pre><p>然后将之前生成好的私钥和公钥(<strong>注意这里的公钥指的是支付宝公钥</strong>)，放入到项目目录中，改个名字好区分</p><pre class="language-python" data-language="python"><code class="language-python">app_public.txt  # 应用公钥app_private.txt # 应用私钥alipay_public.txt  # 支付宝公钥</code></pre><p>其中，填写上自己对应的公钥与私钥，格式为：</p><pre class="language-python" data-language="python"><code class="language-python">alipay_public.txt-----BEGIN PUBLIC KEY----- 密钥-----END PUBLIC KEY-----app_public.txt-----BEGIN PUBLIC KEY----- 密钥-----END PUBLIC KEY-----app_private.txt-----BEGIN RSA PRIVATE KEY-----密钥-----END RSA PRIVATE KEY-----</code></pre><p>然后在settings中配置：</p><pre class="language-python" data-language="python"><code class="language-python">ALIPAY_PUBLIC = os.path.join(BASE_DIR,'keys','alipay_public.txt')APP_PUBLIC = os.path.join(BASE_DIR,'keys','app_public.txt')APP_PRIVATE = os.path.join(BASE_DIR,'keys','app_private.txt')</code></pre><blockquote><p>注意路径</p></blockquote><p>新建个<code>pay.py</code>文件</p><pre class="language-python" data-language="python"><code class="language-python">from datetime import datetimefrom Crypto.PublicKey import RSAfrom Crypto.Signature import PKCS1_v1_5from Crypto.Hash import SHA256from urllib.parse import quote_plusfrom urllib.parse import urlparse, parse_qsfrom base64 import decodebytes, encodebytesimport jsonimport requestsclass AliPay(object):    """    支付宝支付接口(PC端支付接口)    """    def __init__(self, appid, app_notify_url, app_private_key_path,                 alipay_public_key_path, return_url, debug=False):        self.appid = appid        self.app_notify_url = app_notify_url        self.app_private_key_path = app_private_key_path        self.app_private_key = None        self.return_url = return_url        with open(self.app_private_key_path) as fp:            self.app_private_key = RSA.importKey(fp.read())        self.alipay_public_key_path = alipay_public_key_path        with open(self.alipay_public_key_path) as fp:            self.alipay_public_key = RSA.importKey(fp.read())        if debug is True:            self.__gateway = "https://openapi.alipaydev.com/gateway.do"        else:            self.__gateway = "https://openapi.alipay.com/gateway.do"    def direct_pay(self, subject, out_trade_no, total_amount, return_url=None, **kwargs):        biz_content = {            "subject": subject,            "out_trade_no": out_trade_no,            "total_amount": total_amount,            "product_code": "FAST_INSTANT_TRADE_PAY",            # "qr_pay_mode":4        }        biz_content.update(kwargs)        data = self.build_body("alipay.trade.page.pay", biz_content, self.return_url)        return self.sign_data(data)    def build_body(self, method, biz_content, return_url=None):        data = {            "app_id": self.appid,            "method": method,            "charset": "utf-8",            "sign_type": "RSA2",            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),            "version": "1.0",            "biz_content": biz_content        }        if return_url is not None:            data["notify_url"] = self.app_notify_url            data["return_url"] = self.return_url        return data    def sign_data(self, data):        data.pop("sign", None)        # 排序后的字符串        unsigned_items = self.ordered_data(data)        unsigned_string = "&amp;".join("{0}={1}".format(k, v) for k, v in unsigned_items)        sign = self.sign(unsigned_string.encode("utf-8"))        # ordered_items = self.ordered_data(data)        quoted_string = "&amp;".join("{0}={1}".format(k, quote_plus(v)) for k, v in unsigned_items)        # 获得最终的订单信息字符串        signed_string = quoted_string + "&amp;sign=" + quote_plus(sign)        return signed_string    def ordered_data(self, data):        complex_keys = []        for key, value in data.items():            if isinstance(value, dict):                complex_keys.append(key)        # 将字典类型的数据dump出来        for key in complex_keys:            data[key] = json.dumps(data[key], separators=(',', ':'))        return sorted([(k, v) for k, v in data.items()])    def sign(self, unsigned_string):        # 开始计算签名        key = self.app_private_key        signer = PKCS1_v1_5.new(key)        signature = signer.sign(SHA256.new(unsigned_string))        # base64 编码，转换为unicode表示并移除回车        sign = encodebytes(signature).decode("utf8").replace("\n", "")        return sign    def _verify(self, raw_content, signature):        # 开始计算签名        key = self.alipay_public_key        signer = PKCS1_v1_5.new(key)        digest = SHA256.new()        digest.update(raw_content.encode("utf8"))        if signer.verify(digest, decodebytes(signature.encode("utf8"))):            return True        return False    def verify(self, data, signature):        if "sign_type" in data:            sign_type = data.pop("sign_type")        # 排序后的字符串        unsigned_items = self.ordered_data(data)        message = "&amp;".join(u"{}={}".format(k, v) for k, v in unsigned_items)        return self._verify(message, signature)    #请求退款接口    def api_alipay_trade_refund(self,refund_amount,out_trade_no=None,trade_no=None,**kwargs):        #构造参数体        biz_content = { "refund_amount":refund_amount}        #传递可选参数        biz_content.update(**kwargs)        #判断使用站外订单还是支付宝订单        if out_trade_no:            biz_content["out_trade_no"] = out_trade_no        if trade_no:            biz_content["trade_no"] = trade_no        #构造支付接口地址        data = self.build_body("alipay.trade.refund",biz_content)        #构造url        url = self.__gateway+"?" + self.sign_data(data)        #请求接口        r = requests.get(url)        html = r.content.decode("utf-8")        return html</code></pre><p>在视图中：</p><pre class="language-python" data-language="python"><code class="language-python">#导入支付基类from testdjango.settings import BASE_DIRfrom testdjango import settingsimport timefrom django.shortcuts import render, redirect, HttpResponsefrom .pay import AliPayimport os# 支付宝初始化app_private_key_string = os.path.join(BASE_DIR,'keys','app_private.txt')alipay_public_key_string = os.path.join(BASE_DIR,'keys','alipay_public.txt')def get_order_code():    order_no = str(time.strftime('%Y%m%d%H%M%S', time.localtime(time.time())))    return order_no#初始化阿里支付对象def get_ali_object():    app_id = "2016102600762844"  #  APPID （沙箱应用）    # 支付完成后，跳转的地址。    return_url = "http://localhost:8000/alipayreturn/"    alipay = AliPay(        appid=app_id,        app_notify_url=return_url,        return_url=return_url,        app_private_key_path=app_private_key_string,        alipay_public_key_path=alipay_public_key_string,  # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥        debug=True,  # 默认False,    )    return alipaydef page1(request):    # 根据当前用户的配置，生成URL，并跳转。    money = request.POST.get('money')    alipay = get_ali_object()    # 生成支付的url    query_params = alipay.direct_pay(        subject="test",  # 商品简单描述        out_trade_no=get_order_code(),        total_amount=1,  # 交易金额(单位: 元 保留俩位小数)    )    pay_url = "https://openapi.alipaydev.com/gateway.do?{0}".format(query_params)  # 支付宝网关地址（沙箱应用）    print(pay_url)    return redirect(pay_url)def alipay_return(request):    alipay = get_ali_object()    params = request.GET.dict()    out_trade_no = request.GET.get("out_trade_no")    print(out_trade_no)    sign = params.pop('sign', None)    status = alipay.verify(params, sign)    print('==================开始==================')    print('GET验证', status)    print('==================结束==================')    return HttpResponse('支付成功')</code></pre><p>搞完收工，访问一下的视图即可跳转到支付页面，然后回调这些记得和网页环境一致即可。</p><h2 id="退款"><a href="#退款" class="headerlink" title="退款"></a>退款</h2><blockquote><p>退款业务，也是基于订单号。在之前的<code>pay</code>中已经添加过了，我们只需要增加一个视图即可</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">def refund(request):    #实例化支付类    alipay = get_ali_object()    #调用退款方法    order_string = alipay.api_alipay_trade_refund(    #订单号，一定要注意，这是支付成功后返回的唯一订单号    out_trade_no="20201216102213",    #退款金额，注意精确到分，不要超过订单支付总金额    refund_amount="1.00",    #回调网址    notify_url='http://localhost:8000/alipayreturn'    )    return HttpResponse(order_string)</code></pre><p>以上就是支付宝与django的操作，感谢观看</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> 支付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>验证码系列(邮箱、短信)</title>
      <link href="/posts/846/"/>
      <url>/posts/846/</url>
      
        <content type="html"><![CDATA[<h2 id="python3利用腾讯云发送短信"><a href="#python3利用腾讯云发送短信" class="headerlink" title="python3利用腾讯云发送短信"></a><code>python3</code>利用腾讯云发送短信</h2><h4 id="如何发送短信"><a href="#如何发送短信" class="headerlink" title="如何发送短信"></a>如何发送短信</h4><blockquote><p>首先，注册一个腾讯云的账号，然后点击<a href="https://cloud.tencent.com/product/sms">这里</a></p></blockquote><ol><li><p>注册成功后，腾讯云会自动生成一个短信应用，如果没有默认应用，需要新建一下</p></li><li><p>记录一下应用的 appid 以及 appkey 一会要用到</p><p><img src="/posts/846/012.png" loading="lazy"></p></li><li><p>配置短信的签名，用来限制短信接口的权限，防止被恶意调用</p></li><li><p>然后配置模板</p></li><li><p>好了，进入正题，下面安装腾讯云短信的sdk<br><code>pip install qcloudsms_py</code></p></li><li><p>按照官网文档，准备必要的参数</p><pre class="language-python" data-language="python"><code class="language-python"># 短信应用 SDK AppIDappid = 1400009099  # SDK AppID 以1400开头# 短信应用 SDK AppKeyappkey = "9ff91d87c2cd7cd0ea762f141975d1df37481d48700d70ac37470aefc60f9bad"# 需要发送短信的手机号码phone_numbers = ["21212313123", "12345678902", "12345678903"]# 短信模板ID，需要在短信控制台中申请template_id = 7839  # NOTE: 这里的模板 ID`7839` 只是示例，真实的模板 ID 需要在短信控制台中申请# 签名sms_sign = "腾讯云"  # NOTE: 签名参数使用的是`签名内容`，而不是`签名ID`。这里的签名"腾讯云"只是示例，真实的签名需要在短信控制台中申请</code></pre></li><li><p>指定模板ID单发短信</p><pre class="language-python" data-language="python"><code class="language-python">from qcloudsms_py import SmsSingleSenderfrom qcloudsms_py.httpclient import HTTPErrorssender = SmsSingleSender(appid, appkey)params = ["5678"]  # 当模板没有参数时，`params = []`可以发送随机数，用来做短信验证码,如果指定为["5678",'5']，则过期时间为5分钟try: result = ssender.send_with_param(86, phone_numbers[0],      template_id, params, sign=sms_sign, extend="", ext="") except HTTPError as e: print(e)except Exception as e: print(e)print(result)</code></pre></li><li><p>如果要群发短信，<code>phone_numbers</code>不取0值，发送全部</p></li></ol><hr><h4 id="点击发送短信验证码"><a href="#点击发送短信验证码" class="headerlink" title="点击发送短信验证码"></a>点击发送短信验证码</h4><p>视图定义，获取手机号，这里，我是把上面的脚本封装成函数<code>phone_s</code>了，两个参数，分别为手机号和随机数验证码</p><pre class="language-python" data-language="python"><code class="language-python">class phoneView(APIView):    def post(self,request):        phone = request.POST.get('phone')# 随机数，用来做验证码        uuid = random.randint(1000,9999)        # 调用发送短信的接口，传入手机号和随机数验证码        pwg = phone_s(phone,uuid)        if pwg:            # 连接redis            redis_client = get_redis_connection('phone')            redis_phone = redis_client.get(phone)# 防止频繁发送，如果redis中有，就不必再发            if redis_phone:                return Response({'code': 1003, 'msg': '频繁发送'{)            # 存入redis,邮箱为键，uuid为值            redis_client = get_redis_connection('phone')  # 获取redis客户端            redis_client.setex(phone, 60 * 5, uuid)            return Response({'code':1000,'msg':'发送成功'{)        return Response({'code':1004,'msg':'发送失败'{)</code></pre><p>至于验证，只需要从redis中取出验证码来比对即可</p><hr><h2 id="邮箱验证码"><a href="#邮箱验证码" class="headerlink" title="邮箱验证码"></a>邮箱验证码</h2><p>发送邮箱验证码，我们使用的是QQ邮箱，打开QQ邮箱，打开设置，在里面找到</p><p><strong><code>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</code></strong></p><p>打开POP3/SMTP服务</p><p>获取到授权码之后，我们就可以直接可以开始</p><pre class="language-python" data-language="python"><code class="language-python">#定义参数my_mail = "你申请授权的邮箱"#授权码my_pass = "授权码"#定义发送邮件的方法def mail(subject,content,mailaddr):    #声明邮件对象    msg = MIMEText(content,'plain','utf-8')    #设置发送方对象    msg['From'] = formataddr(['在线教育平台',my_mail])    #设置收件方对象    msg['To'] = formataddr(['尊敬的客户',mailaddr])    #设置标题    msg['Subject'] = subject    #设置smtp服务器    server = smtplib.SMTP_SSL("smtp.qq.com",465)    #登录邮箱    server.login(my_mail,my_pass)    #发送邮件    server.sendmail(my_mail,[mailaddr],msg.as_string())    #关闭smtp链接    server.quit()</code></pre><p>然后定义视图</p><pre class="language-python" data-language="python"><code class="language-python">class Go_emailView(APIView):    def post(self,request):        # 验证邮箱有效性        email = request.POST.get('email',None)        try:            re.match(r'[a-zA-Z0-9]{0,19{@(qq|163|126)\.(com|cn|net)$', email)        except Exception as e:            return Response({'code': 1002, 'msg': '电子邮箱不正确'{)        # 查询redis中是否有这个数据，如果有，则不需要再次发送        # 验证邮箱验证码        redis_client = get_redis_connection('email')        # 获取redis中的库        redis_email = redis_client.get(email)        if redis_email:            return Response({'code':1003,'msg':'频繁发送'{)        uuid = random.randint(0,9999)        try:            # 调用发送邮件的函数            mail('龙潭技术博客验证', '您的验证码是{{，有限期为2分钟'.format(uuid), email)            # 存入redis,邮箱为键，uuid为值            redis_client = get_redis_connection('email')  # 获取redis客户端            redis_client.setex(email, 60 * 2, uuid)            return Response({'code':1000,'msg':'发送成功'{)        except Exception as e:            print(e)            return Response({'code':1001,'msg':'发送失败'{)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABAC权限模型</title>
      <link href="/posts/58788/"/>
      <url>/posts/58788/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ABAC权限模型，是基于属性的权限模型，ABAC通过动态计算一个或一组属性来满足某种条件来进行授权判断(可以编写简单的逻辑)，属性通常来说分为四类，用户属性(例如年龄，性别等)，环境属性(比如时间，地点)，操作属性(比如读取)，对象属性(如一篇文章，又称为资源属性),所以理论上能够实现非常灵活的控制权限,几乎能满足所有类型的需求</p></blockquote><p>例如规则：“允许所有班主任在上课时间自由进出校门”这条规则，其中，“班主任”是用户的角色属性，“上课时间”是环境属性，“进出”是操作属性，而“校门”就是对象属性了。为了实现便捷的规则设置和规则判断执行，ABAC通常有配置文件（XML、YAML等）或DSL配合规则解析引擎使用。XACML（eXtensible Access Control Markup Language）是ABAC的一个实现，但是该设计过于复杂，我还没有完全理解，故不做介绍。</p><hr><p>总结一下，ABAC有如下特点</p><ol><li>集中化管理</li><li>可以按需求实现不同颗粒度的权限控制</li><li>不需要预定以判断逻辑，减轻了权限系统的维护成本，特别是需求经常变化的系统中</li><li>定义权限时，不能直观的看出用户和对象间的关系</li><li>规则如果稍微复杂一点，或者设计混乱，就会给管理者维护和追查带来麻烦</li><li>权限判断需要实时执行，规则过多会导致性能问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACL与RBAC访问权限模型</title>
      <link href="/posts/16426/"/>
      <url>/posts/16426/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是ACL"><a href="#什么是ACL" class="headerlink" title="什么是ACL"></a>什么是<code>ACL</code></h4><blockquote><p>以前非常盛行的一种权限设计，它的核心主要在于用户和权限直接挂钩。</p><p>它的原理非常的简单，每一项资源，都配有一个列表，这个列表记录的就是哪些用户可以对这项资源执行CRUD中的那些操作。当系统试图访问这项资源时，会首先检查这个列表中是否有关于当前用户的访问权限，从而确定当前用户可否执行相应的操作。总得来说，<code>ACL</code>是一种面向资源的访问控制模型，它的机制是围绕<strong>“资源”</strong>展开的。</p></blockquote><p>它的优点是：简单易用，开发便捷</p><p>但同样，它的缺点也很明显，用户和权限直接挂钩，导致在授予权限时的复杂性，比较分散，不便于管理</p><p>使用场景：</p><ul><li> 比较小的用户管理系统</li><li> 常见的文件系统权限设计，直接给用户加权限</li></ul><h4 id="什么是RBAC"><a href="#什么是RBAC" class="headerlink" title="什么是RBAC"></a>什么是<code>RBAC</code></h4><blockquote><p><code>RBAC</code>是基于角色的访问控制系统，权限和角色相联系，用户通过成为某个角色而获取该角色拥有的权限</p><p>它的原理就是将用户按照角色进行归类，通过用户的角色来确定用户有没有对某项资源访问的权限</p></blockquote><p>这样做的好处是，简化了用户与权限的管理，在一定程度上简化了授予时的复杂度，易扩展 易于维护</p><p>缺点：开发对比于<code>ACL</code>相对复杂，而且，比较僵硬，如果要修改某个用户所拥有的权限，只能修改它的角色，这样，如果有不想让他拥有的权限，<code>RBAC</code>就显得很僵硬。</p><p>使用场景：</p><ul><li>数据量比较庞大时授予权限</li><li>比较明确的角色分明时</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>如果要写一个用户管理系统，数据表之间的关联关系适当的添加关联关系甚至可以不添加那些看起来关联住的表，这样，查询时，完全可以通过多表联查来实现某些目的，不仅会使维护变得简单许多，还会将这个框给划开，而不是牵一发而动全身。</p><p><img src="/posts/16426/20201102201153.png" loading="lazy"></p><p><strong>左：<code>ACL</code>  右：<code>RBAC</code></strong></p><blockquote><p>无论是<code>ACL</code>还是<code>RBAC</code>，都不能过于复杂，规则过多，否则，维护性和性能会下降</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊天机器人</title>
      <link href="/posts/21161/"/>
      <url>/posts/21161/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是聊天机器人"><a href="#什么是聊天机器人" class="headerlink" title="什么是聊天机器人"></a>什么是聊天机器人</h2><blockquote><p>好吧其实没什么好解释的，就是能够一天二十四小时陪伴你到老的机器人，具有一定的学习能力，越来越像人，让你在没人陪的时候也能有人聊聊天解解闷</p></blockquote><p>由于我还不太熟悉花里胡哨的机器学习，虽然对这方面有着很大的兴趣，但是奈何需要一定的门槛，不过没关系，我们可以先做一个调包侠</p><p>这篇教程，让我们一起用python来实现三款免费而且好用的机器人</p><p>从最简单的青云客开始吧</p><h2 id="青云客"><a href="#青云客" class="headerlink" title="青云客"></a>青云客</h2><p>首先呢，青云客可谓是相当的简单了，也不需要注册，不需要登录，直接上代码吧</p><pre class="language-python" data-language="python"><code class="language-python">url = 'http://api.qingyunke.com/api.php?key=free&amp;appid=0&amp;msg=%s'%(urllib.parse.quote('你好呀'))html = requests.get(url)print(html.json()['content'])</code></pre><blockquote><p>唯一需要注意的一点是，中文在url里，必须得转码，避免报错的可能，使用urllib</p></blockquote><h2 id="微软小冰"><a href="#微软小冰" class="headerlink" title="微软小冰"></a>微软小冰</h2><blockquote><p>微软小冰是领先的跨平台人工智能机器人。微软小冰注重人工智能在拟合人类情商维度的发展，强调人工智能情商，而非任务完成在人机交互中的基础价值。</p></blockquote><p>首先需要先领养小冰，通过微博关注小冰，然后给她发个消息</p><p><img src="/posts/21161/image-20201116200835343.png" loading="lazy"></p><p>领养完成之后，按F12打开调试窗口，通过<code>chat/</code>里的Cookie，找到SUB值，注意不要手动退出，手动退出会刷新SUB的</p><p><img src="/posts/21161/image-20201116200959106.png" loading="lazy"></p><p>之后，随便再发一条消息，找到<code>new.json</code>数据包，找到uid和source</p><p><img src="/posts/21161/image-20201116201243607.png" loading="lazy"></p><p>最后构造参数</p><pre class="language-python" data-language="python"><code class="language-python">def xiaobing():    uid = '你的uid'    source = '你的source'    SUB = '你的SUB'    url_send = 'https://api.weibo.com/webim/2/direct_messages/new.json'    data = {        'text': 你要说的话,        'uid': uid,        'source': source    }    headers = {        'cookie': 'SUB='+SUB,        'Content-Type': 'application/x-www-form-urlencoded',        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36',        'Referer': 'https://api.weibo.com/chat/'    }    response = requests.post(url_send, data=data, headers=headers).json()    sendMsg = response['text']    time.sleep(1)    while True:        url_get = 'https://api.weibo.com/webim/2/direct_messages/conversation.json?uid={}&amp;source={}'.format(uid, source)        response = requests.get(url=url_get,headers=headers).json()        getMsg = response['direct_messages'][0]['text']        if sendMsg == getMsg:            time.sleep(1)            else:                return getMsg</code></pre><p>也是调包侠的日常，没啥难度</p><h2 id="腾讯闲聊"><a href="#腾讯闲聊" class="headerlink" title="腾讯闲聊"></a>腾讯闲聊</h2><p> 这个也和小冰类似</p><p>先创建应用</p><img src="/posts/21161/image-20201116201602855.png" alt style="zoom:50%;" loading="lazy"><p>拿到ID和KEY</p><img src="/posts/21161/image-20201116201641496.png" alt style="zoom:50%;" loading="lazy"><p>欧克，准备工作完成，上代码</p><pre class="language-python" data-language="python"><code class="language-python">def tencent(msg):    APPID = '123'    APPKEY = '123'    url = 'https://api.ai.qq.com/fcgi-bin/nlp/nlp_textchat'    params = {        'app_id': APPID,        'time_stamp': str(int(time.time())),        'nonce_str': ''.join(random.choice(string.ascii_letters + string.digits) for x in range(16)),        'session': '10000'.encode('utf-8'),        'question': msg.encode('utf-8')    }    sign_before = ''    for key in sorted(params):        # 键值拼接过程value部分需要URL编码，URL编码算法用大写字母，例如%E8。quote默认大写。        sign_before += '{}={}&amp;'.format(key, urllib.parse.quote(params[key], safe=''))        # 将应用密钥以app_key为键名，拼接到字符串sign_before末尾    sign_before += 'app_key={}'.format(APPKEY)    # 对字符串sign_before进行MD5运算，得到接口请求签名    sign = hashlib.md5(sign_before.encode('UTF-8')).hexdigest().upper()    params['sign'] = sign    # print(params)    html = requests.post(url, data=params).json()    return html['data']['answer']msg= '我好看吗'print("原话&gt;&gt;", msg)res = tencent(msg)print("腾讯&gt;&gt;", res)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据结构与算法</title>
      <link href="/posts/36300/"/>
      <url>/posts/36300/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><blockquote><p>又称存储结构</p></blockquote><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p> 集合结构：(同属一个整体，但是每个元素之间没有关系)<br>​ 线性结构：队尾元素没有直接后继，队头元素没有直接前驱,其他元素有唯一的直接前驱和后继（一对一）<br>​ 树形结构：除了根元素，其他元素都有一个前驱和多个后继（一对多）<br>​ 图形结构：每个元素都有多个前驱和后继（多对多）</p><p> 重点:<code>线性结构</code></p><ul><li>如果既是线性结构，又是链式结构，这种结构成为链表</li><li>如果既是线性结构，又是顺序结构，这种结构成为顺序表</li></ul><p>链表又分为：单向链表 双向链表 单向循环链表</p><p>单向链表:当连接表中的每个节点只包含一个指针时，他只能指向下一个节点地址，这种只含有一个指针域的链表，称为<strong>单向链表</strong></p><p>双向链表：它的连接表中，每个节点，都有两个指针，指向了直接前驱和直接后继，从双向链表中的任意一个节点开始访问，都能很方便的访问到它的前驱节点和后继节点，这种结构，称为<strong>双向链表</strong></p><p>单向循环链表：普通的单向链表，末尾节点(也叫叶子节点)的指针，不再指向NULL，而是指向第一个节点，即开始节点</p><blockquote><p>为什么要用单向循环链表，打个比方，我们要对单向链表中的某个节点进行访问，只能从头开始访问，而单向循环链表，可以从任意一个节点开始，因为它末尾的的指针指向了第一个节点，极大的增加了其灵活性</p></blockquote><p>接下来，我们用代码来展示一下</p><pre class="language-python" data-language="python"><code class="language-python">'''单向链表：指向空的节点为尾结点单向循环链表：指向头结点的节点为尾结点'''# 创建节点类class Node:    def __init__(self, data):        """节点类"""        self.data = data        self.pointer = None        # 创建链表类       class SCLL:    def __init__(self):        """ 初始化函数"""        self.head = Node(None)        self.head.pointer = self.head        # 判断是否位空    '''需要判断头结点是否指向自身，从而确定是否为空'''def is_empty(self):        if self.head.pointer == self.head:        return True        # 针对空链表可返回None；针对非空链表即采用循环操作，结束条件当前位置是尾结点    def traversal(self):    """ 遍历链表"""    if self.is_empty():        return False    else:        counter = 1        current =self.head.pointer        # 当前指针不指向头结点时进行循环        while(current != self.head):            print(" Element {{ is {{ ".format(counter, current.data))            counter += 1            current = current.pointer        return True </code></pre><p>链表和顺序表的区别：<br>链表插入删除方便，修改查找不方便<br>顺序表修改和查找方便，插入删除不方便</p><blockquote><p>顺序结构：逻辑结构相邻，物理结构也相邻<br>​链式结构：逻辑相邻，物理不一定相邻</p></blockquote><hr><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>官方说法为：解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制</p><p>通俗的讲：</p><p>算法是特定解决问题的方法步骤</p></blockquote><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><ul><li>输入：有零个或多个输入</li><li>输出：有一个或多个输出</li><li>有穷性：有限的时间或有限的步骤可以结束算法</li><li>确定性：每个步骤只有唯一的意思，不会产生歧义</li><li>可行性：可用现有的条件可以实现</li></ul><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>时间复杂度:算法运行所需要的时间</li></ul><p>用大O表示法<br><code>list：pop()</code>删除末尾元素：O(1)<br>pop(0)删除第一个元素：O(n)<br>sort()排序：O(<code>nlogn</code>)<br>insert()插入元素 O(n)<br>append()末尾添加元素:O(1)<br>字典：<br>除了循环 复制 O(n)<br>删除、添加、修改、查询元素O(1)</p><ul><li>空间复杂度：算法运行所需要的空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫的相关知识</title>
      <link href="/posts/47227/"/>
      <url>/posts/47227/</url>
      
        <content type="html"><![CDATA[<h2 id="1-虚拟环境"><a href="#1-虚拟环境" class="headerlink" title="1.虚拟环境"></a>1.虚拟环境</h2><blockquote><p>虚拟环境就是一个隔离的python环境，不同的项目应该使用不同的虚拟环境(可以使用同一个虚拟环境)</p></blockquote><blockquote><p>虚拟环境不会导致环境之间的污染</p></blockquote><h4 id="1-1-虚拟环境管理模块"><a href="#1-1-虚拟环境管理模块" class="headerlink" title="1.1  虚拟环境管理模块"></a>1.1  虚拟环境管理模块</h4><p><code>virtualenvwrapper</code></p><p>安装</p><p><code>pip install virtualenvwrapper-win</code></p><p><code>virtualenvwrapper</code>的使用</p><p>查看所有虚拟环境：<code>lsvirtualenv</code></p><p>创建虚拟环境：<code>mkvirtualenv 环境名</code></p><p>激活虚拟环境：<code>workon 环境名</code></p><p>查看当前虚拟环境下的模块：</p><ol><li>进入当前虚拟环境</li><li>pip list</li></ol><p>退出虚拟环境:<code>deactivate</code></p><p>虚拟环境中安装模块:<code>pycharm</code>中,选中虚拟环境，然后添加模块,也可以通过<code>pip install</code>安装</p><p>删除虚拟环境：<code>rmvirtualenv 环境名</code></p><blockquote><p><code>pycharm</code>如果没有直接显示虚拟环境，则<br> settings中选解释器处<code>show all</code> ,加号添加，创建的虚拟环境在<br> <code>C:\Users\22742\Envs\</code>目录下，选中Scripts下的<code>python.exe</code></p></blockquote><h4 id="1-2-环境一致性"><a href="#1-2-环境一致性" class="headerlink" title="1.2  环境一致性"></a>1.2  环境一致性</h4><blockquote><p>保证开发与生产环境一致，需要将模块等同一致</p></blockquote><blockquote><p>在开发机的虚拟环境中，运行命令:<br>生成模块和其版本<code>pip freeze &gt; requirements.txt</code></p><p>将<code>requirements</code>中生成的模块版本进行安装<br><code>pip listall -r ./requirements.txt</code></p></blockquote><h4 id="1-3-查看包的详细信息"><a href="#1-3-查看包的详细信息" class="headerlink" title="1.3  查看包的详细信息"></a>1.3  查看包的详细信息</h4><p><code>pip show 包名</code></p><h4 id="1-4-打包"><a href="#1-4-打包" class="headerlink" title="1.4  打包"></a>1.4  打包</h4><p><code>pyinstall -F XXX.py</code></p><hr><h2 id="2-爬虫"><a href="#2-爬虫" class="headerlink" title="2.爬虫"></a>2.爬虫</h2><h4 id="2-1-爬虫的概念"><a href="#2-1-爬虫的概念" class="headerlink" title="2.1  爬虫的概念"></a>2.1  爬虫的概念</h4><blockquote><p>爬虫又称网页蜘蛛或者网页机器人</p><p>模拟人操作客户端，向服务器发起网络请求，抓取数据的自动化程序和脚本</p></blockquote><blockquote><p>通用爬虫是通过抓取数据实现检索服务</p></blockquote><blockquote><p>爬虫分为聚焦爬虫和通用爬虫</p><p>自动化，数据量较小时可以人工获取数据，但往往在公司中爬取的量都在百万级千万级，所以要程序自动化获取数据</p></blockquote><blockquote><p>B/S架构：<code>Browser</code>/<code>Server</code>，类似淘宝，没有第三方中转，客户端和服务器直接交互</p><p>C/S：<code>Client</code>/<code>server</code>，类似微信，将微信后端作为中转站，和其他人对话时，需要在中转站传话</p></blockquote><h5 id="2-1-1-pyinstaller"><a href="#2-1-1-pyinstaller" class="headerlink" title="2.1.1  pyinstaller"></a>2.1.1  <code>pyinstaller</code></h5><p><code>pyinstaller</code>可以将python文件编译成一个程序，类似go语言的编译</p><h4 id="2-2-通用爬虫"><a href="#2-2-通用爬虫" class="headerlink" title="2.2  通用爬虫"></a>2.2  通用爬虫</h4><p>百度，360，搜狐等搜索引擎</p><p>原理：</p><ol><li>抓取网页</li><li>采集数据</li><li>数据处理</li><li>提供检索服务</li></ol><p>通用爬虫抓取新网站的方式</p><ol><li>主动提交<code>url</code></li><li>设置友情连接</li><li>百度会和<code>DNS</code>服务商合作，抓取新网站</li></ol><p>检索排名:</p><ol><li>竞价排名</li><li>根据<code>PageRank</code>值，访问量、点击量   (<code>SEO</code>)</li></ol><h4 id="2-3-robots协议"><a href="#2-3-robots协议" class="headerlink" title="2.3  robots协议"></a>2.3  robots协议</h4><p><code>robots.txt</code>:如果不想让百度爬取，可以编写<code>robots.txt</code>,这个协议只是口头上的协议，自己写的爬虫程序<strong>不需要遵从</strong></p><h4 id="2-4-聚焦爬虫"><a href="#2-4-聚焦爬虫" class="headerlink" title="2.4  聚焦爬虫"></a>2.4  聚焦爬虫</h4><blockquote><p>根据特定的需求，抓取指定的数据</p></blockquote><p>思路：</p><blockquote><p>代替浏览器上网</p><ol><li><code>url</code>，发起请求，获取响应</li><li>解析内容，提取数据</li><li>将数据存储到本地，数据持久化</li></ol></blockquote><h2 id="2-5-requests模块"><a href="#2-5-requests模块" class="headerlink" title="2.5  requests模块"></a>2.5  requests模块</h2><pre class="language-python" data-language="python"><code class="language-python">#导包import requestsurl = '*****'#res是获取的响应数据res = requests.get(url)</code></pre><pre class="language-python" data-language="python"><code class="language-python">#响应数据的获取方式1.文本形式：res.text2.json形式：res.json()3.流形式：res.content</code></pre><pre class="language-python" data-language="python"><code class="language-python">#数据持久化(mysql入库)#1.导包import pymysql#2.创建链接conn = pymysql.connect(host='127.0.0.1',port=3306,user='root',password='root',charset='utf8',database='***')#3.创建游标cursor = conn.cursor()#4.构造sql语句sql  = 'insert into *** values(数据)'#5.执行sql语句try:    cursor.execute(sql)    #提交事务    conn.commit()except Exception as e:    print(e)    #回滚    conn.rollback()</code></pre><p><code>params</code>参数</p><blockquote><p>get方式传参的拼接，将参数拼接到目标<code>url</code>中</p></blockquote><h4 id="2-6-OSI七层模型"><a href="#2-6-OSI七层模型" class="headerlink" title="2.6  OSI七层模型"></a>2.6  <code>OSI</code>七层模型</h4><p>应用层：</p><pre class="language-none"><code class="language-none">https/http/ftphttp协议：明文传输，端口80https协议：加密传输，端口443</code></pre><p>表示层</p><p>会话层</p><p>传输层：<code>UDP/TCP</code></p><p>网络层：<code>IP</code></p><p>数据链路层：<code>ARP</code></p><p>物理层：<strong>以太网协议</strong></p><h4 id="2-7-TCP-IP五层模型"><a href="#2-7-TCP-IP五层模型" class="headerlink" title="2.7  TCP/IP五层模型"></a>2.7  <code>TCP/IP</code>五层模型</h4><p>应用层：<code>https/http/ftp/ssh/Sftp/</code></p><p>传输层：<code>UDP/TCP</code></p><p>网络层：<code>IP</code></p><p>数据链路层：<code>ARP</code></p><p>物理层：<strong>以太网协议</strong></p><h4 id="2-8-TCP和UDP"><a href="#2-8-TCP和UDP" class="headerlink" title="2.8 TCP和UDP"></a>2.8 <code>TCP</code>和<code>UDP</code></h4><p>TCP协议是一种面向连接的，可靠的，基于字节流的传输通信协议</p><ol><li>有序性：数据包编号，判断数据包的正确次序</li><li>正确性：使用checksum函数检查数据包是否损坏，发送和接收时都会计算<strong>校验和</strong></li><li>可靠性：发送端由超时重发，并有确认机制识别错误和数据的丢失</li><li>可控性：<strong>滑动窗口协议</strong>与<strong>拥塞控制算法</strong>控制数据包的发送速度</li></ol><p><code>UDP</code>协议是用户数据报协议，面向无连接的传输层协议，传输<code>相对于TCP</code>来说，不可靠</p><ol><li>无连接：数据可能丢失或损坏</li><li>报文小，传输速度快</li><li>吞吐量大的网络传输，可以在一定成都上承受数据丢失</li></ol><h4 id="2-9-ARP协议"><a href="#2-9-ARP协议" class="headerlink" title="2.9  ARP协议"></a>2.9  <code>ARP</code>协议</h4><p>通过<code>IP</code>获取目标计算机的mac地址的协议</p><blockquote><p>交换机不能识别<code>IP</code>地址</p></blockquote><h5 id="2-9-1-ssh"><a href="#2-9-1-ssh" class="headerlink" title="2.9.1  ssh"></a>2.9.1  ssh</h5><blockquote><p>远程登录会话</p></blockquote><h5 id="2-9-2-服务器创建的默认端口"><a href="#2-9-2-服务器创建的默认端口" class="headerlink" title="2.9.2  服务器创建的默认端口"></a>2.9.2  服务器创建的默认端口</h5><pre class="language-none"><code class="language-none">ftp:21ssh:22mySQL:3306MongoDB:27017Redis:6379</code></pre><h5 id="2-9-3-http与HTTPS协议的区别"><a href="#2-9-3-http与HTTPS协议的区别" class="headerlink" title="2.9.3  http与HTTPS协议的区别"></a>2.9.3  <code>http</code>与<code>HTTPS</code>协议的区别</h5><ol><li><code>https</code>协议需要到ca申请证书，因而需要一定费用，现阶段国内各大厂商也提供免费的证书</li><li><code>http</code>是超文本传输协议，信息是铭文传输，<code>https</code>则是具有安全性的<code>ssl</code>加密传输协议</li><li><code>http</code>和<code>https</code>使用的是完全不同的连接方式，端口号也不一样,前者是80，后者是443</li><li><code>http</code>的连接很简单，是无状态的，<code>https</code>协议是由<code>ssl+http</code>协议构建的可进行加密传输，身份认证的网络协议，比<code>http</code>协议安全(尽管<code>HTTPS</code>安全，但是传输的效率没有<code>http</code>高)</li></ol><hr><h2 id="3-请求"><a href="#3-请求" class="headerlink" title="3.请求"></a>3.请求</h2><p>url:请求的网址，即<strong>统一资源定位符</strong>，它可以唯一确定我门向请求的资源</p><h4 id="3-1-请求过程"><a href="#3-1-请求过程" class="headerlink" title="3.1  请求过程"></a>3.1  请求过程</h4><blockquote><p>客户端，通常指(web浏览器或<code>APP</code>)向服务器发起请求，服务器接收到的请求进行处理，并向客户端发起响应</p></blockquote><blockquote><p>请求由客户端向服务器发出的，可以分为四部分：请求方法(<code>Request Method</code>),请求网址(<code>Request.URL</code>),请求头(<code>Request Headers</code>) 请求体(<code>Request Body</code>)</p></blockquote><h4 id="3-2-请求方法"><a href="#3-2-请求方法" class="headerlink" title="3.2  请求方法"></a>3.2  请求方法</h4><p>常见的有八种</p><pre class="language-none"><code class="language-none">GET：请求页面，并返回内容POST：用于提交表单数据或者文件等，数据包含在请求体中PUT：从客户端向服务器传送的数据取代指定文档中的内容DELETE：请求服务器删除指定的页面HEAD：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取头CONNECT：把服务器当跳板，让服务器代替客户端访问其他网页OPTIONS：允许客户端查看服务器的性能TRACE：会回显服务器收到的请求，主要用于测试或诊断</code></pre><blockquote><p>GET和POST请求的区别</p><ol><li>GET请求中的参数包含在URL里，数据可以在URL中看到，而POST请求的URL一般不会包含这些数据</li><li>GET请求提交的数据最多只有1024字节，而POST方法没有限制</li><li>POST比 GET<strong>相对安全</strong></li></ol></blockquote><h4 id="3-3-请求头和请求体"><a href="#3-3-请求头和请求体" class="headerlink" title="3.3  请求头和请求体"></a>3.3  请求头和请求体</h4><p>Accept：请求报头域，用于指定客户端可接收哪些类型的信息</p><p>Cookie：页常用复数形式<code>Cookies</code>，这是网站为了辨别用户进行会话跟踪而存在用户本地的数据，它的主要功能时维持当前访问会话，cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上cookies并将其发送给服务器，服务器通过cookies识别出是我们自己，并且查出当前是登录状态，所以返回的数据是登录之后网页内容</p><p><code>Referer</code>:此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如来源统计，防盗链处理等</p><p>User-Agent：简称UA，它是一个页数的字段串头，可以使服务器识别客户使用的操作系统及版本，浏览器及版本等信息，做爬虫时加上此信息，可以伪装浏览器</p><p>x-requested-with：<code>XMHttpRequest</code>  代表ajax请求</p><p>Accept-Language：指定客户端可接受的语言类型</p><p>Accept-Encoding：指定客户端可接受的内容编码</p><p>Content-type：也叫互联网媒体类型(Internet Media Type)或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息,例：text/html代表HTML格式，image/<code>gif</code>代表<code>GIF</code>图片，<code>application/json</code>代表JSON类型</p><blockquote><p>请求体一般承载的内容时POST请求中的表单数据，GET请求没有请求体，为空</p></blockquote><h4 id="3-4-反爬机制与反反爬策略"><a href="#3-4-反爬机制与反反爬策略" class="headerlink" title="3.4  反爬机制与反反爬策略"></a>3.4  反爬机制与反反爬策略</h4><pre class="language-python" data-language="python"><code class="language-python">#反爬机制：为了不让数据泄露，设置了各种阻碍，这就是反爬机制#反反爬策略针对网站的反爬机制，采取不同策略1.脚本：直接忽略2.scrapy框架：修改配置文件，让爬虫不遵守robots协议</code></pre><hr><h2 id="4-响应"><a href="#4-响应" class="headerlink" title="4.响应"></a>4.响应</h2><blockquote><p>响应是由服务端返回给客户端的，可 以分为三部分：响应状态码，响应头，响应体</p></blockquote><blockquote><p>响应体，响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的HTML代码，我们要爬虫请求网页后，要解析的内容就是响应体</p></blockquote><h4 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h4><pre class="language-none"><code class="language-none">200：成功301：永久重定向302：临时重定向400：错误的请求401：未授权403：服务器拒绝此请求404：未找到500：服务器内部错误501：服务器不具备完成请求的功能502：错误的网关，服务器走位网关或代理，从上游服务器收到无效响应504：网关超时，服务器作为网关或代理，但是没有及时从上游服务器收到请求505：HTTP版本不支持</code></pre><blockquote><p>状态码不能完全代表相应状态，部分网站的状态码是自定义的，一切以响应数据为准</p></blockquote><h4 id="4-1-响应数据的几种形式"><a href="#4-1-响应数据的几种形式" class="headerlink" title="4.1  响应数据的几种形式"></a>4.1  响应数据的几种形式</h4><pre class="language-python" data-language="python"><code class="language-python">res = requests.get(url='https://www.guidaye.com/cp/')res.text &gt;&gt;&gt;将响应对象转化为str类型res.json()  &gt;&gt;&gt; 将响应对象转化为python中的dict类型，形式(类json)res.content  &gt;&gt;&gt;流形式(数据流，图片就是流形式)</code></pre><blockquote><p>如果响应数据中文乱码，可以用<code>content.decode('utf-8')</code>来解决</p></blockquote><h4 id="4-2-uuid"><a href="#4-2-uuid" class="headerlink" title="4.2  uuid"></a>4.2  uuid</h4><blockquote><p>通用唯一标识符，时间戳，命名空间，随机数，伪随机数来保证生成ID的唯一性</p><p>python的<code>uuid</code>模块提供<code>UUID</code>类和函数<code>uuid1()</code>, <code>uuid3()</code>,<code> uuid4()</code>,<code> uuid5()</code> 来生成1, 3, 4, 5各个版本的<code>UUID</code><br>( 需要注意的是: python中没有**<code>uuid2()</code>**这个函数)</p></blockquote><pre class="language-none"><code class="language-none">uuid1：基于时间戳uuid3：基于名字的MD5散列值uuid4：基于随机数，有一定重复概率uuid5：基于名字的SHA=1散列值</code></pre><hr><h2 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5.正则表达式"></a>5.正则表达式</h2><h4 id="5-1-元字符"><a href="#5-1-元字符" class="headerlink" title="5.1  元字符"></a>5.1  元字符</h4><pre class="language-python" data-language="python"><code class="language-python">.:任意字符，换行符除外\d:任意数字\w:任意数字字母下划线\s:空白符#如果是大写的s，w，d，代表'非'</code></pre><h4 id="5-2-字符组"><a href="#5-2-字符组" class="headerlink" title="5.2  字符组"></a>5.2  字符组</h4><pre class="language-python" data-language="python"><code class="language-python">[a-z]:[A-Z]:[0-9]:[^...]#匹配非其中元素，举例：[^abc]---&gt;匹配除了abc之外的字符</code></pre><h4 id="5-3-量词"><a href="#5-3-量词" class="headerlink" title="5.3  量词"></a>5.3  量词</h4><pre class="language-python" data-language="python"><code class="language-python">*:匹配0次或多次+:匹配1次或多次?:匹配0次或1次  #非贪婪匹配{m}:m次{m,}:至少m次{m,n}:m-n次{,n}:最多n次</code></pre><h4 id="5-4-边界修饰"><a href="#5-4-边界修饰" class="headerlink" title="5.4   边界修饰"></a>5.4   边界修饰</h4><blockquote><p>^匹配开始</p><p>$匹配结尾</p></blockquote><h4 id="5-5-分组"><a href="#5-5-分组" class="headerlink" title="5.5   分组"></a>5.5   分组</h4><pre class="language-python" data-language="python"><code class="language-python">import res = "&lt;a href='asdsdjfiohssdbfkjsdbkjsd'&gt;"res = re.findall(r"href='(.*?)'&gt;",s)</code></pre><h4 id="5-6-贪婪与非贪婪"><a href="#5-6-贪婪与非贪婪" class="headerlink" title="5.6  贪婪与非贪婪"></a>5.6  贪婪与非贪婪</h4><blockquote><p>贪婪，尽可能多的匹配</p><p>非贪婪，尽可能往少了匹配</p></blockquote><h4 id="5-7-re"><a href="#5-7-re" class="headerlink" title="5.7  re"></a>5.7  re</h4><p><code>re.findall(r'正则表达式','str')</code>,结果是一个列表，匹配整个字符串</p><p><code>re.search(r'正则表达式','str')</code>匹配到第一个结果就返回，返回的是一个对象，使用<code>group</code>取值</p><p><code>re.match(r'正则表达式','str')</code>从字符串开始进行匹配，返回一个对象，使用<code>group</code>取值，如果未匹配到，返回None </p><p><code>re.complie</code>将正则表达式编译为<strong>对象</strong>，在需要按正则表达式匹配是可以在直接使用该对象调用以上方法</p><hr><h2 id="6-requests高阶应用"><a href="#6-requests高阶应用" class="headerlink" title="6. requests高阶应用"></a>6. requests高阶应用</h2><h4 id="6-1-文件处理"><a href="#6-1-文件处理" class="headerlink" title="6.1  文件处理"></a>6.1  文件处理</h4><pre class="language-python" data-language="python"><code class="language-python">import requests#打开文件，注意要以rb形式打开f = open('chn.jpg','rb')files = {    'file':f}res = requests.post(url='***',files = files)</code></pre><blockquote><p>文件也是一种数据，所以，可以通过<code>files</code>参数来进行文件的上传</p></blockquote><h4 id="6-2-会话维持"><a href="#6-2-会话维持" class="headerlink" title="6.2  会话维持"></a>6.2  会话维持</h4><pre class="language-python" data-language="python"><code class="language-python">from requests import Session#1.实例化一个对象session = Session()#2.urlurl = '*****'#3.session.get()或者session.post(url=url.headers=headers)res = session.post(url=url.headers=headers)</code></pre><h4 id="6-3-ssl证书验证"><a href="#6-3-ssl证书验证" class="headerlink" title="6.3  ssl证书验证"></a>6.3  <code>ssl</code>证书验证</h4><p><code>https</code>是<code>http</code>的安全版本，<code>HTTPS</code>在<code>http</code>的基础上多了一个<code>ssl</code>安全套接层</p><blockquote><p>requests提供了证书验证的功能，当发起HTTP请求时，模块会检查<code>SSL</code>证书，但检查的行为可以用verify参数来控制</p></blockquote><p>添加了一个参数<code>verify=false   ---&gt;不检查ssl证书</code>,如果等于<code>True</code>，则检查<code>SSL</code>证书</p><pre class="language-python" data-language="python"><code class="language-python">#ssl证书验证#添加一个verify=false参数，禁止证书验证import requestsurl = '******'#阻止抛出警告requests.packages.urllib3.disable_warinings()res = requests.get(url=url,verify=false)</code></pre><blockquote><p>简单来说，在爬取网站时，有可能网站的证书是有问题的，这时如果使用<code>requests</code>模块去请求时，会报错，所以需要<code>ssl</code>证书验证</p></blockquote><h4 id="6-4-代理设置"><a href="#6-4-代理设置" class="headerlink" title="6.4  代理设置"></a>6.4  代理设置</h4><blockquote><p>代理<code>IP</code>是指在请求的过程中使用非本机<code>ip</code>进行请求，避免大数据量频繁请求的过程中出现<code>IP</code>封禁，限制数据的爬取</p></blockquote><p>透明代理<code>ip</code>：服务器知道你使用了代理，服务器能够获取爬虫真实的<code>ip</code></p><p>匿名代理<code>ip</code>：服务器知道你使用了代理，服务器不能获取爬虫真实的<code>ip</code></p><p>高匿代理<code>ip</code>：服务器不知道使用了代理，服务器不能获取爬虫真实<code>ip</code></p><blockquote><p>代理类别：基于接口的，基于隧道的</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">反爬：ip封禁---&gt;使用代理ipimport requestsurl = '*********'proxies = {    #或者是https    'http':'http://ip地址:端口号',    #无论是http还是https，后面一定是http    'https':'http://ip地址:端口号'}res = requests.get(url=url,proxies = proxies)</code></pre><h4 id="6-5-超时设置"><a href="#6-5-超时设置" class="headerlink" title="6.5  超时设置"></a>6.5  超时设置</h4><p>添加了一个参数，以<strong>秒</strong>计量<code>timeout=0.1</code></p><pre class="language-python" data-language="python"><code class="language-python">#添加timeout参数，秒数import requestsres=requests.get(url=url,timeout=0.1)</code></pre><blockquote><p>给予爬虫与服务器连接的时间限定，设置一个时间，在指定的时间内完成了正常的连接，不报错，如果没有完成，就会报错</p><p>requests模块发送请求可以设置超时时间，在超时时间内未得到响应，便会抛出异常</p><p>好处：一方面减少了请求的阻塞时间，一方面，可以进行异常处理，执行相应的操作</p></blockquote><blockquote><p>如果规定时间完成了和服务器连接，之后爬取数据的时间并不算在超时设置的时间内</p></blockquote><h4 id="6-6-UA检测"><a href="#6-6-UA检测" class="headerlink" title="6.6  UA检测"></a>6.6  <code>UA</code>检测</h4><p><code>UA</code>是用户的身份表示，可以表示用户的系统及浏览器信息</p><blockquote><p>在请求过程中，添加headers参数</p></blockquote><h4 id="6-7-cookie的处理-session"><a href="#6-7-cookie的处理-session" class="headerlink" title="6.7  cookie的处理(session)"></a>6.7  cookie的处理(session)</h4><blockquote><p>在同一个关联网页中，为了保存登录状态和各种信息，可以通过cookie来保持</p></blockquote><blockquote><p>三种方法</p><ol><li>手动在headers中添加cookie的键值对</li><li><code>cookiejar</code>对象</li><li>自动封装cookie的类：<code>Session</code></li></ol></blockquote><pre class="language-python" data-language="python"><code class="language-python">#cookie的处理#1.url = 'https://www.baidu.com/'        headers = {            'Cookie':'BIDUPSID=B63BDB40304991E9FF3159864CC9C302; PSTM=1586308511; BAIDUID=B63BDB40304991E9CC4E4ECFFCFFB23D:FG=1; BD_UPN=12314753; BDUSS=VWNmZu',            'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36'        }        res = requests.get(url=url,headers=headers)            #2.cookiejar对象    from requests.cookies import RequestCookieJar   1.首先需要获取Cookies    Cookie = ***********    2.实例化一个jar对象    jar = RequestsCookieJar()    3.处理Cookies，封装进jar对象中    for i in Cookie.split(','):        #再次分割，分成dict的键值，每分割一次添加一次        k,v = i.split('=',1)        jar.set(k,v)        #3.Session类，会话维持    from requests import Session    1.实例化一个对象    session = Session()    2.url    url = '*****'    3.session.get()或者session.post(url=url.headers=headers)    res = session.post(url=url.headers=headers)</code></pre><pre class="language-python" data-language="python"><code class="language-python">from requests import Sessionsession = Session()data = {    'username':"天听",    'password':'123456'}res = session.post(url=url,headers=headers,data=data)</code></pre><hr><h2 id="7-lxm库"><a href="#7-lxm库" class="headerlink" title="7.lxm库"></a>7.<code>lxm</code>库</h2><blockquote><p>从响应数据中抽取出目标数据的过程，就叫做数据解析<br>数据解析：<br><code>re</code>,<code>xpath</code>,<code>BS4</code>,<code>Pyquery</code></p></blockquote><blockquote><p>DOM树与<code>xpath</code>解析原理</p><p>HTML页面标签存在层级关系，即DOM树，在获取目标数据时可以根据网页层级关系定位标签，再获取标签的文本或属性</p><p><code>xpath</code>解析原理：根据DOM节点的结构关系，进行定位</p></blockquote><h4 id="7-1-xpath基本语法"><a href="#7-1-xpath基本语法" class="headerlink" title="7.1  xpath基本语法"></a>7.1  <code>xpath</code>基本语法</h4><p><code>.</code>:当前节点</p><p><code>/</code>:根节点</p><p><code>//</code>:代表任意位置</p><p><code>.//</code>:从当前节点向下的任意位置匹配</p><p><code>nodename</code>:<strong>节点名</strong>定位</p><p><code>nodename[@attribute='value']</code>:根据节点的属性进行定位</p><p><code>@attribue</code>：获取节点的属性值，比如获取a标签的<code>href</code>属性，直接可以<code>/a/@href</code></p><p><code>text()</code>:获取节点的文本<br><code>//div[@class='asdds']/p/text()</code></p><h4 id="7-2-属性匹配"><a href="#7-2-属性匹配" class="headerlink" title="7.2  属性匹配"></a>7.2  属性匹配</h4><ul><li><p>单属性多值匹配：当节点的一个属性有多个值时，根据其中一个进行定位，使用<code>contai ns</code>函数</p><pre class="language-python" data-language="python"><code class="language-python">'//div[contains(@class,"属性值")]'</code></pre></li><li><p>多属性匹配：用节点的多个属性共同定位节点<code>and</code></p><pre class="language-python" data-language="python"><code class="language-python">'//div[@class="asds" and @name="adsadasd"]'</code></pre></li></ul><h4 id="7-3-按序选择"><a href="#7-3-按序选择" class="headerlink" title="7.3  按序选择"></a>7.3  按序选择</h4><ul><li><p>索引定位：[6] </p><blockquote><p><strong>注意，索引从1开始，跟python有区别</strong></p></blockquote></li><li><p>位置函数：<code>position</code><br>例：<code>/li[position()&gt;2]</code></p></li><li><p><code>last()</code>函数：定位最后一个，<code>last()-1</code>代表倒数第二个</p></li></ul><h4 id="7-4-流程"><a href="#7-4-流程" class="headerlink" title="7.4  流程"></a>7.4  流程</h4><p>加载本地<code>html</code>，需要有<code>etree.HTMLParser</code>参数，注意要加括号<br>例：<code>tree = etree.parser('./xpath.html',etree.HTMLParser())</code></p><p>加载网页<code>html</code>,直接使用HTML<br>例：<code>tree = etree.HTML()</code></p><p>然后些<code>xpath</code>语法<br><code>tree.xpath('//ul[@class="pli"]/li/div/a/img/@src')</code></p><p><code>xpath</code>获得的结果是一个列表2  </p><pre class="language-python" data-language="python"><code class="language-python">#编码流程from lxml import etreeres = requests.get(...)tree = etree.HTML(res.text) #etree加载的是响应数据的文本形式tree.xpath('xpath表达式')</code></pre><h4 id="7-5-补充"><a href="#7-5-补充" class="headerlink" title="7.5  补充"></a>7.5  补充</h4><pre class="language-python" data-language="python"><code class="language-python">res1 = tree.xpath("//div[@id='007']/text()")res2 = tree.xpath("//div[@id='007']//text()")'''res1展示的是以divid007为根节点的结果，其div下的其他标签不显示res2展示的是以divid007任意位置的结果，其div下的其他标签内容也一同显示'''</code></pre><hr><h2 id="8-动态数据加载"><a href="#8-动态数据加载" class="headerlink" title="8.动态数据加载"></a>8.动态数据加载</h2><blockquote><p>网页HTML上，有些数据是通过<code>js</code>代码填充，所以如果直接使用爬虫，只会爬取到一个标签，并没有其中的元素</p><p>requests模块和<code>scrapy</code>框架在发起请求爬取数据的过程中，不能执行<code>js</code>代码</p></blockquote><h4 id="8-1-selenium"><a href="#8-1-selenium" class="headerlink" title="8.1  selenium"></a>8.1  selenium</h4><blockquote><p>selenium是一个web端自动化测试框架，可以通过代码来控制浏览器，比如打开关闭，点击等行为</p><p>作用：帮助抓取动态加载的数据，避免反爬</p></blockquote><h4 id="8-2-selenium安装与配置与操作"><a href="#8-2-selenium安装与配置与操作" class="headerlink" title="8.2  selenium安装与配置与操作"></a>8.2  selenium安装与配置与操作</h4><blockquote><ol><li><code>Chrome</code>浏览器</li><li><code>selenium</code>框架：<code>pip install selenium</code></li></ol><p>3.驱动程序：下载<br>   <code>http://npm.taobao.org/mirrors/chromedriver/</code><br>   查看浏览器版本<br>   选择对应的版本</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">编码流程：#首先需要将下载的chromedriver.exe放到代码文件夹下    #导包    from seleniumi import webdriver            #调用chromedriver.exe    bro = webdriver.Chrome('./chromedriver.exe')        #访问    bro.get('https://www.iqiyi.com/')        #获取网页源代码(对象)bro.page_source   ---&gt;字符串</code></pre><pre class="language-python" data-language="python"><code class="language-python">#如何获取网页的元素#根据标签内属性定位，一般用id定位find_element_by_id('id')find_element_by_name('name')find_element_by_class_name('class')#根据class属性定位find_element_by_xpath()#根据xpath定位节点find_element_by_css_selector()#css选择器find_element_by_link_text()#根据超链接文本定位find_element_by_partial_link_text()#根据超链接文本的一部分定位#执行js脚本execute_script(js)#节点交互操作：1.输入内容：对象.send_keys()2.清空内容：对象.clear()3.点击操作：对象.click()4.退出浏览器：对象.quit()#获取网页的数据获取元素属性：get_attribute()获取元素文本：get_text()获取元素位置：element.location获取元素尺寸：element.size获取网页源码：browser.page_source(*****)#执行js脚本js = 'window.scrollTo(0,300)'#向下滚动300距离js = 'window.scrollTo(0,document.body.scrollHeight)'#滚动到底部对象.execute_script(js)</code></pre><h4 id="iframe标签跳转"><a href="#iframe标签跳转" class="headerlink" title="iframe标签跳转"></a><code>iframe</code>标签跳转</h4><p><code>switch_to.frname('frameid')</code></p><p><code>switch_to.default_content()</code></p><p>实例：</p><pre class="language-python" data-language="python"><code class="language-python">from selenium import webdriverfrom time import sleepfrom selenium.webdriver.chrome.options import Optionsoptions = Options()options.add_experimental_option('excludeSwitches',['enable-automation'])#调用chromedriver.exebro = webdriver.Chrome('./chromedriver.exe',options=options)bro.get('https://www.baidu.com/')#根据id--&gt;kw获取input输入框input_tag = bro.find_element_by_id('kw')#根据id--&gt;su获取百度一下点击按钮button_baidu = bro.find_element_by_id('su')#输入框输入input_tag.send_keys('黑洞')#点击button_baidu.click()#睡眠两秒之后清空输入框sleep(2)input_tag.clear()input_tag.send_keys('抖动')button_baidu.click()sleep(3)input_tag.clear()input_tag.send_keys('翻转')button_baidu.click()sleep(3)input_tag.clear()bro.quit()</code></pre><h4 id="8-3-子级页面和父级页面"><a href="#8-3-子级页面和父级页面" class="headerlink" title="8.3  子级页面和父级页面"></a>8.3  子级页面和父级页面</h4><blockquote><p>HTML页面嵌套另一个HTML页面</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">#子页面的跳转switch_to.frame('id')#跳转到父级页面switch_to_default.conent()</code></pre><blockquote><p>注意，selenium默认操作父级页面</p></blockquote><h4 id="8-4-防检测"><a href="#8-4-防检测" class="headerlink" title="8.4  防检测"></a>8.4  防检测</h4><pre class="language-python" data-language="python"><code class="language-python">from selenium.webdriver.chrome.options import Optionsoptions = Options()options.add_experimental_option('excludeSwitches',['enable-automation'])bro = webdriver.Chrome('./chromedriver.exe',options=options)</code></pre><hr><h2 id="9-多线程爬虫"><a href="#9-多线程爬虫" class="headerlink" title="9.多线程爬虫"></a>9.多线程爬虫</h2><blockquote><p>在爬取数据量大的数据时，耗费时间较长，为了提高效率，可采用多线程爬虫，提高效率，但是，多线程不是原子性，操纵数据可能会导致数据紊乱，不安全</p></blockquote><h4 id="9-1-并发与并行"><a href="#9-1-并发与并行" class="headerlink" title="9.1  并发与并行"></a>9.1  并发与并行</h4><blockquote><p>并行：在同一时刻，多个任务同时执行</p><p>并发：在同一时间段内，多个任务同时执行<br>并发时，一般采用了时间片轮转法，即在一个时间段内，给每个程序添加一个时间片，也可以叫做进度条，进度条走完，下一个程序再继续运行，不过时间片轮转时，停顿时间非常的短，所以会造成多个任务同时运行的错误</p></blockquote><h4 id="9-2-示例"><a href="#9-2-示例" class="headerlink" title="9.2  示例"></a>9.2  示例</h4><pre class="language-python" data-language="python"><code class="language-python">from threading import Threadfrom queue import Queueimport requestsfrom lxml import etreeimport pymongofrom threading import Lock#负责爬取的类class SpiderThread(Thread):    def __init__(self, name, url_queue, data_queue):        super().__init__()        self.name = name        self.url_queue = url_queue        self.headers = {            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36'        }        self.data_queue = data_queue    def run(self):        base_url = 'http://xiaohua.zol.com.cn/lengxiaohua/%s.html'        while 1:            try:                page = self.url_queue.get(block=False)                print('%s正在爬取数据' % self.name )                res = requests.get(url=base_url % page, headers=self.headers)                self.data_queue.put(res.text)            except:                break#负责解析的类class ParseThread(Thread):    def __init__(self, name, data_queue, lock):        super().__init__()        self.name = name        self.data_queue = data_queue        self.lock = lock    def run(self):        # 调用解析方法        while 1:            try:                html = self.data_queue.get(block=False)                print('%s 正在解析数据' % self.name)                self.parse(html)            except:                break    def parse(self, html):        tree = etree.HTML(html)        li_list = tree.xpath('//li[@class="article-summary"]')        for li in li_list:            title = li.xpath('.//span[@class="article-title"]/a/text()')            content = ''.join(li.xpath('.//div[@class="summary-text"]//text()'))            if title and content:                data = {                    'title': title[0],                    'content': content                }                with self.lock:                    self.save(data)    def save(self, data):        # 简历连接        conn = pymongo.MongoClient()        db = conn.lilong        table = db.liuyueyang        table.insert_one(data)</code></pre><hr><h2 id="10-无头浏览器与BS4"><a href="#10-无头浏览器与BS4" class="headerlink" title="10.无头浏览器与BS4"></a>10.无头浏览器与<code>BS4</code></h2><h4 id="10-1-无头浏览器"><a href="#10-1-无头浏览器" class="headerlink" title="10.1  无头浏览器"></a>10.1  无头浏览器</h4><blockquote><p>什么是无头浏览器（headless browser），简单来说是一种<strong>没有界面</strong>的浏览器。既然是浏览器那么浏览器该有的东西它都应该有，只是看不到界面而已。我们日常使用浏览器的步骤为：启动浏览器、打开一个网页、进行交互。而无头浏览器指的是我们使用脚本来执行以上过程的浏览器，能模拟真实的浏览器使用场景。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from selenium import webdriverfrom selenium .webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument('--headless')chrome_options.add_argument('--dissble-gpu')bro = webdriver.Chrome(chrome_options = chrome_options)bro.get(******)print(bro.page_source)</code></pre><h4 id="10-2-BS4语法"><a href="#10-2-BS4语法" class="headerlink" title="10.2  BS4语法"></a>10.2  <code>BS4</code>语法</h4><blockquote><p>编码流程：</p><ol><li>导包<code>from bs4 import BeautifulSoup</code></li><li>实例化对象，传两个参数，一个文本，一个解析器，一般为<code>lxml</code><br><code>suop = BeautifulSoup(res.text,'lxml')</code></li><li>选择器解析</li></ol></blockquote><pre class="language-python" data-language="python"><code class="language-python">#bs4编码流程from bs4 import BeautifulSoupsuop = BeautifulSoup(res.text,'lxml')tag = soup.select('css选择器表达式')tag = soup.节点() #节点选择器tag = soup.findall() # 方法选择器</code></pre><pre class="language-python" data-language="python"><code class="language-python">#节点选择器from bs4 import BeautifulSoupsoup = BeautifulSoup(res.text,'lxml')tag = soup.a  #取a标签，只取一个</code></pre><pre class="language-python" data-language="python"><code class="language-python">#方法选择器find_all(name,attrs,text,limit):    soup.findall(name='***')  #根据节点名字定位    soup.findall(attrs={'属性名(scr,class等)':'值'})#根据属性定位，多个属性时，一个即可定位    soup.findall(text=res.compile(r'***'))#根据节点文本定位，返回文本    soup.findall(name='***',limit=2)#只返回两个结果    find(name,attrs,text,limit):区别于find_all，find返回的是一个对象结果    find_all(name=节点名,{attrs:属性值})返回的是一个列表</code></pre><pre class="language-python" data-language="python"><code class="language-python">#css选择器属性选择器：1.根据节点名定位标签：标签选择器soup.select('***(title,a,p等)')2.根据节点的class属性定位：css选择器soup.select('.***')3.根据id定位soup.select('#***')4.嵌套选择：ss = soup.select('ul')#得到的是一个列表for i in ss:    print(i.select("li"))5.层级选择器soup.select('div &gt; ul &gt; li') #单层级选择器，按照顺序找到直属lisoup.select('div li') #多层级选择器，包含了div下的所有li#获取节点的文本或属性obj.string:获取直接子文本，如果节点内有平行的节点，则结果是Noneobj.get_text()：获取子孙节点的所有文本obj['***(属性)']：获取节点属性</code></pre><hr><h2 id="11-快代理网站的模拟登录"><a href="#11-快代理网站的模拟登录" class="headerlink" title="11.快代理网站的模拟登录"></a>11.快代理网站的模拟登录</h2><pre class="language-python" data-language="python"><code class="language-python">from requests import Session#实例化session对象session = Session()#登录的urlurl = 'https://www.kuaidaili.com/login/'#构造数据data = {    'next': '',    'kf5_return_to': '',    'username': '2274201339@qq.com',    'passwd': 'o66.'}#浏览器头headers = {    "User-Agent":'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36'}#用post请求将数据传进去，此时，已经模拟了登录，访问这个网站的其他网页时，会保存登录状态res = session.post(url=url,headers=headers,data=data)#访问时，可以获得到返回的数据，用户名在其中，模拟登录完成ret = session.get(url='https://www.kuaidaili.com/api/checkuser/',headers=headers)print(ret.json())</code></pre><h4 id="11-1-第三方打码平台"><a href="#11-1-第三方打码平台" class="headerlink" title="11.1  第三方打码平台"></a>11.1  第三方打码平台</h4><blockquote><p>我们在模拟登录时，时常会遇到一些验证码代码无法准确的识别不同的验证码，这时，就用到了打码平台，它会将图片上的字符或者数字转成字符串返回给你</p></blockquote><blockquote><p>流程：</p><ol><li>下载验证码图片</li><li>传给第三方打码平台</li><li>进行识别，识别完成之后，传回<code>ret</code></li><li>把<code>ret</code>拿回，构造数据</li></ol></blockquote><blockquote><p>超级鹰平台</p></blockquote><h2 id="12-Scrapy框架"><a href="#12-Scrapy框架" class="headerlink" title="12.Scrapy框架"></a>12.<code>Scrapy</code>框架</h2><blockquote><p><code>scrapy</code>是基于<code>twisted</code>的异步框架</p></blockquote><h4 id="12-1-安装"><a href="#12-1-安装" class="headerlink" title="12.1  安装"></a>12.1  安装</h4><blockquote><p>首先需要安装相应的依赖库</p><p><code>lxml</code>、<code>wheel</code>、<code>pywin32</code></p><p><code>twisted</code>此依赖安装时，需要从<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted">地址</a>下载相应的版本,然后通过<code>pip</code>来安装</p></blockquote><blockquote><p>最后安装<code>scrapy</code>框架</p></blockquote><h4 id="12-2-创建项目"><a href="#12-2-创建项目" class="headerlink" title="12.2  创建项目"></a>12.2  创建项目</h4><blockquote><p>创建项目<br><code>scrapy startproject 项目名</code></p></blockquote><blockquote><p>创建爬虫文件<br><code>scrapy genspider 爬虫名 域名</code></p></blockquote><h4 id="12-3-运行项目"><a href="#12-3-运行项目" class="headerlink" title="12.3  运行项目"></a>12.3  运行项目</h4><p><code>scrapy  crawl 爬虫名</code></p><h4 id="12-4-项目基本架构"><a href="#12-4-项目基本架构" class="headerlink" title="12.4  项目基本架构"></a>12.4  项目基本架构</h4><p>└── <code>day01(A)</code>  外层项目目录<br>        └── <code>day01(A)</code>  内层项目目录<br>            └── <code>spiders</code>  放置爬虫的包<br>                └── <code>__init__.py</code><br>                └── <code>tianting.py</code>  爬虫文件   </p><p>​            └── <code>items.py</code>   定义要爬取的数据字段<br>​            └── <code>middlewares.py</code>  中间件<br>​            └── <code>piplines.py</code>  管道<br>​            └── <code>settings.py</code>  配置文件(爬虫配置)<br>​        └── <code>scrapy.cfg</code>  配置文件,跟部署相关</p><h4 id="12-5-核心组件与数据流向"><a href="#12-5-核心组件与数据流向" class="headerlink" title="12.5  核心组件与数据流向"></a>12.5  核心组件与数据流向</h4><h5 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h5><blockquote><p>五大核心组件</p><p>1.引擎(<code>Scrapy Engine</code>)：<br>整个框架的调度，负责各个组件之间的通信与数据的传递</p><p>2.爬虫(<code>Spiders</code>)：<br>定义爬取行为和解析规则</p><p>3.调度器(<code>Scheduler</code>)：<br>负责调度所有请求</p><p>4.下载器(<code>Downloader</code>)：<br>负责爬取页面(与互联网交互，爬取页面的)</p><p>5.管道(<code>Item Pipeline</code>)：<br>负责数据持久化</p></blockquote><blockquote><p>由于引擎负责各个组件之间的调度，所以，所有的组件在相互传递时，都需要经过引擎，比如，爬虫解析后需要将<code>req</code>给引擎，然后引擎再给调度器，<strong>注意</strong>，此时，调度器<strong>无法</strong>越过引擎去直接调用下载器，所以，需要将<code>req</code>再次返回给引擎，由引擎来调度下载器和互联网交互</p></blockquote><h5 id="数据流向"><a href="#数据流向" class="headerlink" title="数据流向"></a>数据流向</h5><blockquote><p>依据请求的生命周期</p></blockquote><p>​                【调度器】</p><p>​                    ↑        ↓<br>​                <code>2.req  3.req  4.req</code></p><p>【管道】    【引擎】        →    【下载器】 <code>5.req</code>    → <code>internet</code><br>                                ←<code>7.res</code>            ←<code>6.res</code>    </p><p>​                        ↑      ↓<br>​                    <code>1.req  8.res</code></p><p>​                【爬虫】</p><blockquote><p>9.爬虫经过引擎到达管道 </p></blockquote><h4 id="12-6-组件分析"><a href="#12-6-组件分析" class="headerlink" title="12.6   组件分析"></a>12.6   组件分析</h4><ul><li><p>爬虫组件</p></li><li><blockquote><p><code>xpath</code>选择器，<code>extract_first</code>返回第一个数据，如果不加<code>first</code>，则是返回所有数据</p></blockquote></li></ul><blockquote><p><code>scrapy.Spider</code>:Spider爬虫类，自建的爬虫类必须继承这个</p><p>将数据item在组件中传递，<strong>注意</strong>不是return，而是<code>yield</code></p></blockquote><blockquote><p>实例化item,两种方法，一种是实例化对象，另一种是直接<code>yield 类名(字段名=值)</code></p></blockquote><pre class="language-python" data-language="python"><code class="language-python">class BlogSpider(scrapy.Spider):    #爬虫名，爬虫唯一的身份标识，不可重复    name = 'blog'    #域名的限定，限制了爬虫的范围，可以注释    # allowed_domains = ['baidu.com']    #起始url，当项目启动，自动对这个url发起请求    start_urls = ['http://baidu.com/']    #parse是默认的解析回调方法，如果发送一个请求，未指定回调解析，默认调用parse    def parse(self,response):        li_list = response.xpath('//ul[@id="menu-list"]/li')        for li in li_list:            item = Test01Item()            #名字            item['title'] = li.xpath('.//h2/a/@title').extract_first()            #简介            item['brief'] = ''.join(li.xpath('./text()').extract()).replace('\n','')            #时间            item['date'] = re.findall(r'\d+-\d+-\d+', li.xpath('.//p/text()').extract_first())[0]            #链接            item['link'] = li.xpath('.//h2/a/@href').extract_first()            yield item                        #第二种实例化方法            yield Test01Item(title=title)</code></pre><ul><li>item</li></ul><blockquote><p>Item 是保存爬取数据的容器，它的使用方法和字典类似,Item 多了额外的保护机制，可以避免拼写错误或者定义字段错误。<br>建 <code>Item</code>需要继承<code> scrapy.Item</code>类，并且定义类型为<code> scrapy.Field</code>字段 </p></blockquote><blockquote><p>注意！！items只能够通过字典的方式进行访问和添加</p></blockquote><p>在爬虫组件中使用item容器，需要以下4步：</p><ol><li>导包，将items导入</li><li>实例化items中的类对象</li><li>通过键值对的字典形式将数据添加进items</li><li>通过yield将items返回</li></ol><pre class="language-python" data-language="python"><code class="language-python">class Test01Item(scrapy.Item):    title = scrapy.Field()    jianjie = scrapy.Field()    #爬虫组件中：item = Test01Item()            #名字item['title'] = li.xpath('.//h2/a/@title').extract_first()    #简介item['brief'] = ''.join(li.xpath('./text()').extract()).replace('\n','')    #时间item['date'] = re.findall(r'\d+-\d+-\d+', li.xpath('.//p/text()').extract_first())[0]    #链接item['link'] = li.xpath('.//h2/a/@href').extract_first()    yield item</code></pre><ul><li>管道(<code>pipelines</code>)</li></ul><blockquote><p>在管道中，主要实现数据的保存，在自定义类中，实现process_item方法，参数有item，spider</p></blockquote><blockquote><p>如果爬虫组件中，传出了item，那么就需要将item走过这个process_item方法</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">#数据库的连接conn = pymongo.MongoClient('localhost',27017)db = conn.Longtantable = db.ss#自定义类class TextPipline:#实现process_item方法,item就是爬虫组件中传来的item    def process_item(self,item,spider):        table.insert_one(dict(item))        return item</code></pre><ul><li>settings</li></ul><blockquote><p>需要修改的是<code>ROBOTSTXT_OBEY</code>,<code>UA</code>,</p><pre class="language-python" data-language="python"><code class="language-python">ITEM_PIPELINES = {   'test01.pipelines.TextPipline': 300,}</code></pre></blockquote><h4 id="12-7-保存数据"><a href="#12-7-保存数据" class="headerlink" title="12.7  保存数据"></a>12.7  保存数据</h4><p>保存到<code>json</code>中</p><pre class="language-python" data-language="python"><code class="language-python">scrapy crawl 爬虫名 -o blog_data.json</code></pre><blockquote><p>另外，也可以每一个Item输出一行<code>JSON</code>,输出后缀改为<code>jl</code>，命令:<code>scrapy crawl 爬虫名 -o blog_data.jl</code></p></blockquote><p>此外，输出还支持<code>csv、xml、pickle、marshal</code>，还支持了远程<code>ftp、s3</code>等输出</p><blockquote><p>注意，<code>ftp</code>输出需要正确配置用户名、密码、地址、输出路径，否则会报错</p></blockquote><h4 id="12-8-管道-Item-Pipline-的使用"><a href="#12-8-管道-Item-Pipline-的使用" class="headerlink" title="12.8  管道(Item Pipline)的使用"></a>12.8  管道(<code>Item Pipline</code>)的使用</h4><blockquote><p>注意，<code>pipline</code>是需要被注册的</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">1. 在settings中，解封或者重新在底下写上ITEM_PIPELINES = {   'test01.pipelines.TextPipline': 300,#项目名.pipelines.自定义的管道名:}# 300：代表着优先级，数字越小，代表着优先级越高</code></pre><blockquote><p>当<code>Item</code>生成后，它会自动被送到管道进行处理，我们常用管道来实现以下:</p><ul><li>清理HTML数据</li><li>验证爬取数据，检查爬取字段</li><li>查重并丢弃重复内容</li><li>将爬取结果保存到数据库中</li></ul></blockquote><pre class="language-python" data-language="python"><code class="language-python">class Test01Pipeline:    def process_item(self, item, spider):        return item</code></pre><h4 id="12-9-整体流程"><a href="#12-9-整体流程" class="headerlink" title="12.9  整体流程"></a>12.9  整体流程</h4><blockquote><ol><li>需要在items中，定义要爬取的字段</li><li>在爬虫组件中，定义要爬取的<code>url</code>和解析规则</li><li>在<code>settings</code>中，配置相关的参数</li><li>在<code>pipeline</code>中，自定义类,实现<code>process_item</code>方法<br>在爬虫组件生成的item，通过了<code>yield</code>传递到<code>process_item</code>方法中</li><li>将数据保存在<code>MongoDB、mysql</code>等数据库中,也可以将数据保存到<code>json</code>等文件里</li></ol></blockquote><h4 id="12-91-手动发送请求"><a href="#12-91-手动发送请求" class="headerlink" title="12.91  手动发送请求"></a>12.91  手动发送请求</h4><blockquote><p><code>srcapy</code>框架在启动时，会自动对起始<code>url</code>发起请求，是因为爬虫组件继承的<code>scrapy.Spider</code>实现了一个<code>start_requests</code>方法，所以，想要手动发送请求，需要自己在类中实现此方法，这样，便不会再自动继承父类的方法，而是从自己类中实现方法</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">#手动发送get请求#callback参数，是指定回调，如果不指定此参数，就会默认回调到parseyield scrapy.Request(url=url,callback=self.parse)#手动发送post请求yield scrapy.FormRequest(url=next_page,formdata=data)</code></pre><h4 id="12-92-中间件"><a href="#12-92-中间件" class="headerlink" title="12.92  中间件"></a>12.92  中间件</h4><h5 id="篡改UA"><a href="#篡改UA" class="headerlink" title="篡改UA"></a>篡改<code>UA</code></h5><blockquote><p>需要用到的模块<code>fake-useragent</code>，用<code>pip</code>安装</p></blockquote> <pre class="language-python" data-language="python"><code class="language-python">#在middlewares中，TestIpUaDownloaderMiddleware下载器中间件中，#导包from fake_useragent import UserAgent#实例化对象ua = UserAgent()def process_request(self, request, spider):    request.headers['User-Agent'] = ua.random    return Noneua.random#生成的ua是随机的</code></pre><blockquote><p>注意，需要把<code>settings</code>中的<code>DOWNLOADER_MIDDLEWARES</code>打开</p></blockquote><h5 id="篡改ip"><a href="#篡改ip" class="headerlink" title="篡改ip"></a>篡改<code>ip</code></h5><pre class="language-python" data-language="python"><code class="language-python">def process_request(self, request, spider):    #篡改ip    request.meta['proxy'] = 'http://ip:port'    return None</code></pre><h5 id="selenium的使用"><a href="#selenium的使用" class="headerlink" title="selenium的使用"></a><code>selenium</code>的使用</h5><blockquote><ol><li>拦截res响应，在<code>process_response</code>方法中</li><li>使用<code>selenium</code>抓取数据</li><li>构建一个响应对象</li><li>替换原有的响应对象</li></ol></blockquote><blockquote><p>注意！如果在中间件中实例化对象，那么，每次请求都会实例化对象，比较耗费资源，所以，最好在爬虫组件中实例化</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">#爬虫组件中from selenium import webdriver#构建响应对象from scrapy.http import HttpResponsebro = webdriver.Chrome(executable_path='设置绝对路径')#中间件中，使用方法process_response自带的spider参数，从爬虫组件可以直接传过去bro = spider.brobro.get(url=response.url)#设置滚动一屏脚本js = 'window.scrollTo(0,document.body.scrollHeight)'#执行js脚本bro.execute_script(js)#网页源码html = bro.page_source#自己构建响应对象myres = HttpResponse(url=response.url,body=html,encoding='utf-8',request=request)#替换原来的响应对象return myres</code></pre><blockquote><p>根据需要添加判断是否使用<code>selenium</code></p></blockquote><h4 id="12-93-meta传值"><a href="#12-93-meta传值" class="headerlink" title="12.93  meta传值"></a>12.93  <code>meta</code>传值</h4><blockquote><p>在爬虫组件中，如果回调解析方法之间相互传值，可以使用<code>meta</code></p></blockquote><pre class="language-python" data-language="python"><code class="language-python">def parse(self,response):    ...    yield scrapy.Request(url=url,callback=self.da_parse,meta={'title':title})    def da_parse(self,response):    title = response.meta['title']</code></pre><h4 id="12-94-全站数据爬取"><a href="#12-94-全站数据爬取" class="headerlink" title="12.94   全站数据爬取"></a>12.94   全站数据爬取</h4><blockquote><p>全站数据爬取就是爬取多页时自动帮助翻页，省去了写代码的时间</p></blockquote><blockquote><p>创建爬虫文件时，在<code>genspider</code>后，添加<code>-t crawl</code>再添加爬虫名和域名，这样，爬虫会成为一个全站爬虫</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">#链接提取器，根据给定的规则进行链接的提起link = LinkExtractor(allow=r'Items/')    rules = (        #规则解析器，根据给定的规则解析数据，follow是递归提取页码，就是逐级访问url，对各个url来追踪访问        Rule(link,callback='parse_item', follow=True),    )</code></pre><h4 id="12-95-增量式爬虫"><a href="#12-95-增量式爬虫" class="headerlink" title="12.95  增量式爬虫"></a>12.95  增量式爬虫</h4><blockquote><p>增量式就是自写爬虫监控目标网站，如果目标有更新的数据，则将更新的数据爬取下来，已经爬取的数据，则通过去重的方式来忽略</p></blockquote><blockquote><p>而这其中，又分为两种去重方式，分别是根据<code>url</code>去重和数据指纹去重</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from redis import Redisconn = Redis('127.0.0.1',6379)def detail_parse(self,response):    name = li.xpath('//text()')    content = li.xpath('//text()')    #连起来生成指纹    data = name+content    fp = md5(data.encode('utf-8')).hexdigest()    #添加进redis的集合中    conn.sadd('ggsfp',fp)    #如果返回结果为0，则证明已经添加过，如果为1，则没有添加过</code></pre><p>对应<code>day14</code>视频</p><hr><h2 id="13-MongoDB数据库"><a href="#13-MongoDB数据库" class="headerlink" title="13.MongoDB数据库"></a>13.<code>MongoDB</code>数据库</h2><h4 id="13-1-数据库操作"><a href="#13-1-数据库操作" class="headerlink" title="13.1  数据库操作"></a>13.1  数据库操作</h4><blockquote><ol><li>创建数据库并切换至该数据库下<br><code>use 库名</code></li><li>查看当前数据库<br><code>db</code></li><li>查看所有数据库，只能显示<strong>非空</strong>的数据库<br><code>show dbs</code></li><li>创建表<br><code>db.creaeteCollection('表名')</code></li><li>插入数据,如果没有这个表，会自动创建<br><code>db.表名.insert({'字段':'值})</code></li><li>查询所有数据<br><code>db.表名.find()</code></li><li>查看所有表<br><code>show tables</code></li><li>删除表<br><code>db.表名.drop()</code></li><li>删除库<br><code>db.表名.dropDatabase()</code></li></ol></blockquote><h4 id="13-2-增加数据"><a href="#13-2-增加数据" class="headerlink" title="13.2  增加数据"></a>13.2  增加数据</h4><blockquote><p>字段多少是单独的那条数据，不一致也没有关系</p><p>例如：</p><p>{‘name’:’玛卡巴卡’}—{‘name’:’海绵宝宝’,’age’:200}</p></blockquote><ol><li><code>db.表名.insertOne({'字段名':'值})</code></li><li><code>db.表名.insert({'字段':'值})</code></li><li><code>db.表名.insertMany([{'字段':'值},{'字段':'值}])</code></li></ol><h4 id="13-3-查询数据"><a href="#13-3-查询数据" class="headerlink" title="13.3  查询数据"></a>13.3  查询数据</h4><ul><li>简单查询<br><code>db.表名.find()</code></li><li>分页，返回2条查询数据<br><code>db.表名.find({}).limit(2)</code></li><li>排序，*<strong>1**<em>是升序，</em></strong>-1***是降序<br><code>db.表名.find().sort({'price':1})</code></li></ul><blockquote><p>等值查询</p></blockquote><ul><li><p>等值查询（按照条件查询）<br><code>db.表名.find({'price':4.5})</code></p></li><li><p>非等值查询（范围查询）</p></li><li><p><code>({'price':{'$lt':500,'$gt':100}})#小于500，大于100</code></p></li><li><p><strong><em>或</em></strong>查询<br><code>db.表名.find({$or:[{'price':{'$lt':5.5}},{'price':{$gt:500}} ]})</code></p></li><li><pre class=" language-python"><code class="language-python"><span class="token operator">></span>   <span class="token operator">==</span> $gt  <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'price'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>$gt<span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#价格大于100的</span><span class="token operator">&lt;</span>   <span class="token operator">==</span> $lt  <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'price'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>$lt<span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#价格小于100的</span><span class="token operator">&lt;=</span>  <span class="token operator">==</span> $lte <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">>=</span>  <span class="token operator">==</span> $gte <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">!=</span>  <span class="token operator">==</span> $ne  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre></li></ul><blockquote><p>模糊查询</p></blockquote><ul><li><code>db.表名.find({'字段名':{$regex:'正则表达式'}})</code></li></ul><h4 id="13-4-修改数据"><a href="#13-4-修改数据" class="headerlink" title="13.4  修改数据"></a>13.4  修改数据</h4><p><code>db.表名.update({'price':2.5},{$set:{'price':500}})</code></p><h4 id="13-5-删除数据"><a href="#13-5-删除数据" class="headerlink" title="13.5  删除数据"></a>13.5  删除数据</h4><p><code>db.表名.remove({'name':'玛卡巴卡'})</code></p>]]></content>
      
      
      <categories>
          
          <category> spider </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PayPal跨境支付</title>
      <link href="/posts/31865/"/>
      <url>/posts/31865/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是PayPal"><a href="#什么是PayPal" class="headerlink" title="什么是PayPal"></a>什么是PayPal</h2><blockquote><p>PayPal又称为贝宝，是一种外贸支付方式，目前在国际的贸易支付中有着极高的地位，它就好像中国的支付宝，都是第三方支付平台。</p><p>PayPal的优势是，其业务网络遍布全球。目前PayPal的庞大网络覆盖了全球200多个国家，可提供20多种语言服务，并接受100多种货币付款和56种货币提现。</p></blockquote><ul><li>需要注意的一点是，也是我个人感觉非常好的一个地方，PayPal的支付逻辑，是一个事务性的操作，一旦开始，除非获取到支付成功的返回凭证，否则一致就认为没有成功，支付宝就不是这样，它是支付时生成订单，无论是否付款，订单都已经生成了，这样的话，在付款的一瞬间，啪，网断了，支付宝有可能会出现错误，可能是支付状态未修改啊，或者三方卖家没有收到支付成功请求啊一类的。</li><li>但是，支付宝也有避免错误的方法，就是对所有唤起收银台交易的状态码<code>10003</code>发起轮询，轮询间隔未3秒，在让用户再次支付前，必须通过查询确认当前订单的 状态</li></ul><h2 id="注册PayPal和开发者平台"><a href="#注册PayPal和开发者平台" class="headerlink" title="注册PayPal和开发者平台"></a>注册PayPal和开发者平台</h2><p><a href="https://www.paypal.com/">官网地址</a></p><p><a href="https://developer.paypal.com/developer/accounts/">开发者平台</a></p><hr><p>注册成功后，会默认创建两个账号，一个是个人的，一个商户的，如果不想用默认的，可以自己创建</p><img src="/posts/31865/image-20201129103836488.png" alt style="zoom:67%;" loading="lazy"><p> 进入应用管理，可以看到，它也给创建了默认的应用</p><img src="/posts/31865/image-20201129104223976.png" alt style="zoom:50%;" loading="lazy"><p>然后获取Client ID和Secret</p><img src="/posts/31865/image-20201129104436414.png" alt style="zoom:50%;" loading="lazy"><p>然后回来修改一下个人账户的余额和密码</p><img src="/posts/31865/image-20201129105355410.png" alt style="zoom:50%;" loading="lazy"><p><img src="/posts/31865/image-20201129105446465.png" alt style="zoom:50%;" loading="lazy"><img src="/posts/31865/image-20201129105524864.png" alt loading="lazy"></p><img src="/posts/31865/image-20201129105524864.png" alt style="zoom:50%" loading="lazy"><hr><h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><pre class="language-python" data-language="python"><code class="language-python">pip install paypalrestsdk</code></pre><p>先安装paypal的sdk</p><p>然后新建app，注册好路由和应用，然后view中的代码</p><pre class="language-python" data-language="python"><code class="language-python">import paypalrestsdkfrom django.http import HttpResponsefrom django.shortcuts import redirectClient_id = '你的Client_id'Secret = '你的Secret'def payment(request):    paypalrestsdk.configure({      "mode": "sandbox", # sandbox代表沙盒      "client_id": Client_id,      "client_secret": Secret,    })    payment = paypalrestsdk.Payment({        "intent": "sale",        "payer": {            "payment_method": "paypal"},        "redirect_urls": {            "return_url": "http://192.168.1.157:8000/palpay/pay/", # 支付成功跳转页面            "cancel_url": "http://192.168.1.157:3000/paypal/cancel/"}, # 取消支付页面        "transactions": [{            "amount": {                "total": "5.00", # 付款金额                "currency": "USD"}, # 货币类型            "description": "这是一个订单测试"}]})    if payment.create():        print("Payment created successfully")        for link in payment.links:            if link.rel == "approval_url":                approval_url = str(link.href)                print("Redirect for approval: %s" % (approval_url))                return redirect(approval_url)    else:        print(payment.error)        return HttpResponse("支付失败")</code></pre><p>启动项目，网页访问该视图，即可看到这样</p><img src="/posts/31865/image-20201129112525018.png" alt="image-20201129112525018" style="zoom:50%;" loading="lazy"><p>点击继续，可以看到，回调的地址传来了三个参数</p><pre class="language-none"><code class="language-none">http://192.168.1.157:8000/palpay/pay/?paymentId=PAYID-L7BRGHA28162157FN083293V&amp;token=EC-1S659222KF8901217&amp;PayerID=QFV2E28KASNQS</code></pre><p>支付id,token和支付者id</p><hr><p>然后，我们写一个回调方法，需要通过支付者id进行确认验证支付</p><pre class="language-python" data-language="python"><code class="language-python">def payment_execute(request):    paymentid = request.GET.get("paymentId") #订单id    payerid = request.GET.get("PayerID")  #支付者id    payment = paypalrestsdk.Payment.find(paymentid)print(payment)    if payment.execute({"payer_id": payerid}):        print("Payment execute successfully")        return HttpResponse("支付成功")    else:        print(payment.error) # Error Hash        return HttpResponse("支付失败")</code></pre><p>然后点击支付即可看到，少了五块钱</p><img src="/posts/31865/image-20201129114412124.png" alt style="zoom:50%;" loading="lazy"><p>然后有些时候需要对交易进行一些核对，也可以通过接口查看交易明细，也就是上面的<code>payment</code></p>]]></content>
      
      
      <categories>
          
          <category> PayPal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> PayPal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Docker配置Elasticsearch全文检索</title>
      <link href="/posts/46689/"/>
      <url>/posts/46689/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>什么是搜索，这是一个相当简单的问题了，就是根据一个搜索词来检索出所有包含该词的数据。我们一般使用<code>mysql</code>数据搜索都是通过模糊搜索来查询，但是这样就会面临一个性能问题，假如数据量超多，这样的搜索无异于自杀。</p><p>基于文档式的全文检索引擎相信大家都不陌生，<code>Elasticsearch</code>诞生的本意是为了解决文本搜索太慢的问题，ES会默认将所有的输入内容当作字符串来理解，对于字段类型是keyword或者text的数据比较友好。</p></blockquote><p>我们已经提到，<code>Elasticsearch</code>专为字符串搜索而生，在建立索引的时候针对字符串进行了非常多的优化，在对字符串进行准确匹配或者前缀匹配等匹配的时候效率是很高的。</p><p>谈论到搜索引擎，就一定会涉及到两个概念，正向索引和反向索引。听上去这是两个完全不同的数据结构。但是实际上，正向索引就好比我们的书籍，每本书都有目录，这就是一种正向索引，能够通过文档去查找关键词。</p><p>而反向索引，和正向索引是完全相反的，它将关键词作为索引， 去查找哪个文档包含了这个关键词，就拿上边的例子，正向索引是通过楼层去找店铺，而反向索引，就是你知道店铺的某一个字，商场导航给你提供了包含这个字的所有店铺，这样就极大的缩小了查找范围。</p><hr><h2 id="Docker配置"><a href="#Docker配置" class="headerlink" title="Docker配置"></a>Docker配置</h2><p>拉取镜像</p><pre class="language-python" data-language="python"><code class="language-python">docker pull elasticsearch:7.2.0</code></pre><p>运行镜像</p><pre class="language-python" data-language="python"><code class="language-python">docker run --name es -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -d elasticsearch:7.2.0</code></pre><blockquote><p>容器别名我们就用缩写es来替代，通过 9200 端口并使用<code>Elasticsearch</code>的原生传输协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群，运行模式先走单节点模式。</p></blockquote><p>此时，我们如果要加一些功能，就得改一些配置，就好像<code>django</code>的Settings配置一样。</p><p>Docker提供了<code>cp</code>命令来拷贝容器内部的文件</p><p>我们只要拷贝<code>elasticsearch.yml</code></p><pre class="language-python" data-language="python"><code class="language-python">docker cp 容器id:/usr/share/elasticsearch/config/elasticsearch.yml ./elasticsearch.yml</code></pre><p>也可以将文件拷贝路径指定为绝对路径</p><p>打开文件，可以加一些自己的配置</p><pre class="language-python" data-language="python"><code class="language-python">cluster.name: "docker-cluster"network.host: 0.0.0.0http.cors.enabled: truehttp.cors.allow-origin: "*"</code></pre><p>然后停止正在运行的容器，并且删除它</p><pre class="language-none"><code class="language-none">docker stop 容器iddocker rm $(docker ps -a -q)</code></pre><p>再次启动，只不过不同的是，这次我们需要通过-v命令把我们刚刚修改的文件配置挂载到容器内部去。</p><pre class="language-none"><code class="language-none">docker run --name es -v E:\elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -d elasticsearch:7.2.0</code></pre><p>这里需要注意一点，就是在Win10宿主机里需要单独设置一下共享文件夹，这里我设置的共享文件夹叫做es，如果是Centos或者Mac os就直接写真实物理路径即可。</p><img src="/posts/46689/image-20201201223246321.png" alt style="zoom:80%;" loading="lazy"><p>随后，重启Docker，输入命令进入默认容器：docker-machine ssh default</p><p>在容器根目录能够看到刚刚设置的共享文件夹，就说明设置成功了。</p><p>另外还有一个需要注意的点，就是Elasticsearch存储数据也可以通过-v命令挂载出来，如果不对数据进行挂载，当容器被停止或者删除，数据也会不复存在，所以挂载后存储在宿主机会比较好一点，命令是：</p><pre class="language-python" data-language="python"><code class="language-python">docker run --name es -v /es/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /es/data:/usr/share/elasticsearch/data -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -d elasticsearch:7.2.0</code></pre><h2 id="python配置"><a href="#python配置" class="headerlink" title="python配置"></a>python配置</h2><p>首先安装<code>pip3 install elasticsearch</code></p><p>建立检索实例</p><pre class="language-python" data-language="python"><code class="language-python">from elasticsearch import Elasticsearch es = Elasticsearch(hosts=[{"host":'Docker容器所在的ip', "port": 9200}])</code></pre><p>建立索引</p><pre class="language-python" data-language="python"><code class="language-python"># 建立索引result = es.indices.create(index='godhearing', ignore=400)print(result)</code></pre><p>删除索引</p><pre class="language-python" data-language="python"><code class="language-python">result = es.indices.delete(index='godhearing', ignore=[400, 404])print(result)</code></pre><p>插入数据</p><pre class="language-python" data-language="python"><code class="language-python">data = {'title': '天听', 'url': 'http://123.com','content':"好耶耶耶"}result = es.index(index='godhearing',body=data)print(result)</code></pre><blockquote><p>index()方法会自动生成一个唯一id</p><p>也可以使用create()方法创建数据<br>不同的是create()需要手动指定一个id</p></blockquote><p>修改数据</p><pre class="language-python" data-language="python"><code class="language-python">data = {'content':"啊哈哈哈哈哈哈哈嗝！"}result = es.index(index='godhearing',body=data, id='插入数据时返回的id')print(result)</code></pre><blockquote><p>修改之后，仅剩余此字段</p></blockquote><p>删除数据</p><pre class="language-python" data-language="python"><code class="language-python">result = es.delete(index='godhearing',id='插入数据时的ID')print(result)</code></pre><p>查询数据</p><pre class="language-python" data-language="python"><code class="language-python">result = es.search(index='godhearing')print(result)</code></pre><p>全文检索</p><pre class="language-python" data-language="python"><code class="language-python">mapping = {    'query': {        'match': {            'content': '嗝'        }    }}result = es.search(index='godhearing',body=mapping)print(result)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux终端测试接口</title>
      <link href="/posts/25589/"/>
      <url>/posts/25589/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>假如说，你只有一个linux终端来测试你的代码，你是不是瞬间觉得没有了梦想，发送参数，发送不同的请求，甚至查看返回结果，你面对的只有无穷无尽的黑色和白色的代码，是不是很绝望，今日带来一篇攻略，让你仅仅凭借一个终端来测试你的代码</p></blockquote><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><blockquote><p>访问接口，除了写脚本测试之外，还可以直接使用终端来进行测试，具体我们要使用的命令，就是<code>curl</code></p><p>这个命令可以访问网址，但是，他会返回的只有网页的源代码，所以，一般你访问完了，会看到这种情况</p></blockquote><img src="/posts/25589/image-20201225134708278.png" alt style="zoom:50%;" loading="lazy"><p>虽然可以查看到，但是也很不利于你的查看，所以，我们需要将<code>curl</code>命令后面，加上一个<code>&gt;</code>，紧接着，跟上你保存的文件名字，这样，他就会将访问的网页给你保存下来，像这样</p><pre class="language-none"><code class="language-none">curl http://baidu.com &gt; baidu.html</code></pre><p>随后，你就会看到一个网页就保存下来了</p><p>其次，我们写的接口不只是get，还有其他的请求方法，这样该怎么做呢，只需添加一个<code>X</code>参数即可</p><p><code>curl -X POST http://127.0.0.1:8000/</code> ，这样你就发送了一个post请求，同样你也可以传参，使用<code>d</code>，不同参数之间使用<code>&amp;</code>来进行连接</p><pre class="language-none"><code class="language-none">curl -X POST -d'a=1&amp;b=2&amp;c=3' http://127.0.0.1:8000/</code></pre><p>再做个假如，你访问的是张图片，我们也可以通过 <code>&gt;</code> 来进行保存，然后查看</p><p>还有，如果在终端里发送文件，则需要<code>-F</code>参数，不过要注意的是，@一定不要少哦</p><pre class="language-none"><code class="language-none">curl -X POST -F 'avatar=@./ssss.jpg' http://127.0.0.1:8000/user/avatar/</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>这个场景呢，主要就是使用了windows系统，但是有些功能只能在linux下测试，但是我的linux云服务器又只有一个终端界面，出于无奈之举，只能使用这样的方法来进行。希望能帮到大家。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios的封装</title>
      <link href="/posts/12164/"/>
      <url>/posts/12164/</url>
      
        <content type="html"><![CDATA[<h2 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h2><ol><li><p>src文件夹下新建http文件夹，用来放网络请求相关的文件</p></li><li><p><code>src/http</code>文件夹下，创建<code>index.js</code>文件，对axios进行封装</p></li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript">const&nbsp;axios=require('axios');&nbsp;&nbsp;&nbsp;//创建axios对象axios.defaults.baseURL='http://127.0.0.1:8000/';&nbsp;//vue请求后端地址axios.defaults.timeout=1000;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//多久超时&nbsp;axios.defaults.withCredentials=&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//携带cookie需要添加/**&nbsp;*&nbsp;设置请求传递数据的格式（看服务器要求的格式）&nbsp;*&nbsp;x-www-form-urlencoded&nbsp;*&nbsp;默认提交表单&nbsp;*&nbsp;把数据对象序列化成&nbsp;表单数据&nbsp;*///axios.default.headers['Content-Type']='application/x-www-form-urlencoded';//axios.default.transformRequest=data&nbsp;=&gt;qs.stringify(data);/**&nbsp;*设置默认提交JSON&nbsp;*&nbsp;把数据对象序列化成json字符串&nbsp;*/axios.defaults.headers['Content-Type']='application/json';axios.defaults.transformRequest=&nbsp;data&nbsp;=&gt;JSON.stringify(data);//请求拦截器axios.interceptors.request.use(config=&gt;{&nbsp;&nbsp;//从localStorage获取token&nbsp;&nbsp;let&nbsp;token&nbsp;=&nbsp;localStorage.getItem('token');&nbsp;&nbsp;//如果有token,就把token设置到请求头中Authorization字段中&nbsp;&nbsp;token&nbsp;&amp;&amp;(config.headers.Authorization=token);&nbsp;&nbsp;return&nbsp;config;&nbsp;&nbsp;{,error=&gt;{&nbsp;&nbsp;return&nbsp;Promise.reject(error);&nbsp;&nbsp;{);//响应拦截器axios.interceptors.response.use(response=&gt;{&nbsp;&nbsp;//当响应码&nbsp;2xx的情况，进入这里&nbsp;&nbsp;return&nbsp;response.data;&nbsp;&nbsp;{,error&nbsp;=&gt;&nbsp;{&nbsp;&nbsp;//当相应码不是2xx的情况，进入这里&nbsp;&nbsp;return&nbsp;error&nbsp;&nbsp;{);//get方法，对应get请求//@params{String{&nbsp;url[请求的url地址]//@params{Object{&nbsp;params[请求时携带的参数]export&nbsp;function&nbsp;get(url,params,headers)&nbsp;{&nbsp;&nbsp;return&nbsp;new&nbsp;Promise((resolve,reject)=&gt;{&nbsp;&nbsp;&nbsp;&nbsp;axios.get(url,{params,headers{).then(res=&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(res.data.ResultObj)&nbsp;&nbsp;&nbsp;&nbsp;{).catch(err=&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(err.data)&nbsp;&nbsp;&nbsp;&nbsp;{)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;){//post方法，对应post请求export&nbsp;function&nbsp;post(url,params,headers)&nbsp;{&nbsp;&nbsp;return&nbsp;new&nbsp;Promise((resolve,reject)=&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axios.post(url,params,headers).then((res)=&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(res.data)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{).catch((err)=&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(err.data)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;){export&nbsp;default&nbsp;axios;</code></pre><ol start="3"><li><p><code>src/http</code>目录下创建apis.js文件，用来写接口地址列表</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">//接口信息，生成请求方法//请求后端django的地址//引入get方法，post方法import {get,post{ from './index'//用户登录export const login = (params,headers) =&gt; post("/user/login/",params,headers)</code></pre></li></ol><h2 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h2><pre class="language-python" data-language="python"><code class="language-python">#允许所有源来跨域CORS_ORIGIN_ALLOW_ALL =True#或者设置跨域请求白名单# CORS_ORIGIN_WHITELIST = (#     'http://127.0.0.1:8080',#     'http://localhost:8080',# )#允许携带cookieCORS_ALLOW_CREDENTALS = True</code></pre><h2 id="前后端联调思路"><a href="#前后端联调思路" class="headerlink" title="前后端联调思路"></a>前后端联调思路</h2><ol><li>写完视图函数，使用postman进行接口测试，保证后端接口没有问题</li><li>在vue中写页面，向后端发送数据</li></ol><pre class="language-python" data-language="python"><code class="language-python">const { data { = require('autoprefixer');const axios = require('axios');const { error { = require('shelljs');axios.defaults.baseURL = 'http://192.168.56.100:8888' //vue请求后端地址axios.defaults.timeout = 10000; // 超时设置axios.defaults.withCredentials = true; // 跨域访问需要发送cookie时，一定要加上axios.defaults.headers['Content-Type'] = 'application/json'; //设置默认提交jsonaxios.defaults.transformRequest = data =&gt; JSON.stringify(data);//把数据对象序列化成json字符串// 对请求拦截器，和响应拦截器进行封装/*请求拦截器，发送请求前需要调用这个函数当没有登录时，直接跳转到登录页请求发送前把token获取，设置到header中*/axios.interceptors.request.use(config=&gt;{    //从localStorage中获取token    let token = localStorage.getItem('token');    // 如果有token，就把token设置到请求头中Authorization字段中    token &amp;&amp; (config.headers.Authorzation = token);    return config;{,error =&gt; {    return Promise.reject(error){);/*响应拦截器，当后端返回数据给vue时，会调用这个函数每次返回403错误时，跳转到login*/axios.interceptors.response.use(response =&gt;{    //当响应码是2xx的情况时，进入这里    return response.data;{,error =&gt;{    //当响应码不是2xx的情况是，进入这里    return error{);//使用上面的axios对象，对get和post请求进行封装/*get方法，对应get请求@param {String{ url [请求的url地址]@param {Object{ params [请求时携带的参数]*/export function get(url,params,headers){    return new Promise((resolve,reject) =&gt;{        axios.get(url,{params,headers{).then(res=&gt;{            resolve(res.data.ResulObj)        {).catch(err =&gt;{            reject(err.data)        {)    {){/*post方法，对应post请求@param {String{ url [请求的url地址]@param {Object{ params [请求时携带的参数]*/export function post(url,params,headers){    return new Promise((resolve,reject) =&gt;{        axios.post(url,params,headers).then(res=&gt;{            resolve(res.data)        {).catch(err =&gt;{            reject(err.data)        {)    {){//一定要导出函数export default axios;</code></pre><pre class="language-python" data-language="python"><code class="language-python">def login(request):    body_dict = json.loads(request.body)    name = body_dict.get("name")    pwd = body_dict.get("pwd")    if not all([name,pwd]):        resp = {            'code':1001,            'msg':'信息不全'        {        return JsonResponse(resp)    if name == '天听' and pwd == '123456':        res = {            "code":0,            "msg":"登录成功",            "data":{                "id":1,                "name":"tianting",                "age":20            {        {        return JsonResponse(res)    return JsonResponse({        "code":1002,        "msg":'用户名或密码错误'    {)</code></pre>]]></content>
      
      
      <categories>
          
          <category> axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> Vue </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署Django项目</title>
      <link href="/posts/34163/"/>
      <url>/posts/34163/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h2><blockquote><p>作为一种新兴的虚拟化方式，Docker跟传统的虚拟化方式相比具有众多的优势</p><p>首先，Docker的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。 其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。</p><p>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p><p>Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。</p></blockquote><p>简单来说，Docker是一个应用容器引擎，它包括了三个基本的概念，镜像(Image)，容器(Container)，仓库(Repository)，理解了这三个概念，就理解了Docker整个的生命周期</p><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>Docker镜像就是一个只读的模板，就好比于一个桶，桶里可以装任何东西，无论是一个程序，还是一个完整的ubuntu系统环境，里面仅安装了需要的其他应用程序，需要用什么，往桶里扔什么</p><p>镜像可以用来创建Docker容器</p><p>Docker提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用</p><ul><li><code>docker load -i '镜像路径'</code>用来引入镜像</li><li><code>docker pull mysql</code>，拉去<code>mysql</code>镜像，当然不止<code>mysql</code>，几乎所有的工具都能通过pull来拉取镜像来搭建环境，例如<code>mongo</code>，<code>redis</code>等</li></ul><hr><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><blockquote><p>Dockers利用容器来运行应用</p><p>容器时从镜像创建的运行实例，它可以被启动、开始、停止、删除。每个容器都时相互隔离的，保证安全</p></blockquote><p><code>docker run -it -p 80:80 镜像id</code>：运行容器</p><ul><li><code>-it</code>：<strong>i</strong>以交互式模式运行容器,<strong>t</strong>为容器分配一个伪输入终端</li><li><code>-p</code>：端口<ul><li><code>80:80</code>：端口映射<code>宿主机port:容器port</code></li></ul></li><li><code>docker stop 容器id</code>：关闭</li><li><code>docker ps</code>:查看正在运行的容器</li></ul><blockquote><p>注意，启动时，使用的是镜像id，关闭时，使用的是容器id</p></blockquote><hr><h2 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h2><blockquote><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p></blockquote><blockquote><p>最大的公开仓库是 <a href="https://hub.docker.com/">Docker Hub</a>，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括 <a href="http://www.dockerpool.com/">Docker Pool</a> 等，可以提供大陆用户更稳定快速的访问。</p></blockquote><p>当然，用户也可以在本地网络内创建一个私有仓库。</p><p>当用户创建了自己的镜像之后就可以使用 <code>push</code> 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 <code>pull</code> 下来就可以了。</p><p>Docker仓库的概念跟<strong>Git</strong>类似，注册服务器可以理解为<code>Github</code>这样的托管服务</p><hr><h2 id="部署Django"><a href="#部署Django" class="headerlink" title="部署Django"></a>部署Django</h2><ol><li>在安装好Docker之后，在宿主机安装<code>gunicorn</code>，容器内我们用异步的方式来启动Django</li></ol><pre class="language-python" data-language="python"><code class="language-python">pip isntall gunicorn gevent</code></pre><ol start="2"><li><p>Django配置<code>settings.py</code>对应的应用:</p><pre class="language-python" data-language="python"><code class="language-python">INSTALLED_APPS = [    'gunicorn']</code></pre></li><li><p>在<code>Django</code>项目的根目录编写<code>gunicorn</code>的配置文件：<code>gunicorn.conf.py</code></p><pre class="language-python" data-language="python"><code class="language-python">import multiprocessingbind = "0.0.0.0:8000"   #绑定的ip与端口workers = 1                #进程数</code></pre><blockquote><p>这里注意一点，<code>ip</code>必须是0.0.0.0，不要写成127.0.0.1,否则外部环境会访问不到容器内的服务</p></blockquote></li><li><p>导出你的python对应的依赖列表:</p><pre class="language-python" data-language="python"><code class="language-python">pip freeze &gt; requirements.txt</code></pre></li><li><p>在根目录编写<code>Dockerfile</code>文件</p><pre class="language-python" data-language="python"><code class="language-python">FROM python:3.7WORKDIR /Project/mydjangoCOPY requirements.txt ./RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simpleCOPY . .ENV LANG C.UTF-8CMD ["gunicorn", "mydjango.wsgi:application","-c","./gunicorn.conf.py"]</code></pre></li><li><p>打包</p><pre class="language-python" data-language="python"><code class="language-python">docker build -t '你的项目名' .</code></pre></li><li><p>然后查看镜像</p><pre class="language-python" data-language="python"><code class="language-python">docker images</code></pre></li><li><p>启动镜像服务</p><pre class="language-python" data-language="python"><code class="language-python">docker run -it --rm -p 8000:8000 你的项目名</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/posts/6013/"/>
      <url>/posts/6013/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是工厂模式"><a href="#什么是工厂模式" class="headerlink" title="什么是工厂模式"></a>什么是工厂模式</h2><blockquote><p>所谓的工厂模式，是设计模式中比较常用的，这种类型的设计模式</p><p>在这种模式下，不会暴露创建逻辑，只是通过某个标识来确定实例化哪个工厂实例</p><p>简单的举个例子，如果你要买一辆汽车，不用知道他是怎样做出来的，只需要把参数传递进去，到时候来提车就好了。</p><p>无论是车还是什么，都不用管工厂内部是怎样实现的，只需要将参数传进去就可以</p></blockquote><p>工厂模式从简到难，分为简单工厂模式，工厂方法模式以及抽象工厂模式</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式其实并不算是一种设计模式，更多的时候更像是一种编程习惯</p><blockquote><p>定义一个工厂类，根据传入的参数返回不同的实例，被创建的实例具有共同的父类或接口</p><p>现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。</p></blockquote><p>再举个栗子，假如，你要生产瓶子，客户说要什么样的瓶子，你就拿着这个瓶子的参数，去该瓶子的生产车间去取。</p><pre class="language-python" data-language="python"><code class="language-python"># 定义三个具体的工厂，他们用来生产具体的东西class A:    def __init__(self):        self.name = 'A瓶子'class B:    def __init__(self):        self.name = 'B瓶子'class C:    def __init__(self):        self.name = 'C瓶子'# 工厂类class factory():    def example(self,name):        if name=='A':            s = A()            print(s.name)        elif name == 'B':            s = B()            print(s.name)        elif name == 'C':            s = C()            print(s.name)w = factory()w.example('B')</code></pre><p>可以看到，只需要在工厂<code>factory</code>中，传入你想要什么瓶子，他就可以通过内部方法实例化某个工厂，从而达到你想要的某个东西</p><hr><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote><p>工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。</p><p>以上面的例子为例，假如要再多一个D瓶子，除了要新建一个D类，还要修改工厂类中的代码，这样就违背了软件设计中的开闭原则，即再扩展新的类时，尽量不要修改原有的代码</p></blockquote><p>说的再简单点，就是工厂类被具体的工厂继承</p><pre class="language-python" data-language="python"><code class="language-python"># 工厂类class factory():    @staticmethod    def example(self):        passclass A(factory):    def __init__(self):        self.name = 'A瓶子'    def example(self):        print(self.name)class B(factory):    def __init__(self):        self.name = 'B瓶子'    def example(self):        print(self.name)class C(factory):    def __init__(self):        self.name = 'C瓶子'    def example(self):        print(self.name)class D(factory):    def __init__(self):        self.name = 'D瓶子'    def example(self):        print(self.name)# 无论你加了多少个工厂，只需要实例化对应的那个具体工厂w = D()w.example()</code></pre><p>这样做的好处就是，在工厂类里，无需改动任何代码，只需要在需要的时候实例化某个具体工厂即可，便于维护</p><hr><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p><p>抽象工厂模式中有工厂和产品簇的概念。而一簇的产品都是成套出现的。比如现在要给每个士兵发一套武器，包括枪和子弹。步枪和步枪子弹，手枪和手枪子弹。生产步枪的工厂就是步枪工厂，而生产手枪的工厂就是手枪工厂。步枪工厂和手枪工厂都是工厂，这就是一种抽象工厂的例子</p></blockquote><p>用一个简单的代码来实现:</p><pre class="language-python" data-language="python"><code class="language-python">import abc# 工厂类class factory():    @staticmethod    def Rifle(self):        pass    def Pistol(self):        pass# M4工厂class M4(category):    def Rifle(self):        return M4Rifle()    def Pistol(self):        return M4Pistol()# AK工厂class AK(category):    def Rifle(self):        return AKRifle()    def Pistol(self):        return AKPistol()# M4工厂class M4Rifle():    def __repr__(self):        return 'M4A1步枪'class M4Pistol():    def __repr__(self):        return 'M4A1手枪'class AKRifle():    def __repr__(self):        return 'AK47步枪'class AKPistol():    def __repr__(self):        return 'AK47手枪'w = M4().Rifle()print(w)</code></pre><blockquote><p>进入工厂类，无论是要AK系列的，还是<code>M4</code>系列的，都只实例化那个类就可以了，因为，无论是<code>M4</code>还是AK都能生产该类的手枪和步枪</p><p>虽然我也不知道他们是不是生产手枪</p></blockquote><p>嗯…再画个图吧，low归low，但比较好理解</p><img src="/posts/6013/20201115120419234.png" style="zoom:70%;" loading="lazy">]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布一致性算法(雪花算法)</title>
      <link href="/posts/71cdb231/"/>
      <url>/posts/71cdb231/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是分布一致性"><a href="#什么是分布一致性" class="headerlink" title="什么是分布一致性"></a>什么是分布一致性</h2><blockquote><p>这是一个相当灵魂拷问的问题了，在我们应对千万级甚至亿级的资源访问时，一定会用到的一个词，就是分布式</p><p>因为一台服务器的承载力是有限的，而数据库更是有限的，数据表是更更更有限的，我们只能通过横向扩容的方式来进行数据存储量和查询速度的优化</p><p>可这样会造成一个问题，分库分表后，分布式系统中，唯一主键ID的生成问题，当我们使用mysql自增长主键时，他只在本表中是唯一的， 在分布式系统中，两张表都有一张ID为1的数据，那么显然就无法使用这个自增长了</p></blockquote><p>如果我们说使用uuid，也可以凑活用，但是，第一他是无序的，第二，他占用空间巨大，耗费空间。</p><p>uuid只能适用于类似生成token令牌的场景</p><hr><h2 id="SnowFlake"><a href="#SnowFlake" class="headerlink" title="SnowFlake"></a>SnowFlake</h2><blockquote><p>SnowFlake(雪花算法)，是Twitter提出来的一个算法，其目的是生成一个64bit的整数</p></blockquote><p>1位标识符，始终是0</p><p>41位的时间戳</p><p>10位的机器标识码</p><ul><li>前5位代表数据中心，后面5位是某个数据中心的机器ID</li></ul><p>12位的递增序列</p><ul><li>用来对同一个毫秒之内产生不同的ID，12位可以最多记录4095个，也就是在同一个机器同一毫秒最多记录4095个，多余的需要进行等待下毫秒。</li></ul><h2 id="python实操"><a href="#python实操" class="headerlink" title="python实操"></a>python实操</h2><blockquote><p>首先安装<code>pip install pysnowflake</code></p></blockquote><p>然后终端启动snowflake服务</p><pre class="language-python" data-language="python"><code class="language-python">snowflake_start_server --worker=1</code></pre><blockquote><p>这里的worker就是当前节点的标识</p></blockquote><p> 上代码:</p><pre class="language-python" data-language="python"><code class="language-python">import snowflake.clientprint(snowflake.client.get_guid())# 多次输出一下，就会发现，有递增的连续性</code></pre><img src="/posts/71cdb231/image-20201130221520785.png" alt style="zoom:50%;" loading="lazy"><p>将其转换成二进制码</p><pre class="language-python" data-language="python"><code class="language-python">print(bin(4431128039883018241))</code></pre><img src="/posts/71cdb231/image-20201130221746952.png" alt style="zoom:50%;" loading="lazy"><p>然后我们通过二进制码反推</p><ul><li>第一位是标识符</li><li>往后41位是时间戳</li></ul><p>从右方数，12位的递增序列，再数5位就是机器标识，这个机器标识就是某个节点的存储标识00001</p><p>但是啊，目前他是二进制，我们再将其转换为10进制</p><pre class="language-python" data-language="python"><code class="language-python">print(int('00001',2))</code></pre><img src="/posts/71cdb231/image-20201130222356449.png" alt style="zoom:50%;" loading="lazy">]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ModelViewSet</title>
      <link href="/posts/23362/"/>
      <url>/posts/23362/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>ModelViewSet是封装度最高的DRF的视图类。包含了怎删改查中的所有接口操作。</p></blockquote><blockquote><p>它继承自<code>GenericViewSet</code>、ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin。</p><p><strong>！！！！！注意，因为继承关系，必须在内部定义属性，queryset和serializer_class，因此，ModelViewSet通常结合ModelSerializer使用</strong></p></blockquote><blockquote><p>所以，在使用ModelViewSet定义API时，我们只需要套用模板即可</p></blockquote><p>使用视图集，可以将一系列逻辑相关的动作放到一个类中：</p><ul><li>list() 提供一组数据</li><li>retrieve() 提供单个数据</li><li>create() 创建数据</li><li>update() 更新数据</li><li>destory() 删除数据</li></ul><blockquote><p>视图集类不再实现get()、post()、put()、delete()方法，而是实现动作 <strong>action</strong>。 如 list()、retrieve()、create()、update()、destory()</p></blockquote><table><thead><tr><th>请求</th><th>url</th><th>对应方法</th><th>备注</th></tr></thead><tbody><tr><td>get</td><td>127.0.0.1:8000/app01/book/</td><td>list</td><td>ListModelMixin</td></tr><tr><td>get</td><td>127.0.0.1:8000/app01/book/{1{/</td><td>retrieve</td><td>….Mixin</td></tr><tr><td>post</td><td>127.0.0.1:8000/app01/book/</td><td>create</td><td>….Mixin</td></tr><tr><td>put</td><td>127.0.0.1:8000/app01/book/{1{/</td><td>update</td><td>….Mixin</td></tr><tr><td>detete</td><td>127.0.0.1:8000/app01/book/{1{/</td><td>destroy</td><td>….Mixin</td></tr><tr><td>get</td><td>127.0.0.1:8000/app01/book/ user_action</td><td>useraction</td><td>自定义</td></tr><tr><td>post</td><td>127.0.0.1:8000/app01/book/ user_action</td><td>useraction</td><td>自定义</td></tr></tbody></table><pre class="language-python" data-language="python"><code class="language-python">#views中class BookInfoViewSet(ModelViewSet):    """增删改查图书信息"""    # 指定查询集    queryset = BookInfo.objects.all()    # 指定序列化器    serializer_class = BookInfoModelSerializer</code></pre><blockquote><p>定义好了API视图后，需要在路由中，将请求方法与action进行绑定</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from django.conf.urls import urlfrom django.urls import path,includefrom . import views#导入路由控制类from rest_framework.routers import SimpleRouter,DefaultRouter#实例化路由控制对象router = DefaultRouter()#注册router.register(r'book',views.BookInfoViewSet)#编写路由，固定写法，不清楚是否还有其他写法urlpatterns = [    url(r'',include(router.urls)),]</code></pre><h3 id="action-自定义方法"><a href="#action-自定义方法" class="headerlink" title="action(自定义方法)"></a>action(自定义方法)</h3><blockquote><p>DRF框架提供的action根本不能满足某些无良老板的奇葩需求,这时候，就需要自定义<code>action</code></p></blockquote><blockquote><p>只需要在ModelViewSet定义的api类中，自定action函数后，再将自定义的函数在路由中绑定即可</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">def 函数名(self, request):        '''        自定义action        return: JSON数据        '''        pass#示例：def latest(self, request):    '''获取最后一条记录'''    # 获取模型数据    book = BookInfo.objects.latest('id')    # 获取序列化器对象    s = BookInfoModelSerializer(instance=book)    return Response(s.data)</code></pre><pre class="language-python" data-language="python"><code class="language-python">#路由urlpatterns = [    url(r'^books/$', views.BookInfoViewSet.as_view({'get':'action函数名'{)),    #示例：url(r'^books/$', views.BookInfoViewSet.as_view({'get':'latest'{)),]</code></pre><blockquote><p>之后，使用<code>http://127.0.0.1:8000/app01/books/</code>进行测试</p></blockquote><p>或者使用装饰器方法：</p><pre class="language-python" data-language="python"><code class="language-python">from rest_framework.decorators import action@action(methods=['get'],detail=False,url_path='bookw')def use(self,request):    return Response({'name':'天听'{)'''http://127.0.0.1:8000/app01/book/bookw/如果不加url_path，路由就成了http://127.0.0.1:8000/app01/book/use/'''</code></pre><blockquote><p>注意，此写法不需要再注册路由，需要在装饰器内部进行定义<br><code>url_path</code><br>如果不定义<code>url_path</code>，路由默认为函数名</p><p><code>detail=False</code>表示不需要匹配主键的正则，函数不需要传入主键就设为False</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库自定义字段</title>
      <link href="/posts/606/"/>
      <url>/posts/606/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在以往的数据库使用中，我们通常在一个数据库里操作某些表，如果有很多字段不同但目的相同的表，则需要建立很多的表来完成需求，这时候，可以通过在一个字段里添加多个数据来实现</p></blockquote><blockquote><p>比如，工单的创建，假如有请假，外购两个工单，请假需要的字段为请假时间，请假理由，而外购的工单需要价格，理由，而两个工单的审批人也都不同，但是，要求两张工单都在同一张表里</p><p>相信很多入门的程序猿到这里已经要提刀砍人了，难道要把两个工单的全部字段建出来，然后根据不同的工单来添加哪些数据，不添加哪些数据吗？</p></blockquote><p>是的，上面的也是一个办法，但是，这样除了效率和辨识度的问题，还有一个最重要的问题就是，low</p><p>简单的来画个图吧</p><p><img src="/posts/606/sss.png" loading="lazy"></p><p>建立这样一张表，的确能够满足需求，只需要在创建外购的时候，请假的两个字段不填就好了(请忽略这张比较low的表)</p><p>而如果使用了自定义字段，就会是这样</p><p><img src="/posts/606/image-20201115215841546.png" loading="lazy"></p><p>怎么样，是不是简便的多了，只需要在取出该条数据的时候，多一个自定义字段的解析罢了，而且还节省空间和性能(请再次忽略这张low图)</p><p>推荐使用json数据类型储存自定义字段，这样无论是使用哪种语言来实现这项需求，都非常的简单</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRF基本操作</title>
      <link href="/posts/23179/"/>
      <url>/posts/23179/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>DRF作为django的伴生框架，也封装了很多及其好用的东西</p><p>1.认证 2.权限 3.限流 4.序列化 5.分页 </p></blockquote><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><blockquote><p>Drf内置的四种API认证方式：</p><p><strong>认证方式说明：</strong></p><p>**<a href="https://www.django-rest-framework.org/api-guide/authentication/#basicauthentication">BasicAuthentication</a>**每次提交请求的时候附加用户名和密码来进行认证</p><p>**<a href="https://www.django-rest-framework.org/api-guide/authentication/#tokenauthentication">TokenAuthentication</a>**每次提交请求的时候在HTTP headers里附加Token进行认证</p><p>**<a href="https://www.django-rest-framework.org/api-guide/authentication/#sessionauthentication">SessionAuthentication</a>**用户登录之后系统在cookies存入sessionid进行认证</p><p>**<a href="https://www.django-rest-framework.org/api-guide/authentication/#remoteuserauthentication">RemoteUserAuthentication</a>**通过web服务器认证(apache/nginx这些)</p><p>我选择的是基于Token的认证，客户端登录之后维护一个token，每次请求附加到HTTP headers，还算是方便。</p><p>Drf还可以自定义认证方式，只要继承<code>authentication.BaseAuthentication</code>这个类然后重写<code>authenticate</code>方法就好了。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">class MyAuthentication(BaseAuthentication):def authenticate(self, request):# 认证逻辑，如果认证通过，返回两个值# 如果认证失败，抛出Authentication异常token = request.GET.get('token')if token:user_token = UserToken.objects.filter(token=token).first()# 认证通过if user_token:return user_token.user,tokenelse:raise AuthenticationFailed('认证失败')else:raise AuthenticationFailed('请求地址中需要携带token')</code></pre><p>然后在视图中使用即可</p><pre class="language-python" data-language="python"><code class="language-python">class StudentViewSet(viewsets.ModelViewSet):authentication_classes = [SessionAuthentication, BasicAuthentication,MyAuthentication]permission_classes = [IsAuthenticated]queryset = Student.objects.all()    serializer_class = StudentSerializer</code></pre><ul><li>创建认证类：继承<code>BaseAuthentication</code>、重写<code>authenticate</code>方法</li><li><code>authenticate()</code>返回值</li></ul><ol><li><code>None</code>：当前认证不管，等下一个认证来执行</li><li><code>raise exceptions.AuthenticationFailed('用户认证失败')</code></li><li>有返回值元组形式：（元素1，元素2）元素1复制给<code>request.user</code>、元素2复制给<code>request.auth</code></li></ol><p>在<code>settings.py</code>中可以配置默认的认证方式，这里我添加了三个：</p><pre class="language-text" data-language="text"><code class="language-text">REST_FRAMEWORK = {    # 身份验证    'DEFAULT_AUTHENTICATION_CLASSES': (        'rest_framework.authentication.BasicAuthentication',        'rest_framework.authentication.TokenAuthentication',        'rest_framework.authentication.SessionAuthentication',    )}</code></pre><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="API授权"><a href="#API授权" class="headerlink" title="API授权"></a><strong>API授权</strong></h3><p>Drf的接口权限有以下几种：</p><ul><li>**<a href="https://www.django-rest-framework.org/api-guide/permissions/#allowany">AllowAny</a>**：允许所有，登不登录无所谓</li><li>**<a href="https://www.django-rest-framework.org/api-guide/permissions/#isauthenticated">IsAuthenticated</a>**：登录了才能访问</li><li>**<a href="https://www.django-rest-framework.org/api-guide/permissions/#isadminuser">IsAdminUser</a>**：管理员才能访问</li><li>**<a href="https://www.django-rest-framework.org/api-guide/permissions/#isauthenticatedorreadonly">IsAuthenticatedOrReadOnly</a>**：顾名思义，不登录只读，登录才能写入</li><li>**<a href="https://www.django-rest-framework.org/api-guide/permissions/#djangomodelpermissions">DjangoModelPermissions</a>**：根据Django Auth的配置（权限细化到每个model）</li><li><strong><a href="https://www.django-rest-framework.org/api-guide/permissions/#djangomodelpermissionsoranonreadonly">DjangoModelPermissionsOrAnonReadOnly</a></strong></li><li>**<a href="https://www.django-rest-framework.org/api-guide/permissions/#djangoobjectpermissions">DjangoObjectPermissions</a>**：配合第三方权限控制，细化到每个对象</li></ul><p>一般来说小网站用到<code>DjangoModelPermissions</code>就是够用的，或者干脆简单一点，用<code>IsAuthenticated</code>和<code>queryset</code>限定请求的数据即可。</p><p>介绍完了基本概念，来看看代码中是如何操作的。</p><p>对于操作用户信息的viewset，我只用了<code>permissions.IsAuthenticated</code>这个权限，然后覆盖了<code>ReadOnlyModelViewSet</code>的<code>get_queryset</code>方法，把queryset变成只包括当前用户，这样就保证了一个用户只能操作自己的信息。</p><pre class="language-python" data-language="python"><code class="language-python">from rest_framework import authentication, permissions, viewsetsclass UserViewSet(viewsets.ReadOnlyModelViewSet):    permission_classes = [permissions.IsAuthenticated]    serializer_class = UserSerializer    def get_queryset(self):        return User.objects.filter(pk=self.request.user.pk)</code></pre><p>viewset的action同样可以使用权限，加在装饰器的参数上即可：</p><pre class="language-python" data-language="python"><code class="language-python">@action(detail=True, methods=['GET'], permission_classes=[permissions.IsAuthenticated])def some_actions(self, request, pk=None):    dosomething    return Response(SomeSerializer(some_data, many=True).data)</code></pre><p>这里提一下装饰器的detail参数，这个代表了是对列表操作还是对单个对象操作，True就是对单个对象。</p><blockquote><p>ApiView和ViewSet同样通过在类字段中加入<code>authentication_classes</code>和<code>permission_classes</code>实现认证和授权。</p></blockquote><h2 id="分页-PAGINATION"><a href="#分页-PAGINATION" class="headerlink" title="分页 PAGINATION"></a>分页 PAGINATION</h2><p>Drf和Django一样自带分页功能，很好用（当然也支持使用第三方的分页功能）。</p><p>首先进行配置（不配置的话使用默认配置），这里我设置每页显示十条记录：</p><pre class="language-text" data-language="text"><code class="language-text">REST_FRAMEWORK = {    # 设置分页    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',    'PAGE_SIZE': 10,}</code></pre><p>使用得最多的<code>ModelViewSet</code>已经自带分页了，这个我们不用操心，不过如果自己定义了action来返回列表数据的话，就没有分页，这时候要用<code>paginate_queryset</code>方法来处理。</p><p>代码如下：</p><pre class="language-text" data-language="text"><code class="language-text">@action(detail=False)def tag(self, request):    queryset = SomeModel.objects.all().order_by('-add_time')    page = self.paginate_queryset(queryset)    if page is not None:    return self.get_paginated_response(self.get_serializer(page, many=True).data)    return Response(self.get_serializer(queryset, many=True).data)</code></pre><p>可以看出Drf自动处理了不同页面的请求，不用像Django一样自己从GET或者POST数据里读取page，分页相关的方法直接在viewset对象里面，非常方便。</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>其实就是一个自定义的认证过程。</p><p>Drf内置有<code>BaseThrottle</code>、<code>SimpleRateThrottle</code>，后者是前者的之类。</p><ul><li><code>BaseThrottle</code> 需要自己写<code>allow_request</code>和<code>wait</code>方法，控制粒度更细</li><li><code>SimpleRateThrottle</code>重写<code>get_cache_key</code>和设置<code>scope</code>名称就可以，更简单</li></ul><h3 id="实现1分钟内只能访问3次的限流"><a href="#实现1分钟内只能访问3次的限流" class="headerlink" title="实现1分钟内只能访问3次的限流"></a><strong>实现1分钟内只能访问3次的限流</strong></h3><p><code>SimpleRateThrottle</code>代码如下：</p><pre class="language-python3" data-language="python3"><code class="language-python3">from rest_framework.throttling import SimpleRateThrottleclass VisitThrottle(SimpleRateThrottle):    '''匿名用户60s只能访问三次（根据ip）'''    scope = 'throttle'   #这里面的值，自己随便定义，settings里面根据这个值配置throttle    def get_cache_key(self, request, view):        #通过ip限制节流        return self.get_ident(request)class UserThrottle(SimpleRateThrottle):    '''登录用户60s可以访问10次'''    scope = 'userThrottle'    #这里面的值，自己随便定义，settings里面根据这个值配置userThrottle    def get_cache_key(self, request, view):        return request.user.user_id</code></pre><p><code>BaseThrottle</code> 代码如下：</p><pre class="language-python3" data-language="python3"><code class="language-python3">from rest_framework.throttling import BaseThrottleimport timeVISIT_RECORD = {}   #保存访问记录class VisitThrottle(BaseThrottle):    '''60s内只能访问3次'''    def __init__(self):        self.history = None   #初始化访问记录    def allow_request(self,request,view):        #获取用户ip (get_ident)        remote_addr = self.get_ident(request)        ctime = time.time()        #如果当前IP不在访问记录里面，就添加到记录        if remote_addr not in VISIT_RECORD:            VISIT_RECORD[remote_addr] = [ctime,]     #键值对的形式保存            return True    #True表示可以访问        #获取当前ip的历史访问记录        history = VISIT_RECORD.get(remote_addr)        #初始化访问记录        self.history = history        #如果有历史访问记录，并且最早一次的访问记录离当前时间超过60s，就删除最早的那个访问记录，        #只要为True，就一直循环删除最早的一次访问记录        while history and history[-1] &lt; ctime - 60:            history.pop()        #如果访问记录不超过三次，就把当前的访问记录插到第一个位置（pop删除最后一个）        if len(history) &lt; 3:            history.insert(0,ctime)            return True    def wait(self):        '''还需要等多久才能访问'''        ctime = time.time()        return 60 - (ctime - self.history[-1])</code></pre><h3 id="配置节流"><a href="#配置节流" class="headerlink" title="配置节流"></a><strong>配置节流</strong></h3><pre class="language-text" data-language="text"><code class="language-text">#全局REST_FRAMEWORK = {    # 设置全局节流    "DEFAULT_THROTTLE_CLASSES":['api.utils.throttle.UserThrottle'],   #全局配置，登录用户节流限制（10/m）    # 设置访问频率    "DEFAULT_THROTTLE_RATES":{        'throttle':'3/m',         #没登录用户3/m，throttle就是scope定义的值,通过IP地址        'userThrottle':'10/m',    #登录用户10/m，userThrottle就是scope定义的值， 通过user_id    }}# 局部：在类视图中添加throttle_classes = [VisitThrottle,]</code></pre><p><a href="https://zhuanlan.zhihu.com/p/113367282">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊天室</title>
      <link href="/posts/15462/"/>
      <url>/posts/15462/</url>
      
        <content type="html"><![CDATA[<p>最近，在写一个简单的基于websocket和django的聊天室，来分享一下我这个过程</p><ul><li><p>首先是思路，聊天室说起来简单，但实际操作起来完全不是那么回事了，除了简单的连接之外，完全没有一点头绪</p><blockquote><p>把聊天室的功能梳理了一下，然后拆开，分成了前端连接，前端发送，后端连接，实时推送消息，记录保存这五个方面</p></blockquote></li><li><p>先来说一说前端连接的问题，其实也就是一个简单的<code>websocket</code>连接，不过是增加了一个断开重连</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">websocketlink(uid){      if('WebSocket' in window){      //  生成websocket链接      console.log('支持')      var ws = new WebSocket('ws://192.168.1.157:8000/chat_room_websocket/?uid='+uid);      // var ws = new WebSocket('ws://192.168.1.157:8000/chat_room_websocket/');      // 连接成功      ws.onopen = function(){        ws.send(uid);      {      // 收到数据      ws.onmessage=(evt)=&gt;{        // 将获取信息打印        var received_msg = evt.data        this.msglist.push(JSON.parse(received_msg))        console.log(evt)              // 连接关闭      ws.onclose=()=&gt;{        console.log('链接已关闭')        this.websocketlink(localStorage.getItem('uid'))      {      // 连接报错      ws.error=()=&gt;{        this.websocketlink(localStorage.getItem('uid'))      {</code></pre><blockquote><p>这里，我把连接封装起来，在报错或者关闭时，重新连接</p></blockquote></li><li><p>页面操作上，点击按钮，发送消息，这都是简单的请求<code>API</code>接口的操作，这里就不多详述了</p></li><li><p>后端连接，也是一个简单的<code>dwebsocket</code>连接</p><pre class="language-python" data-language="python"><code class="language-python">clients = {{# 链接websocket接口@accept_websocketdef chat_room_websocket(request):    if request.is_websocket():        while True:            message = request.websocket.wait()            if not message:                break            else:                # 连接的用户的id                uid = message.decode()                # 加入到字典中                clients[uid] = request.websocket</code></pre><blockquote><p>和之前一样，定义公共变量，将连接的id和连接对象放进去</p></blockquote></li><li><p>存储，发送消息不难，存储其实也不难，无论是存到mysql还是redis还是文件都可以自行选择，这里，我存的是自己的文件，根据用户的id生成文件，时间戳+消息追加性的存储</p><pre class="language-python" data-language="python"><code class="language-python"># 时间戳，毫秒，为了之后取消息记录，做一下准备t = time.time()timestamp1 = int(round(t * 1000))# 加个换行，直接存s = str(timestamp1)+ ':' + msg + '\n'with open('chat_record/%s.txt' % uid, 'a', encoding='utf-8') as f:                f.write(s)</code></pre></li><li><p>实时推送消息，如果有人在聊天室发了消息，却看不到，这就非常的伤脑筋，为了实现简单的推送消息，将公共变量中的所有连接，遍历一下，然后发送给所有人</p><pre class="language-python" data-language="python"><code class="language-python"># 遍历所有的连接用户for client in clients:    # 构造返回数据，需要编一下码message = json.dumps({'username':username,'msg':msg{,ensure_ascii=False)    # 发送消息    clients[client].send(message.encode('utf-8'))</code></pre></li><li><p>后端推送，这里我是传了图片，为了更加的人性化。只发文字不发图片的聊天室是没有灵魂的</p><blockquote><p>另外，我做了一个<code>redis</code>限流，这个可以忽略不计</p><p>另外的另外， 因为我前端稀碎， 有些多余的代码可以自行过滤一下</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">class SendMessage(APIView):    def post(self,request):                # 传图片和发送消息是两个接口，所以，获取用户id的方法也不一样，这里写的多余了                msg = request.data.get('msg')        uid = request.data.get('uid')        image = request.FILES.get('file')        if image:            uid = request.GET.get('uid')      # redis限流        redis_client = get_redis_connection('chat_room')        try:            redis_client.get(uid)        except Exception as e:            print(e)            return Response({'code': 1001, 'msg': '发送频繁'{)        redis_client.hincrby(uid,'num')        redis_client.expire(uid, 5)                # 这里的名字是根据连接查了一下数据库，可以忽略        username = User.objects.filter(id=uid).first().username        # 如果要获取两个人的聊天记录，在创建文件时，可以用两个人的id来组成文件名                # 构造时间戳        t = time.time()        timestamp1 = int(round(t * 1000))        # 如果传的是消息，发送消息顺便存储到本地        if msg:            for client in clients:                message = json.dumps({'username':username,'msg':msg{,ensure_ascii=False)                clients[client].send(message.encode('utf-8'))                s = str(timestamp1)+ ':' + msg + '\n'                with open('chat_record/%s.txt' % uid, 'a', encoding='utf-8') as f:                    f.write(s)        # 写图片文件,如果传了文件，则写入到文件中，然后拼接一个url返回        elif image:            with open(os.path.join(CHAT_RECORD_ROOT, '', image.name), 'wb') as f:                for chunk in image.chunks():                    f.write(chunk)                message = json.dumps({'username': username, 'msg':('http://192.168.1.157:8000/static/chat_record/'+image.name){, ensure_ascii=False)                for client in clients:                    clients[client].send(message.encode('utf-8'))            s = str(timestamp1)+':'+'http://192.168.1.157:8000/static/chat_record/'+str(image.name) + '\n'            with open('chat_record/%s.txt' % uid, 'a', encoding='utf-8') as f:                f.write(s)        return Response({'message': 'ok'{)</code></pre></li><li><p>发送与渲染</p><blockquote><p>判断：indexOf() —&gt;判断是否有某个元素，格式为 <strong>字符串&amp;&amp;字符串.indexOf(‘子串’)</strong></p><p>如果不存在，则返回一个**-1**</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;a-modal v-model='show' @ok="myok"&gt;          &lt;span v-for="i in msglist" :key="i.username"&gt;          &lt;p v-if='i.msg &amp;&amp; i.msg.indexOf(".jpg")!=-1'&gt;{{i.username{{:&lt;a-avatar :size="44" :src=i.msg style='margin-left: 20px'&gt;&lt;/a-avatar&gt;&lt;/p&gt;          &lt;p v-else&gt;{{i.username{{:{{i.msg{{&lt;/p&gt;          &lt;/span&gt;          &lt;span&gt;          &lt;a-form-item label="发送消息" v-bind="formlayout" &gt;              &lt;a-input v-model="msg" /&gt;          &lt;/a-form-item&gt;                    &lt;a-form-item v-bind="buttonlayout"&gt;              &lt;a-button type='primary' @click="send_msg"&gt;发送消息&lt;/a-button&gt;              &lt;a-upload              name="file"              :multiple="true"              :action=uid              :headers="headers"              @change="handleChange"              &gt;                &lt;a-button&gt; &lt;a-icon type="upload" /&gt; 发送文件 &lt;/a-button&gt;            &lt;/a-upload&gt;                      &lt;/a-form-item&gt;          &lt;/span&gt;        &lt;/a-modal&gt;</code></pre><p>一个简单的聊天室就做好啦</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Celery</title>
      <link href="/posts/63146/"/>
      <url>/posts/63146/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><h3 id="1-1-celery应用举例"><a href="#1-1-celery应用举例" class="headerlink" title="1.1 celery应用举例"></a>1.1 celery应用举例</h3><ul><li><p>Celery 是一个 基于python开发的分布式异步消息任务队列，通过它可以轻松的实现任务的异步处理，如果你的业务场景中需要用到异步任务，就可以考虑使用celery</p></li><li><p>你想对100台机器执行一条批量命令，可能会花很长时间 ，但你不想让你的程序等着结果返回，而是给你返回 一个任务ID,你过一段时间只需要拿着这个任务id就可以拿到任务执行结果， 在任务执行ing进行时，你可以继续做其它的事情</p></li><li><p>Celery 在执行任务时需要通过一个消息中间件来接收和发送任务消息，以及存储任务结果， 一般使用rabbitMQ or Redis</p></li></ul><h3 id="1-2-Celery有以下优点"><a href="#1-2-Celery有以下优点" class="headerlink" title="1.2 Celery有以下优点"></a>1.2 Celery有以下优点</h3><ul><li>简单：一单熟悉了celery的工作流程后，配置和使用还是比较简单的</li><li>高可用：当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务</li><li>快速：一个单进程的celery每分钟可处理上百万个任务</li><li>灵活： 几乎celery的各个组件都可以被扩展及自定制</li></ul><h3 id="1-3-Celery-特性"><a href="#1-3-Celery-特性" class="headerlink" title="1.3 Celery 特性"></a>1.3 Celery 特性</h3><ul><li>方便查看定时任务的执行情况, 如 是否成功, 当前状态, 执行任务花费的时间等.</li><li>可选 多进程, Eventlet 和 Gevent 三种模型并发执行.</li><li>Celery 是语言无关的.它提供了python 等常见语言的接口支持.</li></ul><h2 id="Celery组件"><a href="#Celery组件" class="headerlink" title="Celery组件"></a>Celery组件</h2><h3 id="2-1-Celery-扮演生产者和消费者的角色"><a href="#2-1-Celery-扮演生产者和消费者的角色" class="headerlink" title="2.1 Celery 扮演生产者和消费者的角色"></a>2.1 Celery 扮演生产者和消费者的角色</h3><ul><li><p><strong>Celery Beat :</strong> 任务调度器. Beat 进程会读取配置文件的内容, 周期性的将配置中到期需要执行的任务发送给任务队列.</p></li><li><p><strong>Celery Worker :</strong> 执行任务的消费者, 通常会在多台服务器运行多个消费者, 提高运行效率.</p></li><li><p><strong>Broker :</strong> 消息代理, 队列本身. 也称为消息中间件. 接受任务生产者发送过来的任务消息, 存进队列再按序分发给任务消费方(通常是消息队列或者数据库).</p></li><li><p><strong>Producer :</strong> 任务生产者. 调用 Celery API , 函数或者装饰器, 而产生任务并交给任务队列处理的都是任务生产者.</p></li><li><p><strong>Result Backend :</strong> 任务处理完成之后保存状态信息和结果, 以供查询.</p></li></ul><h3 id="2-2-celery架构图"><a href="#2-2-celery架构图" class="headerlink" title="2.2 celery架构图"></a>2.2 celery架构图</h3><p><img src="/posts/63146/602127040446.png" loading="lazy"> </p><h3 id="2-3-产生任务的方式"><a href="#2-3-产生任务的方式" class="headerlink" title="2.3 产生任务的方式"></a>2.3 产生任务的方式</h3><ul><li><p>发布者发布任务(WEB 应用)</p></li><li><p>任务调度按期发布任务(定时任务)</p></li></ul><h3 id="2-4-celery-依赖三个库-这三个库-都由-Celery-的开发者开发和维护"><a href="#2-4-celery-依赖三个库-这三个库-都由-Celery-的开发者开发和维护" class="headerlink" title="2.4 celery 依赖三个库: 这三个库, 都由 Celery 的开发者开发和维护."></a>2.4 celery 依赖三个库: 这三个库, 都由 Celery 的开发者开发和维护.</h3><ul><li><code>billiard :</code> 基于 Python2.7 的 multisuprocessing 而改进的库, 主要用来提高性能和稳定性.</li><li><code>librabbitmp : </code>C 语言实现的 Python 客户端</li><li><code>kombu :</code> Celery 自带的用来收发消息的库, 提供了符合 Python 语言习惯的, 使用 AMQP 协议的高级借口.</li></ul><h2 id="配置Celery"><a href="#配置Celery" class="headerlink" title="配置Celery"></a>配置Celery</h2><h3 id="安装celery"><a href="#安装celery" class="headerlink" title="安装celery"></a>安装celery</h3><pre class="language-python" data-language="python"><code class="language-python">pip install celery @ https://github.com/celery/celery/tarball/master</code></pre><h3 id="新建celery-main-py配置celery"><a href="#新建celery-main-py配置celery" class="headerlink" title="新建celery/main.py配置celery"></a>新建<code>celery/main.py</code>配置celery</h3><pre class="language-python" data-language="python"><code class="language-python"># celery_task/main.pyimport osfrom celery import Celery# 定义celery实例, 需要的参数, 1, 实例名, 2, 任务发布位置, 3, 结果保存位置app = Celery('mycelery',             broker='redis://127.0.0.1:6379/14',  # 任务存放的地方              backend='redis://127.0.0.1:6379/15')  # 结果存放的地方@app.taskdef add(x, y):    return x + y</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="启动celery"><a href="#启动celery" class="headerlink" title="启动celery"></a>启动celery</h3><pre class="language-python" data-language="python"><code class="language-python">'''1.启动celery'''#1.1 单进程启动celerycelery -A main worker -l INFO#1.2 celery管理celery multi start celery_test -A celery_test -l debug --autoscale=50,5        # celery并发数：最多50个，最少5个ps auxww|grep "celery worker"|grep -v grep|awk '{print $2{'|xargs kill -9       # 关闭所有celery进程</code></pre><h2 id="1-使用celery异步发送短信"><a href="#1-使用celery异步发送短信" class="headerlink" title="1.使用celery异步发送短信"></a>1.使用celery异步发送短信</h2><h3 id="1-1-在celery-task-mian-py中添加发送短信函数"><a href="#1-1-在celery-task-mian-py中添加发送短信函数" class="headerlink" title="1.1 在celery_task/mian.py中添加发送短信函数"></a>1.1 在<code>celery_task/mian.py</code>中添加发送短信函数</h3><pre class="language-python" data-language="python"><code class="language-python"># celery项目中的所有导包地址, 都是以CELERY_BASE_DIR为基准设定.# 执行celery命令时, 也需要进入CELERY_BASE_DIR目录执行.CELERY_BASE_DIR = os.path.dirname(os.path.abspath(__file__))@app.task(bind=True)def send_sms_code(self, mobile, datas):    sys.path.insert(0, os.path.join(CELERY_BASE_DIR, '../syl'))    # 在方法中导包    from libs.rl_sms import send_message    # time.sleep(5)    try:        # 用 res 接收发送结果, 成功是:０，　失败是：－１        res = send_message(mobile, datas)    except Exception as e:        res = '-1'    if res == '-1':        # 如果发送结果是 -1  就重试.        self.retry(countdown=5, max_retries=3, exc=Exception('短信发送失败'))</code></pre><h3 id="1-2-在verifications-views-py中添加celery发送短信视图函数"><a href="#1-2-在verifications-views-py中添加celery发送短信视图函数" class="headerlink" title="1.2 在verifications/views.py中添加celery发送短信视图函数"></a>1.2 在<code>verifications/views.py</code>中添加celery发送短信视图函数</h3><pre class="language-python" data-language="python"><code class="language-python">class SmsCodeView(APIView):    """使用apiview的限流"""    # 1. 所有人可以访问    permission_classes = (AllowAny,)    def post(self, request):        # 1. 获取参数        phone = request.data.get('phone')  # 手机号        image_code = request.data.get('image_code')  # 图片验证码        image_code_uuid = request.data.get('image_code_uuid')  # 前端生成的uuid        # 2. 检查参数        if not all([phone, image_code, image_code_uuid]):            return Response({"code": 999, "msg": "参数不全"{)        if not re.match(r'^1[3456789]\d{9{$', phone):            return Response({"code": 999, "msg": "手机号码不正确"{)        # 3. 检查是否发送        redis_client = get_redis_connection('img_code')        phone_exists = redis_client.get(phone)        if phone_exists:            return Response({"code": 999, "msg": "频繁发送, 请稍后再试"{)        # 验证图形验证码        redis_image_code = redis_client.get(image_code_uuid)  # bytes        if redis_image_code:            # bytes 转成 string            redis_image_code = redis_image_code.decode()        # 比较用户提供的图片内容是否和redis中保存的一致        if image_code.upper() != redis_image_code:            return Response({'code': 999, 'msg': '图片验证码不正确'{)        # 4. 发送        code = '%06d' % random.randint(0, 999999)  # 随机6位验证码        from syl.settings import BASE_DIR        sys.path.insert(0, os.path.join(BASE_DIR, '../celery_task'))        from main import send_sms_code  # 必须这么写, 从main中导包        send_sms_code.delay(phone, (code, "5"))        print(code)        # 5.使用 pipeline 批量操作        pl = redis_client.pipeline()    # 实例化pipeline对象        pl.setex(phone, 60 * 5, code)   # 存储phone:code, 5分钟有效期        pl.delete(image_code_uuid)      # 从redis中删除这个图片验证码, 以防再次被使用        pl.execute()        # 6. 返回结果        return Response({"code": 0, "msg": "短信发送成功"{)</code></pre><h3 id="1-3-添加路由"><a href="#1-3-添加路由" class="headerlink" title="1.3 添加路由"></a>1.3 添加路由</h3><pre class="language-python" data-language="python"><code class="language-python">urlpatterns = [    path('sms_codes/', views.SmsCodeView.as_view()),]</code></pre><h2 id="2-测试接口"><a href="#2-测试接口" class="headerlink" title="2.测试接口"></a>2.测试接口</h2><ul><li>接口URL</li></ul><pre class="language-none"><code class="language-none">http://192.168.56.100:8888/user/sms_codes/</code></pre><ul><li>请求携带参数</li></ul><pre class="language-python" data-language="python"><code class="language-python">{    "phone": 18538752511,    "image_code":"aed3",                                         # 前端生成的 图形验证码    "image_code_uuid":"de8edce2-fc9f-11ea-9325-005056c00008"     # 前端生成的uuid{</code></pre><h2 id="django添加检查用户名和手机号数量接口"><a href="#django添加检查用户名和手机号数量接口" class="headerlink" title="django添加检查用户名和手机号数量接口"></a>django添加检查用户名和手机号数量接口</h2><h3 id="1-1-在user-urls-py中添加"><a href="#1-1-在user-urls-py中添加" class="headerlink" title="1.1 在user/urls.py中添加"></a>1.1 在<code>user/urls.py</code>中添加</h3><pre class="language-python" data-language="python"><code class="language-python">urlpatterns = [    path('count/', views.RegCountView.as_view()),  # 查询用户名手机号使用量的视图,  /user/count/]</code></pre><h3 id="1-2-在user-views-py中添加视图函数"><a href="#1-2-在user-views-py中添加视图函数" class="headerlink" title="1.2 在user/views.py中添加视图函数"></a>1.2 在<code>user/views.py</code>中添加视图函数</h3><pre class="language-python" data-language="python"><code class="language-python"># 查询用户数量接口class RegCountView(APIView):    # 注册时需要验证的用户名和手机号是否使用    # 自定义权限类    permission_classes = (AllowAny,)    def post(self, request):        # 接收参数:  验证的内容type: username/phone,  data: '用户名' 或者 '手机号',        datatype = request.data.get('type')        data = request.data.get('data')        if not all([data, datatype]):            return Response({'code': 999, 'msg': '参数不完整'{)        if datatype == 'username':            count = User.objects.filter(username=data).count()        if datatype == 'phone':            count = User.objects.filter(phone=data).count()        return Response({'code': 0, 'msg': '查询成功', 'data': {'type': datatype, 'count': count{{)</code></pre><h2 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h2><ul><li>测试接口URL</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript">http://192.168.56.100:8888/user/count/</code></pre><h2 id="完善注册接口"><a href="#完善注册接口" class="headerlink" title="完善注册接口"></a>完善注册接口</h2><h3 id="修改user-views-py中完善视图函数"><a href="#修改user-views-py中完善视图函数" class="headerlink" title="修改user/views.py中完善视图函数"></a>修改<code>user/views.py</code>中完善视图函数</h3><pre class="language-python" data-language="python"><code class="language-python"># 注册接口class RegisterView(APIView):    """    用户注册, 权限是: 匿名用户可访问    """    # 自定义权限类    permission_classes = (AllowAny,)    def post(self, request):        """        接收用户名,密码,手机号和验证码, 前端校验两遍一致性, 注册成功后返回成功, 然后用户自行登录获取token        1. 用户名        2. 密码        3. 手机号        4. 验证码        :param request:        :return:  {'code':0,'msg':'注册成功'{        code: "260361"        password: "123123"        phone: "13303479527"        username: "liangxuepeng"        """        username = request.data.get('username')        phone = request.data.get('phone')        code = request.data.get('code')        passwrod = request.data.get('password')        if all([username, passwrod, phone, code]):            pass        else:            return Response({'code': 999, 'msg': '参数不全'{)        # rand_name = self.randomUsername()        # 验证手机验证码        redis_client = get_redis_connection('verify_code')        code_redis = redis_client.get(phone)        if code_redis:            code_redis = code_redis.decode()        if not code == code_redis:            return Response({'code': 999, 'msg': '手机验证码错误'{)        user = User(username=username, phone=phone)        user.set_password(passwrod)        user.save()        return Response({'code': 0, 'msg': '注册成功'{)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> Celery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的垃圾回收机制</title>
      <link href="/posts/6d1d0248/"/>
      <url>/posts/6d1d0248/</url>
      
        <content type="html"><![CDATA[<h2 id="浅谈一下python的内存管理机制"><a href="#浅谈一下python的内存管理机制" class="headerlink" title="浅谈一下python的内存管理机制"></a>浅谈一下python的内存管理机制</h2><blockquote><p>python采用的是<strong>引用计数</strong>机制为主，<strong>标记-清除</strong>和<strong>分代回收</strong>两种机制为辅的策略</p></blockquote><p>在python中，每一个对象的核心就是一个结构体，它的内部有一个引用计数器，程序运行过程中会实时的更新ob_refcnt的值，来反映引用当前对象的名称数量，当某个对象的引用计数为0，那么它的内存就会被立即释放掉。</p><h2 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h2><blockquote><p>在Python中万物皆对象</p><p>不存在基本数据类型，<code>0, 1.2, True, False, "abc"</code>等，这些全都是对象</p><p>所有对象, 都会在内存中开辟一块空间进行存储</p></blockquote><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><blockquote><p>分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为三代，分别为年轻代(0代)，中年代(1代)，老年代(2代)，他们对应的是三个链表，它们的垃圾收集频率与对象的存活时间的增大而减小</p><p>新创建的对象都会分配在<strong>年轻代</strong>，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，以此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。</p><p>同时，分代回收是建立在标记清除技术基础之上。作为Python的辅助垃圾收集技术处理那些容器对象</p></blockquote><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>有三种情况会触发垃圾回收：</p><ol><li>调用<code>gc.collect()</code>,需要先导入<code>gc</code>模块。</li><li>当<code>gc</code>模块的计数器达到阀值的时候。</li><li>程序退出的时候。</li></ol><h4 id="gc模块"><a href="#gc模块" class="headerlink" title="gc模块"></a><code>gc</code>模块</h4><p><code>gc</code>模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而<code>gc</code>模块的一个主要功能就是解决循环引用的问题。</p><h2 id="多次赋值"><a href="#多次赋值" class="headerlink" title="多次赋值"></a>多次赋值</h2><blockquote><p>对于整数和短小的字符，Python会进行缓存，不会创建多个相同对象</p><p>此时，被多次赋值，只会有多份引用</p></blockquote><h2 id="id和hex"><a href="#id和hex" class="headerlink" title="id和hex"></a>id和hex</h2><p>在python的内置函数中，可以通过id获取内存地址(10进制)，通过hex()可以查看16进制地址</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo解决引用本地图片无法显示</title>
      <link href="/posts/52191/"/>
      <url>/posts/52191/</url>
      
        <content type="html"><![CDATA[<p>最近用起hexo，但是发现文章中引用本地图片时总是显示不出来</p><p>花费了许久时间才解决了这个问题，因此将一些解决经验整理出来，希望能帮助到大家</p><h3 id="一、插件安装与配置"><a href="#一、插件安装与配置" class="headerlink" title="一、插件安装与配置"></a>一、插件安装与配置</h3><p>首先我们需要安装一个图片路径转换的插件，这个插件名字是<strong>hexo-asset-image</strong></p><pre class="language-none"><code class="language-none">npm install https://github.com/CodeFalling/hexo-asset-image --save</code></pre><p>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) {  return str.split(m, i).join(m).length;}var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data){  var config = hexo.config;  if(config.post_asset_folder){    var link = data.permalink;if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)   var beginPos = getPosition(link, '/', 1) + 1;else   var beginPos = getPosition(link, '/', 3) + 1;// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".var endPos = link.lastIndexOf('/') + 1;    link = link.substring(beginPos, endPos);    var toprocess = ['excerpt', 'more', 'content'];    for(var i = 0; i &lt; toprocess.length; i++){      var key = toprocess[i];       var $ = cheerio.load(data[key], {        ignoreWhitespace: false,        xmlMode: false,        lowerCaseTags: false,        decodeEntities: false      });      $('img').each(function(){if ($(this).attr('src')){// For windows style path, we replace '\' to '/'.var src = $(this).attr('src').replace('\\', '/');if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;   !/^\s*\//.test(src)) {  // For "about" page, the first part of "src" can't be removed.  // In addition, to support multi-level local directory.  var linkArray = link.split('/').filter(function(elem){return elem != '';  });  var srcArray = src.split('/').filter(function(elem){return elem != '' &amp;&amp; elem != '.';  });  if(srcArray.length &gt; 1)srcArray.shift();  src = srcArray.join('/');  $(this).attr('src', config.root + link + src);  console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src);}}else{console.info&amp;&amp;console.info("no src attr, skipped...");console.info&amp;&amp;console.info($(this));}      });      data[key] = $.html();    }  }});</code></pre><p>打开_config.yml文件，修改下述内容</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">post_asset_folder: true</code></pre><hr><p>然后，无论是自己创建MarkDown文件还是使用命令创建，如果传了图片，图片一定要保存到跟MarkDown文件名一致的文件夹中，然后在Markdown中通过相对路径来进行引用</p><p>好啦，问题解决的简单粗暴，希望大家能够相互帮助，在码农的世界里一起成长</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搜索功能</title>
      <link href="/posts/20009/"/>
      <url>/posts/20009/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Hexo提供了一个插件来实现搜索的功能，但是，不知道什么原因，按照以下步骤操作，我的搜索功能还是没能实现</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript">npm install hexo-generator-search --save</code></pre><p>然后在hexo根目录的<code>_config.yml</code>下添加：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">search:  path: search.xml  field: post  format: html  limit: 100</code></pre><p>在你的主题themes目录下找到<code>_config.yml</code>，然后添加:</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">local_search:  enable: true  trigger: auto  top_n_per_article: 1</code></pre><p>一般来说，这时候就已经可以实现搜索功能了，但是我遇到的错误比较奇怪，之后，经过一系列的试验，终于找到了解决办法</p><p>遇到难点的朋友们，可以尝试一下</p><p>找到你博客主题的<code>search.ejs</code>模板文件，注意是<code>ejs</code>,修改下面代码</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">&lt;script type="text/javascript"&gt;$(function () {    searchFunc("&lt;%= config.root %&gt;" + "search.xml", 'searchInput', 'searchResult');});&lt;/script&gt;</code></pre><p>也是改为json格式的文件</p><blockquote><p>现在的网上，基本上遇到一个问题，几乎回答全是千篇一律，毫无营养可言，只要一条路走不通，就走不通了，非常的让人抓狂，但是，还有不少真正的大神在认真的在为小白解答，遇到这种情况，希望不要浮躁，慢慢的寻找解决办法</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastAPI学习之路-2 SQLAlchemy</title>
      <link href="/posts/944/"/>
      <url>/posts/944/</url>
      
        <content type="html"><![CDATA[<h3 id="SQLAlchemy简介"><a href="#SQLAlchemy简介" class="headerlink" title="SQLAlchemy简介"></a>SQLAlchemy简介</h3><blockquote><p>它是一个ORM(Object-Relational Mapping)框架，是python最好的ORM工具之一，为高效和高性能的数据库访问设计，实现了完整的企业级持久模型</p><p>提示一点：ORM并非是非用不可，但是，为了代码的健壮性，我们最好还是使用ORM，一方面，为了提高开发效率，另一方面，为了使别人能够看懂代码。</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装sqlalchemy：</p><pre class="language-python" data-language="python"><code class="language-python">pip install sqlalchemy</code></pre><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><blockquote><p>所有的关系型数据库，都可以通过这样连接</p><pre class="language-none"><code class="language-none">'数据库类型+数据库驱动名称://用户名:密码@机器地址:端口号/数据库名'</code></pre></blockquote><p>我们就拿mysql打个比方：</p><blockquote><p>需要安装pymysql，因为引擎基于pymysql</p><p><code>pip install pymysql</code></p></blockquote><pre class="language-python" data-language="python"><code class="language-python"># 首先，导包from sqlalchemy import create_engine# 创建数据库连接connect = create_engine('mysql+pymysql://root:mySQL@localhost:3306/test01')# 可以顺便指定一下编码方式# create_engine('mysql+pymysql://root:mySQL@localhost:3306/test01?charset=utf8')</code></pre><p>这样，我们就能连接上数据库了</p><h4 id="描述表结构-模型"><a href="#描述表结构-模型" class="headerlink" title="描述表结构(模型)"></a>描述表结构(模型)</h4><blockquote><p>要使用 ORM, 我们需要将数据表的结构用 ORM 的语言描述出来。SQLAlchmey 提供了一套 Declarative 系统来完成这个任务。我们以创建一个 <code>user</code> 表为例，看看它是怎么用 SQLAlchemy 的语言来描述的</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from sqlalchemy.ext.declarative import declarative_baseModelBase = declarative_base() #&lt;-元类class User(ModelBase):    # 定义表名    __tablename__ = "user"    # 声明字段    id = Column(Integer, primary_key=True)    username = Column(String(length=255))    password = Column(String(length=255))</code></pre><blockquote><p>这个模型，是对数据表结构的映射，无论是进行迁移文件还是操作数据库，都需要使用到它</p></blockquote><h4 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h4><blockquote><p>一对多，也就是我们所谓的外键，假如，有个user表，要求每个user都要有一个角色，我们就需要另外建立一张角色表，来通过外键连接角色表，用来实现关联，一个角色可以被多个user关联，一个user只能有一个角色，这，就是一对多的关系</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">class User(ModelBase):    # 定义表名    __tablename__ = "user"    # 声明字段    id = Column(Integer, primary_key=True)    username = Column(String(length=255))    password = Column(String(length=255))    role = Column(Integer,ForeignKey('role.id'))    class Role(ModelBase):    __tablename__ = 'role'    id = Column(Integer, primary_key=True)    name = Column(String(length=255))    isnn = relationship('User')</code></pre><blockquote><p>可以看到，我们定义了ForeignKey来指定关联哪张表，连接哪个字段</p><p>而“一”这里，提供了一个relationship方法来表明两个模型中的关系</p><p>而relationship有一个<code>backref</code>，来指定反向访问的属性名称，在我们的这个例子中，就是用来反向访问，都有哪些用户是这个角色</p></blockquote><hr><h4 id="添加数据（Create）"><a href="#添加数据（Create）" class="headerlink" title="添加数据（Create）"></a>添加数据（Create）</h4><p>我们依赖上方的代码来进行添加</p><blockquote><p>⚠！！！在SQLAlchemy中，CRUD都是通过会话(session)进行的，所以我们必须要先创建会话，每一个SessionLocal实例就是一个数据库session</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from sqlalchemy.orm import sessionmaker# 创建DBSession类型# flush()是指发送数据库语句到数据库，但数据库不一定执行写入磁盘；commit()是指提交事务，将变更保存到数据库文件DBSession = sessionmaker(bind=connect,autoflush=False, autocommit=False, expire_on_commit=True)# 创建session对象session = DBSession()# 创建新User对象(我们要添加的数据)new_user = User(id=1,username='Bob',password='123')# 添加到sessionsession.add(new_user)# 提交即保存到数据库session.commit()# 关闭sessionsession.close()</code></pre><blockquote><p>ok，执行一下，可以看到我们的数据库中已经有了这条数据</p></blockquote><img src="/posts/944/sss.png" alt style="zoom:70%;" loading="lazy">可见，关键是获取session，然后把对象添加到session，最后提交并关闭。`DBSession`对象可视为当前数据库连接。<hr><h4 id="查找数据（Retrieve）"><a href="#查找数据（Retrieve）" class="headerlink" title="查找数据（Retrieve）"></a>查找数据（Retrieve）</h4><blockquote><p>重新得到数据</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">user = session.query(User).filter(User.id==5).one()print(type(user))print('name',user.username)</code></pre><blockquote><p>这只是查找第一条</p><p>如果要获取多条，那么就可以将one换成all</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">user = session.query(User).filter(User.id==5).all()print(type(user))for i in user:    print(i.username)</code></pre><p>注意，因为获取多条，他的类型是列表，所以，我们需要处理一下</p><hr><h4 id="更新数据（Update）"><a href="#更新数据（Update）" class="headerlink" title="更新数据（Update）"></a>更新数据（Update）</h4><blockquote><p>首先呢，我们需要找出需要修改的数据，然后直接进行update修改</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">session.query(User).filter(User.id==1).update({'username':'haoye'{)session.commit()</code></pre><hr><h4 id="删除数据（delete）"><a href="#删除数据（delete）" class="headerlink" title="删除数据（delete）"></a>删除数据（delete）</h4><blockquote><p>操作和update一致，只是最后换成dalete</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">session.query(User).filter(User.id==1).delete()session.commit()</code></pre><hr><p>总结：最为简单的CRUD操作并没有什么难度，只是需要注意的是，为了节约内存资源，最好是做完操作之后，将session进行关闭</p><p>如果我们要学习除了django之外的web框架，几乎都离不开sqlachemy，所以，将sqlachemy学好收益还是非常大的</p>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastAPI </tag>
            
            <tag> SQLAlchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastAPI学习之路-1</title>
      <link href="/posts/61711/"/>
      <url>/posts/61711/</url>
      
        <content type="html"><![CDATA[<h2 id="FastAPI框架"><a href="#FastAPI框架" class="headerlink" title="FastAPI框架"></a>FastAPI框架</h2><blockquote><p>FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，天生的支持异步(async)</p></blockquote><p>它的主要优势在于，高效，几乎可与NodeJS和Go比肩的极高性能，自动生成交互式的文档，省去了开发之后写文档的步骤</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>好了话不多说，我们从头开始，边学边补充吧，争取细到不能再细</p><p>首先是安装，安装非常的简单</p><pre class="language-python" data-language="python"><code class="language-python">pip install fastapipip install uvicorn</code></pre><p>好啦，完成之后，做一个基础的API吧</p><p> 创建py文件</p><pre class="language-python" data-language="python"><code class="language-python">from fastapi import FastAPI    app = FastAPI()    @app.get("/")async def root():    return {"message": "Hello World"}</code></pre><ul><li><p><code>from fastapi import FastAPI</code>这是一个python类，提供了<code>API</code>的所有功能</p></li><li><p><code>app=FastAPI()</code>将该类实例化</p></li><li><p><code>@app.get('/')</code>定义路径操作装饰器，告诉<code>FastAPI</code>是正下方的功能负责处理该请求,可用的其他方式：</p><pre class="language-python" data-language="python"><code class="language-python"> @app:get()@app.post()@app:put()@app:delete()@app.options()@app:head()@app:patch()@app:trace()</code></pre></li><li><p><code>async def root():</code>定义路径操作功能，带有<code>async</code>功能的函数</p></li><li><p><code>return {"message": "Hello World"{</code>返回内容，默认是一个<code>json</code>格式，还可以返回<code>dict、list、str、int</code>等类型，还可以返回<code>Pydantic</code>模型</p></li></ul><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><blockquote><p>在终端中输入<code>uvicorn main:app --reload</code></p><p>``main：main.py<code>文件 </code>app<code>：</code>app = FastAPI()<code>实例化的</code>FastAPI<code>对象 </code>–reload`:在代码更改后重新启动服务器</p></blockquote><p>第二种方法:</p><p>程序入口直接运行:</p><pre class="language-python" data-language="python"><code class="language-python">import uvicornif __name__ == '__main__':    uvicorn.run(app=app)    #还可以指定host，port等</code></pre><hr><h2 id="声明类型"><a href="#声明类型" class="headerlink" title="声明类型"></a>声明类型</h2><blockquote><p>FastAPI的类型声明使用的是  :</p></blockquote><p>做个例子:</p><pre class="language-python" data-language="python"><code class="language-python">from typing import strdef get_full_name(first_name,last_name):    full_name = first_name.title() + " " + last_name.title()    return full_name# 上面这是没加类型提示的def get_full_name(first_name: str, last_name: str):# 这事加了类型提示的，添加了这个类型提示不会改变原来的运行结果</code></pre><blockquote><p>这个呢，大家把它当做习惯就好了，无论是否使用这个框架的人 ，都能看懂传参需要什么类型</p><p>Optional:可选类型，例：q:Optional[str] = None<br>q类型可以为str也可以为None</p></blockquote><p>不只是str，能够声明所有标准python类型</p><p>比如：int float bool bytes</p><p>或者是：dict list set tuple</p><p>统统可以使用typing库来声明</p><pre class="language-python" data-language="python"><code class="language-python">from typing import List</code></pre><p>而，在List这些嵌套类型中，也可以声明其元素的类型，比如：</p><pre class="language-python" data-language="python"><code class="language-python">def process_items(items:List[str]):</code></pre><blockquote><p>Dict的key和value都可以各自声明</p></blockquote><blockquote><p>Optional:可选类型，例：q:Optional[str] = None<br>q类型可以为str也可以为None</p></blockquote><p>哦对，差点忘了，类，也是可以作为类型传递的</p><pre class="language-python" data-language="python"><code class="language-python">class Person:    def __init__(selfm,name:str):        self.name = namedef get_person_name(one:Person):    return one_person.name</code></pre><hr><h2 id="交互式文档"><a href="#交互式文档" class="headerlink" title="交互式文档"></a>交互式文档</h2><blockquote><p>交互式文档，在你启动的项目路径的docs下</p><p><code>127.0.0.1:8000/docs</code></p></blockquote><img src="/posts/61711/image-20201125153555784.png" alt style="zoom:50%;" loading="lazy"><p>在网页：</p><img src="/posts/61711/image-20201125153634050.png" alt style="zoom:50%;" loading="lazy"><p>这就是交互式文档的所在了，注意交互二字</p><img src="/posts/61711/image-20201125153754643.png" alt style="zoom:50%;" loading="lazy"><blockquote><p>可以清楚的看到，传参，传的什么参，是否路径参数，一目了然</p></blockquote><p>也可以进入redoc来进入标准的API文档</p><img src="/posts/61711/image-20201125153956180.png" alt style="zoom:50%;" loading="lazy"><hr><h2 id="查询参数和字符串验证"><a href="#查询参数和字符串验证" class="headerlink" title="查询参数和字符串验证"></a>查询参数和字符串验证</h2><p>要注意，到目前，我们在函数参数中传的，都只是params，也就是路径上的那种</p><blockquote><p>Query(查询参数)<br>Query第一个参数用来定义默认值</p></blockquote><blockquote><p>可用于限制长度或者正则表达式</p></blockquote><p>举个栗子:</p><pre class="language-python" data-language="python"><code class="language-python">#q参数必须为字符串，默认值为None，如果为...,则这个参数必须给值，最小长度3，最大长度50async def reds(q:str = Query(None,min_length=3,max+length=50)</code></pre><blockquote><p>注意!!!!此处只是参数，如果路径与参数一致，则不会生效</p></blockquote><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><blockquote><p>添加<code>regex</code>参数</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">async def reds(q:str = Query(None,min_length=3,max+length=50,regex='^nice'))</code></pre><h4 id="别名-alias"><a href="#别名-alias" class="headerlink" title="别名(alias)"></a>别名(alias)</h4><pre class="language-python" data-language="python"><code class="language-python">async def reds(q:str = Query(None,alias = 'asd'))</code></pre><blockquote><p>此时，参数名不再是q，而是<code>asd</code>，函数内部仍使用q</p></blockquote><h4 id="弃用参数-deprecated"><a href="#弃用参数-deprecated" class="headerlink" title="弃用参数(deprecated)"></a>弃用参数(deprecated)</h4><pre class="language-python" data-language="python"><code class="language-python"># 我自己测试得出结论，只是提醒作用，并不是不可写入# 写入Query中，可以改为弃用参数    deprecated = True</code></pre><h4 id="路径参数-path"><a href="#路径参数-path" class="headerlink" title="路径参数(path)"></a>路径参数(path)</h4><pre class="language-python" data-language="python"><code class="language-python">首先导入pathfrom fastapi import path#和Query使用方法类似，在参数定义之后添加@app.get("/items/{item_id}")async def read_items(item_id: int = Path(..., title="The ID of the item to get"))#注意，由于是路径参数，所以不能为空，所以，应该用...声明</code></pre><pre class="language-python" data-language="python"><code class="language-python">ge代表大于等于，le代表小于等于，gt代表大于，lt代表小于#将*作为函数第一个参数的话，那么这个函数内所有参数都是关键字参数kwargs，即便没有默认值举个例子，参数q不带默认值，而it参数带了pathasync def re(*,q:str,it:int = path(..., title="The ID of the item to get"))</code></pre><p>传递 <code>*</code> 作为函数的第一个参数。</p><p>Python 不会对该 <code>*</code> 做任何事情，但是它将知道之后的所有参数都应作为关键字参数（键值对），也被称为 <code>kwargs</code>，来调用。即使它们没有默认值。</p><hr><h2 id="pydantic"><a href="#pydantic" class="headerlink" title="pydantic"></a><code>pydantic</code></h2><p><code>FastAPI</code>内置的数据模型</p><pre class="language-python" data-language="python"><code class="language-python">from pydantic import BaseModelclass Item(BaseModel):    name:str    price:float    tax:float = Nonefrom pydantic import EmailStr#还提供了EmailStr类型，邮件地址类型</code></pre><p>类似Django内的<code>Model</code></p><h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><blockquote><p>参数中，如果参数=body(…)，则这个参数不会在<code>url</code>中，而是会出现在请求体中</p></blockquote><p>栗子：</p><pre class="language-python" data-language="python"><code class="language-python">class Item(BaseModel):    name:str    age:int    price:float@app.post("/items/ss")async  def root(a:Item=Body(...,embed=True)):         return {'item':a{</code></pre><pre class="language-python" data-language="python"><code class="language-python">嵌套请求体参数embed=True参数A=body(...,embed=True)则可以将参数A当做一个字典的键嵌套进请求体中，例：    A = body(...,embed=True)    {        A:{            q:1            w:2            e:3        {    {    不加embed效果:    {        q:1        w:2        e:3    {</code></pre><hr><h2 id="响应模型"><a href="#响应模型" class="headerlink" title="响应模型"></a>响应模型</h2><blockquote><p>response_model=<strong>**参数，此参数写在</strong>路径<strong>中，而不是</strong>函数**</p></blockquote><blockquote><p><code>response_model_exclude_unset = True</code>，返回数据模型中有的字段，没有的字段不返回</p><p><code>response_model_exclude = {某字段{</code>，返回时排除了某个字段</p><p><code>response_model_include = [某字段1,某字段2]</code>,返回时只包含其中的某字段</p></blockquote><p><code>**</code>是解包的意思<br>    假如有多个<code>BaseModel</code>，数据类型有相同的情况下，可以使用<code>.dict</code>形式相互传输数据<br>但是，前边加了<code>**</code></p><h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><pre class="language-python" data-language="python"><code class="language-python">from fastapi import status#如果报错的话，则使用starlette引入from starlette import status#可使用HTTP状态码#错误处理：from fastapi import HTTPException#在路径中@post(/itmes/, status_code=***)</code></pre>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/posts/25246/"/>
      <url>/posts/25246/</url>
      
        <content type="html"><![CDATA[<h2 id="配置全局："><a href="#配置全局：" class="headerlink" title="配置全局："></a>配置全局：</h2><pre class="language-python" data-language="python"><code class="language-python">git config --global user.name "xxx"git config --global user.email "7618733+god_hearing@user.noreply.gitee.com"</code></pre><h2 id="上传到仓库："><a href="#上传到仓库：" class="headerlink" title="上传到仓库："></a>上传到仓库：</h2><ol><li><p>在码云或者<code>github</code>上创建仓库</p></li><li><p>仓库初始化(在本地)<br><code>git init</code></p></li><li><p>新建<code>readme.md</code>文件:<br><code>touch README.md</code></p></li><li><p>添加到本地缓冲区(.代表全部)<br><code>git add .</code></p></li><li><p>此时，也可以查看缓冲区状态<br><code>git status</code></p></li><li><p>添加注释<br><code>git commit -m'注释信息'</code></p><blockquote><p>一般，注释会使用<code>+ - * </code>等符号作为前缀，代表增加，删除，改动</p></blockquote></li><li><p>添加远程仓库地址<br><code>git remote add 自定义缓存名(origin) 码云地址</code></p></li><li><p>提交代码到远程仓库<br><code>git push origin master</code></p><blockquote><p>如果提示报错，不妨先试验一下<br><code>git push -u origin master -f</code></p></blockquote></li></ol><h2 id="克隆到本地："><a href="#克隆到本地：" class="headerlink" title="克隆到本地："></a>克隆到本地：</h2><p><code>git clone 地址</code></p><h2 id="Git分支命令"><a href="#Git分支命令" class="headerlink" title="Git分支命令"></a>Git分支命令</h2><blockquote><p>在一个庞大的项目中，只依靠自己，是写不完所有的命令的，这时候，就需要集合众人之力，东拼西凑，将项目做出来，如果所有人都将自己的想法给上传到线上，那么，很大的几率会发生冲突，因为一个人一个想法，不可能全部都一致，这时候，就需要分支站出来了</p><p>所谓的分支，就像是支线任务，你需要将所有的支线的全部做完，然后汇总到主线任务，才叫完成。 假若每个人都在自己做自己的支线任务，互不影响，最后再汇总，这样不仅会减少错误，还会很方便的分工合作。</p></blockquote><p>Git的分支，无论是在github还是gitee，使用方式是一样的</p><ul><li><code>git pull</code>：将所有的更新拉到本地仓库</li><li><code>git branch -r</code>：查看所有远程分支</li><li><code>git checkout</code> 分支名：切换分支</li><li><code>git branch</code>：查看当前在哪个分支</li><li><code>git merge</code> 分支名：本地合并</li></ul><blockquote><p>需要注意的是，在本地合并，一定要先确认在哪个分支下，merge后的分支名，是将哪个分支合并过来，一般会在主分支下，逐一合并子分支。</p><p>所以，首要任务，就是要保证子分支的代码没有任何的错误，然后再合并</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/posts/c6654282/"/>
      <url>/posts/c6654282/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><blockquote><p>递归，简单来说，就是自己调用自己，指在函数的定义中调用函数自身的方法</p><p>调用分为<strong>直接调用</strong>和<strong>间接调用</strong>，直接调用是指在函数体中调用自身，间接调用是调用别的函数，而这些别的函数又调用函数本身。它主要是把大问题变成小问题，使得代码更加简洁。理解递归需要有一定的抽象能力。</p><p>使用递归时，需要注意的是：</p><ul><li>递归就是在过程或函数里调用自身</li><li>必须有一个明确的递归结束条件，称为递归出口</li></ul><p><strong>切勿忘记递归的出口，否则就是无限循环</strong></p><p>著名的德罗斯特效应就是递归的一种视觉形式</p></blockquote><img src="/posts/c6654282/image-20201124201411737.png" alt=" " style="zoom:90%;" loading="lazy"><p>递归的过程分为，递归前进段，递归边界条件，递归返回段</p><p>递归的最大层次限制是998次，但是可以通过<code>sys</code>(System)模块下的<code>setrecursionlimit</code>方法来进行递归层次的扩大</p><p>递归函数的优点是定义简单，逻辑清晰，但是，过深的调用会导致栈溢出</p><h2 id="递归实现高斯求和"><a href="#递归实现高斯求和" class="headerlink" title="递归实现高斯求和"></a>递归实现高斯求和</h2><blockquote><p>代码实现高斯求和，如果是按照正常方式实现，那么就是这样的</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">def sum_number(n):    total = 0    for i in range(1,n+1):        total += i    return total</code></pre><blockquote><p>非常的简单，但是这样做，流程是这样的，假设我们传参5</p></blockquote><img src="/posts/c6654282/image-20201124203210068.png" style="zoom:67%;" loading="lazy"><p>同样是计算5，我们用递归实现：</p><pre class="language-python" data-language="python"><code class="language-python">def sum_numbers(n):    if n &lt;= 0:        return 0    return n+sum_numbers(n-1)</code></pre><blockquote><p>可以看到，我们并不是从1开始加到5，而是逆向的思维，从5开始，逐渐的递减，直到边界条件触发，也就是，如果为0，则停止递归</p></blockquote><img src="/posts/c6654282/image-20201124203529172.png" alt=" " style="zoom:67%;" loading="lazy"><hr><blockquote><p>但是，这样会造成一个后果，就是内存的耗费问题，因为递归需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）</p></blockquote><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><blockquote><p>对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。</p><p>如果按照上方的递归，计算需要保存n个调用记录，复杂度为O(n)</p></blockquote><p>也就是：</p><pre class="language-python" data-language="python"><code class="language-python">5 + sum_numbers(4)5 + (4 + sum_numbers(3))5 + (4 (3 + sum_numbers(2))5 + (4 (3 (2 + sum_numbers(1))</code></pre><p>在内存中，需要存储5次，非常的耗费</p><p>让我们用尾递归来实现一下，看一下有什么不同</p><pre class="language-python" data-language="python"><code class="language-python">def tail_sum(n,result=0):    if n &lt;= 0:        return result    else:        tail_sum(n-1,result+n)</code></pre><blockquote><p>我们给定义了一个最终数<code>result</code>，每次调用，不再存储到内存中，而是将结果存到<code>result</code>中，这样，只在运行结束的瞬间，存储一次，其他时间，只是存储了状态，如下：</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">tail_sum(5,0)tail_sum(4,5)tail_sum(3,9)tail_sum(2,12)tail_sum(1,14)tail_sum(0,15)</code></pre><p>再实现一下斐波那契</p><pre class="language-python" data-language="python"><code class="language-python">def feibonacci(n):    if n &lt;= 2:        return 1    else:        return feibonacci(n-1) + feibonacci(n-2)</code></pre><p>总结一下， 递归最核心的思想是：<strong>每一次递归，整体问题都要比原来减小，并且递归到一定层次时，要能直接给出结果！</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成器和迭代器</title>
      <link href="/posts/56805/"/>
      <url>/posts/56805/</url>
      
        <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote><p>迭代，是访问集合内元素的一种方式。要理解迭代器，首先要理解可迭代对象，所谓可迭代对象，通俗的 说就是可以被for循环遍历的对象就是可迭代对象</p><p>任何内置了<code>iter</code>方法的，都是可迭代的对象，例如，<code>list</code>、<code>set</code>、<code>dict</code>、<code>tuple</code>等都是可迭代对象</p></blockquote><h4 id="迭代的概念"><a href="#迭代的概念" class="headerlink" title="迭代的概念"></a>迭代的概念</h4><blockquote><p>相信大家都玩过游戏，每一次游戏更新迭代，都是新增了一些功能，调整了什么，迭代就是这个概念，在python中，上一次输出的结果为下一次输入的初始值，重复的过程就称为迭代。</p><p>就好像我们游戏更新一样，都是继上一次的版本为初始的情况下，增加一些新的东西，同理，每次迭代的结果是下一次迭代的初始值。</p></blockquote><p>那么，问题来了，为什么要有迭代器，因为，对于没有索引的数据类型，必须提供一种不依赖索引的迭代方式，这个方式就是迭代器。</p><h4 id="迭代器定义"><a href="#迭代器定义" class="headerlink" title="迭代器定义"></a>迭代器定义</h4><p>迭代器，就是<strong>可迭代对象</strong>执行<code>iter</code>方法，得到的结果就是<strong>迭代器</strong>，迭代器对象有<code>next</code>方法。它是一个状态的对象，它能在你调用你next()方法的时候返回容器中的下一个值，如果容器中没有更多的元素了，则会抛出<code>StopIteration</code>(停止迭代异常)</p><p>我们常用的for循环，其实它的本质就是：</p><ol><li>利用iter函数得到函数</li><li>利用next函数依次取值</li><li>捕获异常</li></ol><p>手写一个迭代器</p><pre class="language-python" data-language="python"><code class="language-python">class Csmt:def __init__(self):# 初始化可迭代对象和numself.name = []self.num = 0def add(self,na):# 添加元素self.name.append(na)def __iter__(self):# 调用iter方法，返回自身return selfdef __next__(self):# 如果 num小于name的长度if self.num &lt; len(self.name):# 从0开始，取出可迭代对象中的元素ret = self.name[self.num]# 同时，往后移一位self.num += 1# 返回return retelse:# 没有元素，抛出异常raise StopIterationc = Csmt()c.add('AAA')c.add('BBB')c.add('CCC')for i in c:print(i)</code></pre><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote><p>生成器是一个特殊的迭代器，它的实现更简单，<strong>yield</strong>，就是生成器实现next()方法的关键，它作为生成器执行的暂停恢复点，可以对<strong>yield</strong>表达式进行赋值，也可以将yield表达式的值返回</p><p>也就是说，yield是一个语法糖，内部实现了支持迭代器协议，同时yield内部是一个状态机，维护着挂起和继续的状态</p><p> 也就是说，一边循环，一边计算的机制，就是生成器。</p></blockquote><h4 id="为什么要有生成器"><a href="#为什么要有生成器" class="headerlink" title="为什么要有生成器"></a>为什么要有生成器</h4><p>假如你有一个海量的列表，你要读取中间的某些元素，那后面的绝大多数元素占用的空间都白白浪费了，如果使用生成器，在得到你需要的数据之后就停止，就没有必要创建完整的list，从而节省大量的空间。</p><h4 id="生成器如何定义"><a href="#生成器如何定义" class="headerlink" title="生成器如何定义"></a>生成器如何定义</h4><p>第一种方式</p><ul><li>在函数中添加yield关键字，这个函数就是生成器</li></ul><p>第二种方式</p><ul><li>将列表推导式的[ ] 变成 ( )</li></ul><h4 id="获取生成器的数据"><a href="#获取生成器的数据" class="headerlink" title="获取生成器的数据"></a>获取生成器的数据</h4><ol><li>利用for循环获取迭代器数据</li><li>利用while和异常捕获</li><li>利用list、tuple类型转换</li></ol><h4 id="生成器唤醒方式"><a href="#生成器唤醒方式" class="headerlink" title="生成器唤醒方式"></a>生成器唤醒方式</h4><blockquote><p>由于生成器是函数暂停执行实现的，那么，我们唤醒生成器就需要使用next()来取值</p><p>或者使用<code>__next__</code>魔法方法</p><p>还可以使用<code>send()</code>函数，它可以将数据作为参数传递到生成器内部，需要<strong>注意</strong>的一点是，<code>send</code>不能作为第一次唤醒时使用</p></blockquote><h4 id="实现生成器"><a href="#实现生成器" class="headerlink" title="实现生成器"></a>实现生成器</h4><pre class="language-python" data-language="python"><code class="language-python">a = (i for i in range(1,11))print(a)for i in a:print(i)'''&lt;generator object &lt;genexpr&gt; at 0x000001BEBA62E448&gt;1，2，3，4，5，6，7，8，9，10'''</code></pre><p>好啦，分享到此结束</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中pipline的使用</title>
      <link href="/posts/5582/"/>
      <url>/posts/5582/</url>
      
        <content type="html"><![CDATA[<p>redis<strong>发送数据原理</strong></p><ul><li><p>Redis是建立在TCP协议基础上的CS架构，客户端client对redis server采取请求响应的方式交互。</p></li><li><p>一般来说客户端从提交请求到得到服务器相应，需要传送两个tcp报文。</p></li><li><p>设想这样的一个场景，你要批量的执行一系列redis命令，例如执行100次get key，这时你要向redis</p><p>请求100次+获取响应100次。如果能一次性将100个请求提交给redis server，执行完成之后批量的获</p><p>取相应，只需要向redis请求1次，然后批量执行完命令，一次性结果，性能是不是会好很多呢？</p></li></ul><p><strong>未使用</strong>pipeline<strong>执行</strong>N<strong>条命令</strong></p><p><img src="/posts/5582/20201008110134859.png" loading="lazy"></p><p><strong>使用了</strong>pipeline<strong>执行</strong>N<strong>条命令</strong></p><p><img src="/posts/5582/20201008110151342.png" loading="lazy"></p><p>pipeline<strong>性能代码展示</strong></p><pre class="language-python" data-language="python"><code class="language-python">from django_redis import get_redis_connectionredis_client = get_redis_connection('default')'''普通方法执行'''for i in range(99999):    redis_client.set(i,i)    '''使用pipeline执行'''    p1 = redis_client.pipeline()# 实例化一个pipeline对象for i in range(99999):    p1.set(i,i)p1.execute()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django配置</title>
      <link href="/posts/26865/"/>
      <url>/posts/26865/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>django作为python中的重型web框架，在开始学习django的时候，一定是非常痛苦的，连文件配置都搞不清，更不要提写功能了，今天这篇文章主要讲解一下django的配置问题</p></blockquote><h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><blockquote><p>settings作为django的配置文件，其中的东西可以说是面面俱到的影响着整个项目，这个文件不需要创建，在你创建项目的时候，他自然会被创建，那让我们来看一下，这个settings中，可以配置什么</p></blockquote><ul><li><p><code>SECRET_KEY</code>，每个django项目都会有自己的密钥，方便了使用jwt加密等</p></li><li><p><code>DEBUG</code>，这个呢，是开发人员的DEBUG模式，也就是开发模式，正常情况下，在项目上线之前，要把这个改为False，否则一旦你网站全部的url泄露出去，那后果可是不堪设想</p></li><li><p><code>ALLOWED_HOSTS</code>，这个是为了限定请求中的host值，以防止黑客构造包来发送请求，只有在列表中的host才能访问</p><blockquote><p>注意，本人在这里强烈建议不要使用<code>*</code>通配符去配置，另外当DEBUG设置为False的时候，必须配置这个配置，否则会抛出异常。</p><p>后面所跟的属性值是一个<strong>字符串列表值</strong>，这个字符串列表值表示当下这个Django站点可以提供的<code>host/domain</code>(主机/域名)。这是一种安全措施，<strong>通过使用伪造的HTTP主机标头提交请求来防止攻击者中毒缓存并触发带有恶意主机链接的密码重置电子邮件</strong>，即使在许多看似安全的Web服务器配置下也是如此</p></blockquote></li><li><p><code>INSTALLED_APPS</code>，一般就是存放app和一些django的插件，比如跨域或者DRF</p></li><li><p><code>MIDDLEWARE</code>：听名字就知道，这是中间件层，一些自定义的中间件也要在这里注册</p></li><li><p><code>ROOT_URLCONF</code>,URL是Web服务的入口，用户通过浏览器发送过来的任何请求，都是发送到一个指定的URL地址，然后被响应，决定哟啊使用的根URLconf模块，通常，这是ROOT_URLFONF设置的值，但是如果传入的HttpRequest对象具有urlconf属性(由中间件设置),则其值将被用于代替ROOT_URLCONF设置，<strong>通俗的讲</strong>，就是你可以自定义项目入口url是哪个文件</p></li><li><p><code>TEMPLATES</code>：模板，在做一些前后端不分离的项目时，会使用到。</p></li><li><p><code>WSGI_APPLICATION</code>：wsgi的配置，一般不需要动</p></li><li><p><code>DATABASES</code>:数据库，这里可以连接关系型数据库，例如Mysql，PosrgrelSQL</p></li><li><p><code>AUTH_PASSWORD_VALIDATORS</code>：弱密码校验，这里会有四个自带的校验器，当然也可以自己写校验器，只需要按照下述格式添加进去就可以做统一校验</p></li><li><p>然后剩下的这些，都是本地化的一些配置</p><pre class="language-python" data-language="python"><code class="language-python">LANGUAGE_CODE = 'zh-hans'  # 语言，这里改为了中文TIME_ZONE = 'Asia/Shanghai' # 时区，改为亚洲上海即可USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False  # 弃用格林威治时间</code></pre></li><li><p>STATIC_ROOT，新增的，该目录下面的文件会被当成静态文件处理，与STATIC_ROOT搭配使用的还有STATIC_URL，一般默认采用<code>/static/</code>，用于你指定静态目录的URL。</p></li><li><p>STATICFILES_DIRS，制定了一个工程里面哪个目录存放了与这个工程相关的静态文件，这是一个列表</p><pre class="language-python" data-language="python"><code class="language-python">STATIC_URL = '/static/'STATICFILES_DIRS=[     os.path.join(BASE_DIR,'static')]</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRF操作</title>
      <link href="/posts/23336/"/>
      <url>/posts/23336/</url>
      
        <content type="html"><![CDATA[<h3 id="1-DRF初始化"><a href="#1-DRF初始化" class="headerlink" title="1.DRF初始化"></a>1.DRF初始化</h3><p>DRF六中常用操作</p><pre class="language-python" data-language="python"><code class="language-python">1.认证2.权限3.限流4.序列化5.分页6.版本</code></pre><h4 id="1-1安装DjangoRestFramework"><a href="#1-1安装DjangoRestFramework" class="headerlink" title="1.1安装DjangoRestFramework"></a>1.1安装DjangoRestFramework</h4><pre class="language-python" data-language="python"><code class="language-python">pip install djangorestframework==3.11.1pip install django-filter==2.3.8  #过滤器pip install markdown # markdown support for the browsable API123</code></pre><h4 id="1-2在syl-settings-py中注册"><a href="#1-2在syl-settings-py中注册" class="headerlink" title="1.2在syl/settings.py中注册"></a>1.2在syl/settings.py中注册</h4><pre class="language-python" data-language="python"><code class="language-python">INSTALLED_APPS = ['django_filters','rest_framework']1234</code></pre><h3 id="1-3-在settings-py中配置"><a href="#1-3-在settings-py中配置" class="headerlink" title="1.3 在settings.py中配置"></a>1.3 在settings.py中配置</h3><pre class="language-python" data-language="python"><code class="language-python"># 过滤器# 1,安装 django-filter# 2,注册应用# 3,配置settings, 在view里配置可过滤的字段# 4,使用 查询字符串携带过滤信息REST_FRAMEWORK = {    # 文档报错： AttributeError: ‘AutoSchema’ object has no attribute ‘get_link’    # 用下面的设置可以解决    'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.AutoSchema',    # 默认设置是:    # 'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.openapi.AutoSchema',    # 异常处理器    # 'EXCEPTION_HANDLER': 'user.utils.exception_handler',    # Base API policies    'DEFAULT_RENDERER_CLASSES': [        'rest_framework.renderers.JSONRenderer',        'rest_framework.renderers.BrowsableAPIRenderer',    ],    'DEFAULT_PARSER_CLASSES': [        'rest_framework.parsers.JSONParser',        'rest_framework.parsers.FormParser',        'rest_framework.parsers.MultiPartParser'    ],    # 1.认证器（全局）    'DEFAULT_AUTHENTICATION_CLASSES': [        'rest_framework.authentication.SessionAuthentication',  # 使用session时的认证器        'rest_framework.authentication.BasicAuthentication'     # 提交表单时的认证器    ],    #2.权限配置（全局）： 顺序靠上的严格    'DEFAULT_PERMISSION_CLASSES': [        # 'rest_framework.permissions.IsAdminUser',  # 管理员可以访问        # 'rest_framework.permissions.IsAuthenticated',  # 认证用户可以访问        # 'rest_framework.permissions.IsAuthenticatedOrReadOnly',  # 认证用户可以访问, 否则只能读取        # 'rest_framework.permissions.AllowAny',  # 所有用户都可以访问    ],    #3.限流（防爬虫）    'DEFAULT_THROTTLE_CLASSES': [        'rest_framework.throttling.AnonRateThrottle',        'rest_framework.throttling.UserRateThrottle',    ],    #3.1限流策略    'DEFAULT_THROTTLE_RATES': {        'user': '100/hour',    # 认证用户每小时100次        'anon': '3/day',       # 未认证用户每天能访问3次    {,    'DEFAULT_CONTENT_NEGOTIATION_CLASS': 'rest_framework.negotiation.DefaultContentNegotiation',    'DEFAULT_METADATA_CLASS': 'rest_framework.metadata.SimpleMetadata',    'DEFAULT_VERSIONING_CLASS': None,    #4.分页（全局）：全局分页器, 例如 省市区的数据自定义分页器, 不需要分页    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',    # 每页返回数量    'PAGE_SIZE': 10,  # 默认 None    #5.过滤器后端    'DEFAULT_FILTER_BACKENDS': [        'django_filters.rest_framework.DjangoFilterBackend',        # 'django_filters.rest_framework.backends.DjangoFilterBackend', 包路径有变化    ],    #5.1过滤排序（全局）：Filtering 过滤排序    'SEARCH_PARAM': 'search',    'ORDERING_PARAM': 'ordering',    'NUM_PROXIES': None,    #6.版本控制：Versioning  接口版本控制    'DEFAULT_VERSION': None,    'ALLOWED_VERSIONS': None,    'VERSION_PARAM': 'version',    # Authentication  认证    # 未认证用户使用的用户类型    'UNAUTHENTICATED_USER': 'django.contrib.auth.models.AnonymousUser',    # 未认证用户使用的Token值    'UNAUTHENTICATED_TOKEN': None,    # View configuration    'VIEW_NAME_FUNCTION': 'rest_framework.views.get_view_name',    'VIEW_DESCRIPTION_FUNCTION': 'rest_framework.views.get_view_description',    'NON_FIELD_ERRORS_KEY': 'non_field_errors',    # Testing    'TEST_REQUEST_RENDERER_CLASSES': [        'rest_framework.renderers.MultiPartRenderer',        'rest_framework.renderers.JSONRenderer'    ],    'TEST_REQUEST_DEFAULT_FORMAT': 'multipart',    # Hyperlink settings    'URL_FORMAT_OVERRIDE': 'format',    'FORMAT_SUFFIX_KWARG': 'format',    'URL_FIELD_NAME': 'url',    # Encoding    'UNICODE_JSON': True,    'COMPACT_JSON': True,    'STRICT_JSON': True,    'COERCE_DECIMAL_TO_STRING': True,    'UPLOADED_FILES_USE_URL': True,    # Browseable API    'HTML_SELECT_CUTOFF': 1000,    'HTML_SELECT_CUTOFF_TEXT': "More than {count{ items...",    # Schemas    'SCHEMA_COERCE_PATH_PK': True,    'SCHEMA_COERCE_METHOD_NAMES': {        'retrieve': 'read',        'destroy': 'delete'    {,{</code></pre><h4 id="1-4创建user-serializer-py写序列化器"><a href="#1-4创建user-serializer-py写序列化器" class="headerlink" title="1.4创建user/serializer.py写序列化器"></a>1.4创建user/serializer.py写序列化器</h4><pre class="language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-from rest_framework import serializersfrom user.models import Userdef address_validate(data):    # 独立校验器    # raise serializer.ValidationError(‘请填写实际地址’) # 有错就抛出异常    # 没错就返回数据    return dataclass UserSerializer (serializers.ModelSerializer):    # 1.独立校验器：重新设定字段，替掉模型中的设定，重新设定地址的长度最小为5    address = serializers.CharField(max_length=255,min_length=5,validators=[address_validate])    #2.单一字段验证，验证地址    def validate_address(self,data):        if data == '测试':            raise serializers.ValidationError('请填写实际地址') # 有错就抛出异常        return data # 没错返回结果    def validate_phone(self,data):        # 不符合手机号格式        # raise serializer.ValidationError("手机号格式不正确")            model  =self.root.Meta.model            num = model.object.filter(phone=data).count()            if num &gt; 0:                raise  serializers.ValidationError('手机好已存在')            return data    # 3. 所以属性验证器    def validate(self,attrs):        # attrs:{“user”:“zhangsan”,"phone":"17563734847",...{        # 所有属性验证器        # self.context中有request和view上下午        # attrs 是需要序列化的数据        # raise serializer.ValidationsError('xxx.错误') # 有问题报错        return attrs # 没问题返回数据    class Meta:        model = User        # fields = ('id') # 临时添加字段也需要写在这里        fields = '__all__' # 所有字段        # exclude = ['id'] # 排除id字段        read_only_fields = ('',) # 指定字段为 read_only,        # 扩展address：extra_kwargs = {{ # 局部替换某些字段，或者新增设定        extra_kwargs = {            'address':{                'min_length' :5 ,# 给地址增加最小长度限制                'default' :'默认测试地址', # 增加默认值            {        {</code></pre><h4 id="2-DRF认证、权限、限流、分页、过滤、序列化-排序"><a href="#2-DRF认证、权限、限流、分页、过滤、序列化-排序" class="headerlink" title="2.DRF认证、权限、限流、分页、过滤、序列化 排序"></a>2.DRF认证、权限、限流、分页、过滤、序列化 排序</h4><pre class="language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-from django.urls import include,pathfrom user import viewsfrom rest_framework.routers import SimpleRouter,DefaultRouter# 自动生产路由方法，必须使用视图集# router = SimpleRouter（） # 没有跟根路由 /user/ 无法识别router = DefaultRouter() # 有跟路由router.register(r'user',views.UserViewSet) # 配置路由urlpatterns = [    path('index/',views.index),    path('api-auth/',include('rest_framework.urls',namespace='res_framework'))  # 认证地址]urlpatterns+= router.urls # 模块地址</code></pre><h4 id="2-2-编写user-views-py"><a href="#2-2-编写user-views-py" class="headerlink" title="2.2 编写user/views.py"></a>2.2 编写user/views.py</h4><pre class="language-python" data-language="python"><code class="language-python">from django.shortcuts import renderfrom django.http import HttpResponsefrom django_filters.rest_framework import DjangoFilterBackendfrom rest_framework import viewsetsfrom rest_framework.authentication import BasicAuthentication,SessionAuthenticationfrom rest_framework.decorators import actionfrom rest_framework.filters import OrderingFilterfrom rest_framework.permissions import AllowAny,IsAdminUser,IsAuthenticated,IsAuthenticatedOrReadOnlyfrom rest_framework.response import Responsefrom rest_framework.throttling import UserRateThrottlefrom rest_framework.pagination import PageNumberPaginationfrom rest_framework.views import APIViewfrom rest_framework.permissions import BasePermission,SAFE_METHODSfrom user.models import Userfrom user.serializer import UserSerializer# Create your views here.def index(request):    #需要认证才能访问的视图    return HttpResponse('HELLO')# 分页（局部）: 自定义分液器，局部class PageNum(PageNumberPagination):    # 查询字符串中代表每页返回数据量的参数名，默认值：None    page_size_query_param =  'page_size'    # 查询字符串中代表页码的参数名，有默认值：page    # page_query_param = 'page'    # 一页中最多的结果条数    max_page_size = 2# 自定义权限(局部）class MyPermission(BasePermission):    def has_permission(self, request, view):        print(view.kwargs.get('pk'),request.user.id)        '''判断用户对模型有没有访问权限'''        # 任何用户对使用此类权限的视图都有访问权限        print(request)        if request.user.is_superuser:            # 管理员对用户模型有访问权限            return True        elif view.kwargs.get('pk') == str(request.user.id):            # 携带的id和用户的id相同时有访问权限            return True        return False        def has_object_permission(self, request, view, obj):        '''获取单个数据时，判断用户对某个数据对象时否有访问权限'''        if request.user.id == obj.id:            return True        return Falseclass UserViewSet(viewsets.ModelViewSet):    """    完成产品的增删改查    """    queryset = User.objects.all()    serializer_class = UserSerializer # 优先使用 get_serializer_class 返回的序列化器        # # 1.认证： 自定义认证类，自定义会覆盖全局配置    # authentication_classes = (BasicAuthentication,SessionAuthentication)    # # 2.权限认证： 自定义权限类    # permission_classes = (MyPermission)        #3.分页： 自定义分页器  覆盖全局配置    pagination_class = PageNum        # 4.限流：自定义限流类    parser_classes = [UserRateThrottle]        #5. 过滤： 指定过滤方法类，拍下方法类，一个或多个    filter_backends =  (DjangoFilterBackend,OrderingFilter)  # 同时支持过滤和排序    # 5.1 指定排序字段，不设置，排序功能不起效    ordering_fileds = ('date_joined','id')  # ?ordering = -id    # 5.2指定过过滤字段，不设置，过滤功能不起效    filter_fields = ('username','phone','is_active') #?username = tom&amp;phone=is_active=tur        # # 根据不同的请求，获得不同的序列化器    # def get_serializer_class(self):    #     if self.action == 'unactived':    #         return UserUnActiveSerializer    #     else:    #         return UserSerializer</code></pre>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>倒排索引与全文检索</title>
      <link href="/posts/b5646943/"/>
      <url>/posts/b5646943/</url>
      
        <content type="html"><![CDATA[<h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><hr><blockquote><p>一个未经处理的数据库中，一般是以文档ID作为索引，文档内容作为记录</p><p>而倒排索引指的是，将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过索引来查找到其所在的文档</p></blockquote><p>例如：</p><p><img src="/posts/b5646943/image-20201016112650646.png" loading="lazy"></p><ul><li>简单来说，普通的查询检索是通过文档查找关键词，而倒排索引就是通过关键词找到文档</li></ul><h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><p>将数据库中的<strong>结构化数据</strong>数据转换为<strong>非结构化</strong>数据</p><p>然后将<strong>非结构化数据</strong>转化为分词结构</p><hr><h1 id="Django使用haystack"><a href="#Django使用haystack" class="headerlink" title="Django使用haystack"></a><code>Django</code>使用haystack</h1><ul><li><p>haystack是<code>django</code>的开源搜索框架，该框架支持 <code>Solr,Elasticsearch,Whoosh, Xapian</code>搜索引擎，不用更改代码，直接切换引擎，减少代码量。</p></li><li><p>搜索引擎使用Whoosh，这是一个由纯Python实现的全文搜索引擎，没有二进制文件等，比较小</p><p>巧，配置比较简单，当然性能自然略低。</p></li><li><p>中文分词<code>Jieba</code>，由于Whoosh自带的是英文分词，对中文的分词支持不是太好，故用jieba替换</p><p>whoosh的分词组件。</p></li></ul><h4 id="配置与使用："><a href="#配置与使用：" class="headerlink" title="配置与使用："></a>配置与使用：</h4><p><code>syl/settings.py</code> <strong>全文检索配置</strong> </p><pre class="language-python" data-language="python"><code class="language-python">'''1.注册app ''' INSTALLED_APPS = [     'haystack', # haystack要放在应用的上面 ]'''2.模板路径 '''TEMPLATES = [    {        'DIRS':[os.path.join(BASE_DIR,'templates')],    {]'''3.全文检索配置'''HAYSTACK_SEARCH_RESULTS_PER_PAGE = 15 # 搜索出多条数据时需要分页HAYSTACK_CONNECTIONS = {    'default': {        'ENGINE': 'course.whoosh_cn_backend.MyWhooshEngine',        'PATH': os.path.join(BASE_DIR, 'whoosh_index'), # 指定倒排索引存放位置    {{# # ES引擎 # HAYSTACK_CONNECTIONS = { # 'default': {# 'ENGINE': 'haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine',     # 'URL': 'http://10.211.55.15:9200/',  # Elasticsearch服务器ip地址，端口号固 定为9200         # 'INDEX_NAME': 'syl', # Elasticsearch建立的反向索引库的名称         # {, # { # 添加此项，当数据库改变时，会自动更新索引，非常方便 HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor'</code></pre><ul><li><strong>子应用下创建索引文件<code>apps/course/search_indexes.py</code></strong></li></ul><pre class="language-python" data-language="python"><code class="language-python"># apps/course/search_indexes.py# 文件名必须是 search_indexes.pyfrom haystack import indexesfrom .models import Course# 修改此处，类名为模型类的名称+Index，比如模型类为GoodsInfo,则这里类名为GoodsInfoIndex(其 实可以随便写)class CourseIndex(indexes.SearchIndex, indexes.Indexable):    """ Course索引类 """    # text为索引字段 # document = True，这代表haystack和搜索引擎将使用此字段的内容作为索引进行检索    # use_template=True 指定根据表中的那些字段建立索引文件的说明放在一个文件中    text = indexes.CharField(document=True, use_template=True)    # 对那张表进行查询    def get_model(self): # 重载get_model方法，必须要有        """返回建立索引的模型类"""        return Course   # 返回这个model    # 建立索引的数据    def index_queryset(self, using=None):        """返回要建立索引的数据查询集"""        # 这个方法返回什么内容，最终就会对那些方法建立索引，这里是对所有字段建立索引        return self.get_model().objects.all()</code></pre><ul><li><strong>指定索引模板文件</strong></li></ul><p><code>templates/search/indexes/course/course_text.txt </code></p><p><code>创建文件路径命名必须这个规范：templates/search/indexes/应用名称/模型类名称 text.txt</code></p><pre class="language-python" data-language="python"><code class="language-python">{{object.id{{ {{object.title{{ {{object.desc{{</code></pre><ul><li><strong>修改为<code>jieba</code>分词中的中文分析器</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python"># apps/course/whoosh_cn_backend.py# 更换 text 字段的 分析方式, 变为jieba分词中的中文分析器from haystack.backends.whoosh_backend import WhooshEngine, WhooshSearchBackendfrom whoosh.fields import TEXTfrom jieba.analyse import ChineseAnalyzerclass MyWhooshSearchBackend(WhooshSearchBackend):    def build_schema(self, fields):        (content_field_name, schema) = super().build_schema(fields)        # 指定whoosh使用jieba进行分词        schema._fields['text'] = TEXT(stored=True,                                      analyzer=ChineseAnalyzer(),                                      field_boost=fields.get('text').boost,                                      sortable=True)        return (content_field_name, schema)class MyWhooshEngine(WhooshEngine):    backend = MyWhooshSearchBackend</code></pre><ul><li><strong>课程全文检索接口视图函数</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python"># course/views.pyfrom syl import settings from django.core.paginator import InvalidPage, Paginator from haystack.forms import ModelSearchForm from django.http import JsonResponse# 如果settings.py中配置就是用settings中配置的，否则就每页15条RESULTS_PER_PAGE = getattr(settings, 'HAYSTACK_SEARCH_RESULTS_PER_PAGE', 15)def course_index_search(request):    query = request.GET.get('q', None)    page = int(request.GET.get('page', 1))# 第几页    page_size = int(request.GET.get('page_size', RESULTS_PER_PAGE))# 每页多少条    if query:        form = ModelSearchForm(request.GET, load_all=True) # 将查询条件传递给查询对 象        if form.is_valid():            results = form.search() # 查询出来的最终数据        else:            results = []    else:        return JsonResponse({"code": 404, "msg": 'No file found！', "data": []{)    # 对结果集进行分页    paginator = Paginator(results, page_size)    try:        page = paginator.page(page) # 从分好的页中拿第几页    except InvalidPage: # 如果分页出错        return JsonResponse({"code": 404, "msg": 'No file found！', "data": []{)    jsondata = []    for result in page.object_list: # 分页后的课程查询结果        data = {            'id': result.object.id,            'title': result.object.title,            'desc': result.object.desc,            'img':                request.scheme + '://' + request.META['HTTP_HOST'] + result.object.img.url,            # 'follower': result.object.follower,            'learner': result.object.learner,            'status': result.object.status,            'course_type': result.object.course_type.id        {        jsondata.append(data)    result = {        "code": 200,        "msg": 'Search successfully！',        "data": {"count": page.paginator.count, "results": jsondata{    {    return JsonResponse(result)</code></pre><ul><li><strong><code>syl/urls.py</code>添加路由</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python">urlpatterns = [     path('search/', course_index_search), ]</code></pre><ul><li><strong>命令创建倒排索引</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python">python manage.py rebuild_index</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈进程和线程</title>
      <link href="/posts/24758/"/>
      <url>/posts/24758/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>相信大家在刚开始接触三程的时候会懵逼，进程和线程是操作系统的基本概念，但是他们比较抽象，不容易掌握。今天来细细的解释一下进程和线程，关于协程之后有时间会独自出一篇。</p></blockquote><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><blockquote><p>在谈到进程的时候，大家总说的一句话就是，进程是操作系统分配资源的最小单位，这句话理论上没有什么问题，但是对新手不友好。</p><p>首先我们一点点的说，从什么是进程开始吧</p></blockquote><p>进程呢，就是一个将一个程序放入到内存中，从CPU和内存中申请进程资源，从而运行起来，这个运行起来的程序，就是进程，举个例子，进程就好像一座超市，而CPU呢，就好像给超市供电的发电站，假设发电站电力有限，只能供给一座超市，当一个超市正常运行时，其他的超市就得停，就是说，单个CPU只能一次执行一个任务。而一个CPU想要执行多个进程，就需要时间片轮询，什么意思呢，系统会分给每个进程一个时间片，在这个时间片内，是轮到这个进程执行的，然后多个进程轮流执行，由于轮的很快，人的肉眼根本分辨不出来，所以，他们看起来是一起执行的，但是实际上，同一时间只有一个进程在执行。这也就是我们常说的<strong>并发</strong>，同一时间点，只有一个进程在运行，他们只是因为快速的切换达到多任务的效果</p><p>每家超市的货物库存都是<strong>独立</strong>的，也就是说，每个进程的资源不是共享的。</p><hr><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><blockquote><p>线程是系统调度的最小单位，他运行在进程中，就拿上边的例子来举例，每个超市中的收银台，就好像一个个的线程，每个线程都是共享进程的资源的。</p><p>并且，他们是一起执行的，并不是轮流执行，这也就是所谓的<strong>并行</strong>。</p></blockquote><p>谈到线程，就不得不说子线程，子线程就好像超市排队结账的人，他们都是要通过主线程。</p><p>如果你没有对线程进行阻塞，就会造成，你排着排着队，超市下班点到了，所有人都走了，你排队的人一脸懵逼，这时候，就需要守护线程登场，在主线程要结束的时候，先看看超市中还有没有人，等到没人了，主线程才结束。</p><p>由于系统中，线程的启动成本是比较高的，因为他涉及到与操作系统的交互，在这种情况下，使用线程池可以很好的提升性能，在系统启动时创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它，当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。</p><p>此外，使用线程池可以有效的控制系统中并发线程的数量，当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至可能会导致python解释器崩溃。</p><blockquote><p>还有一点是，线程的执行是有顺序的，但是，它可以被其他线程抢占，当多个线程对同一个数据做修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对资源加锁。</p></blockquote><p>补充，python解释器默认是<code>Cpython</code>，它上面有一个全局解释器锁GIL，它的作用是，限制多线程同时执行，保证同一时间内只有一个线程在执行，GIL并不是python的特性，注意，python和python解释器是两个概念。</p><p>所以python也被人诟病是伪多线程，而解决这个问题，可以使用协程或者多进程，也可以换其他解释器，比如<code>PyPy</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 多任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 多任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful风格接口</title>
      <link href="/posts/40287/"/>
      <url>/posts/40287/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是restful风格API"><a href="#什么是restful风格API" class="headerlink" title="什么是restful风格API"></a>什么是restful风格API</h2><blockquote><p>网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现<code>API First</code>的设计思想。<code>RESTful API</code>是目前比较成熟的一套互联网应用程序的API设计理论。</p></blockquote><hr><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>API与用户的通信协议，总是使用<strong>HTTPS</strong>协议</p><hr><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>应该尽量将API部署在专用域名之下，如何确定API很简单，不会有进一步扩展，可以考虑在主域名下</p><hr><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>应该将API的版本号放在URL中，另一个做法是，将版本号放在http头信息中，但不如放在url方便和直观</p><hr><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>路径又称为终点，代表了API的具体网址，每个网址代表一种资源，所以网址中不能有动词，只能有名词，而且所用的名词往往和数据库的表格名相互对应，一般来说，每个数据库中的表都是同种记录的集合，所以API中的名词也要使用复数</p><p>举个栗子：</p><pre class="language-python" data-language="python"><code class="language-python">#  有一个API提供商品信息https://api.example.com/v1/goodshttps://api.example.com/v1/categorys</code></pre><hr><h4 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h4><p>对于资源的具体操作类型， 由HTTP动词表示</p><pre class="language-python" data-language="python"><code class="language-python">GET(SELECT):从服务器中取出资源(一项或多项)POST(CREATE):在服务器新建一个资源PUT(UPDATE):在服务器更新资源(客户端提供改变后的完整资源)PATCH(UPDATE):在服务器更新资源(客户端提供改变的属性)DELETE(DELETE):从服务器删除资源HEAD:获取资源的元数据    OPTIONS:获取信息，关于资源的哪些属性是客户端可以改变的</code></pre><p>拿上边的商品信息举例子</p><pre class="language-python" data-language="python"><code class="language-python">GET /goods:列出所有商品POST /goods:新建商品GET /goods/ID:获取某个指定商品的信息PUT /goods/ID:更新某个指定商品的信息(全部信息)PATCH /goods/ID:更新某个商品的信息(部分信息)DELETE /goods/ID:删除某个商品GET /categorys/ID/good:列出商品类ID下所有商品DELETE /categorys/ID/good/ID:删除某个指定商品类下的某个指定商品</code></pre><hr><h4 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h4><p>如果记录数量很多，服务器不可能都将它们返回给用户，API应该提供参数，过滤返回结果</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">?limit=10：指定返回记录的数量?offset=10：指定返回记录的开始位置。?page=2&amp;per_page=100：指定第几页，以及每页的记录数。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1：指定筛选条件</code></pre><blockquote><p>参数的设计允许存在冗余，即允许<code>API</code>路径和URL参数偶尔有重复。比如，<code>GET /categorys/ID/goods</code> 与 <code>GET /goods?categorys_id=ID</code> 的含义是相同的。</p></blockquote><hr><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><blockquote><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</code></pre><hr><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果状态码是<code>4xx</code>，就应该向用户返回出错信息，一般来说，返回的信息中将error作为键名，出错信息作为键值即可</p><pre class="language-json" data-language="json"><code class="language-json">{    "error":"Invalid API key"{</code></pre><hr><h4 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h4><p>针对不同操作，服务器向用户返回的结果应该符合以下规范</p><pre class="language-python" data-language="python"><code class="language-python">GET /collection：返回资源对象的列表（数组）GET /collection/resource：返回单个资源对象POST /collection：返回新生成的资源对象PUT /collection/resource：返回完整的资源对象PATCH /collection/resource：返回完整的资源对象DELETE /collection/resource：返回一个空文档</code></pre><hr><h4 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h4><p>RESTful API最好做到面向文档，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么，比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><pre class="language-python" data-language="python"><code class="language-python">{"link": {  "rel":   "collection https://www.example.com/goods",  "href":  "https://api.example.com/goods",  "title": "List of goods",  "type":  "application/vnd.yourformat+json"{{上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</code></pre><hr><p>所以，API有四个级别，分别为：</p><pre class="language-python" data-language="python"><code class="language-python">level 0 ：面向过程，只是把HTTP当做一个传输的通道，没有把HTTP当做一种传输协议level 1：面向资源，通过参数判断level 2：面向标签，真正将HTTP作为了一种传输协议，最直观的一点就是Level2使用了HTTP动词，GET/PUT/POST/DELETE/PATCH....,这些都是HTTP的规范level 3：面向文档,使用者只需要知道如何获取资源的入口，之后的每个URI都可以通过请求获得，无法获得就说明无法执行那个请求</code></pre><p>所以，我们写API时，要朝着最高级别迈进，才能逐渐的成长起来</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
