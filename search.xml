<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>扫描普通链接进入微信小程序</title>
      <link href="2021/02/20/sao-miao-pu-tong-lian-jie-jin-ru-wei-xin-xiao-cheng-xu/"/>
      <url>2021/02/20/sao-miao-pu-tong-lian-jie-jin-ru-wei-xin-xiao-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>为了更加方便的将小程序推广，微信现在推出了扫描普通二维码进入某个微信小程序的指定页面，而小程序是没有链接性的地址的，所以，我们还是要先阅读一下<a href="https://developers.weixin.qq.com/miniprogram/introduction/qrcode.html#%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D">文档</a></p></blockquote><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h4 id="step-1：开启扫描二维码打开小程序"><a href="#step-1：开启扫描二维码打开小程序" class="headerlink" title="step 1：开启扫描二维码打开小程序"></a>step 1：开启扫描二维码打开小程序</h4><p>登录小程序后台，进入“开发-开发设置-扫普通链接二维码打开小程序”，开启功能后即可配置二维码规则。</p><h4 id="step2：配置二维码"><a href="#step2：配置二维码" class="headerlink" title="step2：配置二维码"></a>step2：配置二维码</h4><p>二维码规则：</p><blockquote><ul><li>二维码规则的域名须通过ICP备案的验证。</li><li>支持http、https、ftp开头的链接（如：<a href="https://links.jianshu.com/go?to=http://wx.qq.com">http://wx.qq.com</a>、<a href="https://links.jianshu.com/go?to=https://wx.qq.com/mp/">https://wx.qq.com/mp/</a>、<a href="https://links.jianshu.com/go?to=https://wx.qq.com/mp?id=123">https://wx.qq.com/mp?id=123</a>）</li><li>一个小程序帐号可配置不多于10个二维码前缀规则。</li></ul></blockquote><p>校验文件：</p><p>下载随机校验文件，并将文件上传至服务器指定位置的目录下，方可通过所属权校验。</p><p>这里要确定的是，能够访问到这个文件，我这里直接使用的nginx，在nginx下添加配置</p><pre class="language-none"><code class="language-none">location /tra/校验文件名.txt {            alias  /校验文件名.txt;        }</code></pre><p>使用微信扫码，只要是你配置的前缀名，他就会去服务器找这个校验文件，如果校验成功，就会去小程序你指定的页面。</p><p>小程序功能页面：</p><blockquote><p>小程序功能页面可打开指定页面，扫描二维码可打开对应页面。</p></blockquote><img src="/2021/02/20/sao-miao-pu-tong-lian-jie-jin-ru-wei-xin-xiao-cheng-xu/image-20210220133743592.png" alt="" style="zoom:67%;" loading="lazy"><h4 id="step3：扫描二维码打开小程序"><a href="#step3：扫描二维码打开小程序" class="headerlink" title="step3：扫描二维码打开小程序"></a>step3：扫描二维码打开小程序</h4><p>配置二维码时可配置测试链接，利用第三方二维码生成工具，使用测试链接生成二维码，利用微信“扫一扫”或微信内长按识别二维码跳转小程序。</p><p>链接?后为参数部分，可在onLoad事件中提取<code>q</code>参数并自行<code>decodeURIComponent</code>一次，即可获取原二维码的完整内容。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function-variable function">onLoad</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>q<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> queryAll <span class="token operator">=</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">let</span> id <span class="token operator">=</span> <span class="token function">gup</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> queryAll<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//console.log(queryAll);</span>      <span class="token comment">//console.log(id);</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment">/** * 获取URL中某个字符串字段 * gup('id', 'https://www.lubanso.com/wx/home/?id=bHViYW5zb7W7DJI=&amp;jhkfdhkjfda') * //===&gt; bHViYW5zb7W7DJI= */</span><span class="token keyword">function</span> <span class="token function">gup</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>url<span class="token punctuation">)</span> url <span class="token operator">=</span> location<span class="token punctuation">.</span>href<span class="token punctuation">;</span>  name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\[]</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token string">"\\\["</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\]]</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token string">"\\\]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> regexS <span class="token operator">=</span> <span class="token string">"[\\?&amp;]"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"=([^&amp;#]*)"</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>regexS<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> results <span class="token operator">=</span> regex<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> results <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> results<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中使用setTimeout遇到的问题</title>
      <link href="2021/02/19/vue-zhong-shi-yong-js-settimeout/"/>
      <url>2021/02/19/vue-zhong-shi-yong-js-settimeout/</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的问题1"><a href="#遇到的问题1" class="headerlink" title="遇到的问题1"></a>遇到的问题1</h2><p>我在执行setTiemout之后，效果并没有触发，然后发现语法错误</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 错误写法</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">这是第 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 次</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 正确写法</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">t<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 注意这里是形参</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">这是第 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>t<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 次，这是其他参数：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>data<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token operator">*</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 还是每秒执行一次，不是累加的</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">'其他参数'</span><span class="token punctuation">)</span>   <span class="token comment">// 注意这里是实参，这里把要用的参数传进去</span><span class="token punctuation">}</span></code></pre><p>这是个小插曲，之后，我遇到了<code>Uncaught TypeError: this.XXXXX is not a function</code></p><p>原因是，没在一个域内，所以，直接使用this会报错</p><h2 id="解决办法1"><a href="#解决办法1" class="headerlink" title="解决办法1"></a>解决办法1</h2><p>在函数内新生成一个<code>that</code>变量，然后用that代替this</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>that<span class="token punctuation">.</span><span class="token constant">B</span><span class="token punctuation">}</span></code></pre><h2 id="遇到的问题2"><a href="#遇到的问题2" class="headerlink" title="遇到的问题2"></a>遇到的问题2</h2><p>我直接调用了this变量，可能变量会<code>undefined</code></p><h2 id="解决办法2"><a href="#解决办法2" class="headerlink" title="解决办法2"></a>解决办法2</h2><p>不要要this，直接<code>let</code> 一个新变量，使得在作用域是同一片</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器搭建hexo博客教程</title>
      <link href="2021/02/09/a-li-yun-fu-wu-qi-da-jian-hexo-bo-ke-jiao-cheng/"/>
      <url>2021/02/09/a-li-yun-fu-wu-qi-da-jian-hexo-bo-ke-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>作为一名合格的程序员，搭建个人博客对于程序员来讲必不可少。为什么？一是因为互联网的知识需要我们不断学习，如果我们我们经常能够进行总结记录，时不时回头复习一下，效果会好很多；</p><p>二是因为作为程序员经常会遇到各种各样的 bug，如果我们将犯的错误记录下来，下次再次遇到同样的问题时，就不用再反复再网上寻找答案了，能为我们节省出很多时间。</p><p>因此，搭建个人博客有以下几点好处：</p><ul><li>提升知识掌握的深度，印象深刻；</li><li>锻炼自己能够把问题“讲清楚”的能力；</li><li>培养开源意识，与他人分享知识。</li></ul></blockquote><p>这里呢，Hexo怎么搭建，我就不说了，相信大家都有搭建hexo的能力。</p><h2 id="服务端准备工作"><a href="#服务端准备工作" class="headerlink" title="服务端准备工作"></a>服务端准备工作</h2><h3 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h3><p>登陆 <code>https://wanwang.aliyun.com/</code> 挑选一个自己喜欢的域名，具体操作如下：</p><p>1、进入网站主页后，点击“域名注册”:</p><img src="/2021/02/09/a-li-yun-fu-wu-qi-da-jian-hexo-bo-ke-jiao-cheng/image-20210209120656914.png" alt="" style="zoom:50%;" loading="lazy"><p>2、然后在万网进行域名搜索和购买。</p><p>3、初始化自己的服务器</p><p>4、备案，在阿里云的控制台界面，具体备案步骤呢，也就不多说了，往后有机会出一篇备案的攻略。<br><img src="/2021/02/09/a-li-yun-fu-wu-qi-da-jian-hexo-bo-ke-jiao-cheng/image-20210209120903699.png" alt="" style="zoom:67%;" loading="lazy"></p><p>5、阿里云的服务器默认不开放端口号，这样使得我们在网站部署完成之后仍然无法访问。因此我们需要新建安全组并添加 80 端口，再将安全组添加到 ECS 实例中。具体操作如下。在控制台的 ECS 实例中点击安全组，然后新建安全组。</p><img src="/2021/02/09/a-li-yun-fu-wu-qi-da-jian-hexo-bo-ke-jiao-cheng/image-20210209122807387.png" alt="" style="zoom:67%;" loading="lazy"><p>在访问规则为 <strong>入方向</strong> 的标签下添加 80 端口。</p><p>最后回到 ECS 服务器实例，将刚刚配置的安全组加入到实例中。</p><img src="/2021/02/09/a-li-yun-fu-wu-qi-da-jian-hexo-bo-ke-jiao-cheng/image-20210209122901251.png" alt="" style="zoom:67%;" loading="lazy"><h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><p>我们使用 nginx 作为 web 服务器，这里可以将 nginx 理解为安装在服务器上的一个软件。</p><p>还有可以直接使用yum等来安装，不是非得必要用我这个办法。</p><p>安装 nginx 依赖环境，安装期间有提示一律选 yes。推荐直接复制每行命令，避免出错。</p><pre class="language-text" data-language="text"><code class="language-text">yum install gcc-c++yum install -y pcre pcre-develyum install -y zlib zlib-develyum install -y openssl openssl-devel</code></pre><p>下载 nginx 安装包。</p><pre class="language-text" data-language="text"><code class="language-text">wget -c https://nginx.org/download/nginx-1.10.1.tar.gz</code></pre><p>将安装包解压到 <code>/usr/local</code> 目录下。</p><pre class="language-text" data-language="text"><code class="language-text">tar -xvf nginx-1.10.1.tar.gz -C /usr/local</code></pre><p>进入 <code>/usr/local</code> 目录，确认 nginx 解压到该目录下。</p><pre class="language-text" data-language="text"><code class="language-text">cd /usr/local</code></pre><p>进入 <code>nginx-1.10.1</code> 目录，会发现该目录下有一个 <code>configure</code> 文件，执行该配置文件。</p><pre class="language-text" data-language="text"><code class="language-text">cd nginx-1.10.1/ls./configure</code></pre><p>编译并安装 nginx</p><pre class="language-text" data-language="text"><code class="language-text">makemake install</code></pre><p>查找nginx安装目录</p><pre class="language-text" data-language="text"><code class="language-text">whereis nginx</code></pre><p>进入安装目录</p><pre class="language-text" data-language="text"><code class="language-text">cd /usr/local/nginxls</code></pre><p>由于 nginx 默认通过 80 端口访问，而 Linux 默认情况下不会开发该端口号，因此需要开放 linux 的 80 端口供外部访问。</p><pre class="language-text" data-language="text"><code class="language-text">/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT</code></pre><p>进入 <code>/usr/local/nginx/sbin</code> 目录，启动 nginx。</p><pre class="language-text" data-language="text"><code class="language-text">cd sbin./nginx</code></pre><p>没有任何消息，代表启动成功。此时输入公网 IP 即可进入 nginx 的欢迎页面了。</p><p>进入 <code>/usr/local/nginx/conf</code> 目录，并对 <code>nginx.conf</code> 配置文件进行相关配置。</p><pre class="language-text" data-language="text"><code class="language-text">cd /usr/local/nginx/conflsvim nginx.conf</code></pre><p>打开后按 <code>i</code> 键由命令模式切换到编辑模式，修改三处地方：</p><p>首先将最顶端的用户改为 root；</p><img src="/2021/02/09/a-li-yun-fu-wu-qi-da-jian-hexo-bo-ke-jiao-cheng/image-20210210110112486.png" alt="" style="zoom:67%;" loading="lazy"><p>其次将 <code>server_name</code> 改为自己的域名，如果没有备案，可以先填写自己的公网 IP（在控制台 ECS 实例中查看），访问时暂时用公网 IP 进行访问。最后将 <code>root</code> 项中的值改为你自己博客的根目录</p><img src="/2021/02/09/a-li-yun-fu-wu-qi-da-jian-hexo-bo-ke-jiao-cheng/image-20210210110148969.png" alt="" style="zoom:67%;" loading="lazy"><p>修改结束之后，先按 <code>Esc</code> 由编辑模式切换到命令模式，再输入 <code>:wq</code> 命令保存并退出编辑器。</p><h2 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h2><h3 id="为-hexo-创建一个部署目录-home-hexo"><a href="#为-hexo-创建一个部署目录-home-hexo" class="headerlink" title="为 hexo 创建一个部署目录 /home/hexo"></a>为 hexo 创建一个部署目录 <code>/home/hexo</code></h3><pre class="language-text" data-language="text"><code class="language-text">mkdir -p /home/hexo</code></pre><p>进入 <code>/usr/local/nginx/conf</code> 目录，并对 <code>nginx.conf</code> 配置文件进行相关配置。</p><pre class="language-text" data-language="text"><code class="language-text">cd /usr/local/nginx/conflsvim nginx.conf</code></pre><p>打开后按 <code>i</code> 键由命令模式切换到编辑模式，修改三处地方：</p><p>首先将最顶端的用户改为 root；</p><p>其次将 <code>server_name</code> 改为自己的域名，如果没有备案，可以先填写自己的公网 IP（在控制台 ECS 实例中查看），访问时暂时用公网 IP 进行访问。</p><p>最后将 <code>root</code> 项中的值改为 <code>/home/hexo;</code>，如果 <code>server</code> 中的端口号不是 <code>80</code>，则改为 <code>80</code>。</p><p>修改结束之后，先按 <code>Esc</code> 由编辑模式切换到命令模式，再输入 <code>:wq</code> 命令保存并退出编辑器。</p><h3 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h3><p>返回用户根目录，进行安装 node.js。</p><pre class="language-text" data-language="text"><code class="language-text">cd ~curl -sL https://rpm.nodesource.com/setup_10.x | bash -yum install -y nodejs</code></pre><p>通过查看版本号验证是否安装成功。</p><pre class="language-text" data-language="text"><code class="language-text">node -vnpm -v</code></pre><h3 id="创建-Git-用户"><a href="#创建-Git-用户" class="headerlink" title="创建 Git 用户"></a>创建 Git 用户</h3><p>为了使我们能够在本地向服务器实现自动部署，需要在服务器端另外新建一个 Git 用户，然后使用公钥连接成功之后，就可以方便地随时进行自动部署了。</p><p>复制粘贴以下命令安装 Git，有提示选择 yes 即可。</p><pre class="language-text" data-language="text"><code class="language-text">yum install git</code></pre><p>安装结束之后，查看版本号判断是否安装成功。</p><pre class="language-text" data-language="text"><code class="language-text">git --version</code></pre><p>创建 Git 用户</p><pre class="language-text" data-language="text"><code class="language-text">adduser git</code></pre><p>修改 Git 用户权限为 740</p><pre class="language-text" data-language="text"><code class="language-text">chmod 740 /etc/sudoers</code></pre><p>在配置文件中增加 Git 用户。首先打开文件：</p><pre class="language-text" data-language="text"><code class="language-text">vim /etc/sudoers</code></pre><blockquote><p>找到<code>root   ALL=(ALL)   ALL</code>，在他下面，添加上<code>git   ALL=(ALL)   ALL</code></p></blockquote><p>将 Git 用户的权限改回去。</p><pre class="language-text" data-language="text"><code class="language-text">chmod 400 /etc/sudoers</code></pre><p>设置 Git 用户密码</p><pre class="language-text" data-language="text"><code class="language-text">sudo passwd git</code></pre><p>以上我们就完成了 Git 用户的创建，接下来我们向 Git 用户添加公钥，就像配置 Github 那样。</p><h2 id="向-Git-用户配置-ssh-公钥"><a href="#向-Git-用户配置-ssh-公钥" class="headerlink" title="向 Git 用户配置 ssh 公钥"></a>向 Git 用户配置 ssh 公钥</h2><p>在服务器端 <strong>切换到 git 用户</strong>，在根目录下创建 <code>.ssh</code>文件夹。</p><pre class="language-text" data-language="text"><code class="language-text">su gitcd ~mkdir .ssh</code></pre><p>这时，命令行信息中的 <code>#</code> 变成了 <code>$</code>，且 <code>root</code> 变成了 <code>git</code>，表示我们切换成功。</p><p>注意哦，然后在<strong>本地</strong>计算机桌面右键打开 <code>GitBash Here</code>，在本地生成公钥/私钥对。</p><pre class="language-text" data-language="text"><code class="language-text">cd ~cd .sshssh-keygen</code></pre><p>如果有询问直接回车即可。结束之后，会在 <code>C:\Users\你的本地用户名\.ssh</code> 里生成两个文件：<code>id_rsa</code> 和 <code>id_rsa.pub</code>。<code>.ssh</code> 为隐藏文件夹，你可能需要显示隐藏文件夹之后才可以看到。</p><p>在 <strong>本地</strong> 终端输入以下命令，为私钥设置权限。<br>PS：终端用不了的话，用git bash</p><pre class="language-text" data-language="text"><code class="language-text">chmod 700 ~/.sshchmod 600 ~/.ssh/id_rsa</code></pre><p>将这两个文件，复制进服务器里，然后将id_rsa.pub复制一份到<code>/home/git/.ssh</code></p><pre class="language-text" data-language="text"><code class="language-text">cp id_rsa.pub authorized_keys</code></pre><p>修改文件权限<br>PS：应该git用户无法修改，输入<code>su</code>返回超级用户</p><pre class="language-text" data-language="text"><code class="language-text">chmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh</code></pre><p> 确保设置了正确的SELinux上下文。</p><pre class="language-text" data-language="text"><code class="language-text">restorecon -Rv ~/.ssh</code></pre><p>现在我们来测试一下是否设置成功。在本地任意位置右键打开 <code>GitBash Here</code>，输入公网 IP：</p><pre class="language-text" data-language="text"><code class="language-text">ssh -v git@xxx.xxx.xxx.xxx（你的公网 IP）</code></pre><p>如果最后提示Welcome to Alibaba Cloud Elastic Compute Service !，我们就是成功了</p><p>在服务端配置 Git 仓库</p><pre class="language-text" data-language="text"><code class="language-text">cd ~git init --bare hexo.gitvi ~/hexo.git/hooks/post-receive</code></pre><p>进入后按 <code>i</code> 键由命令模式切换到编辑模式。输入以下命令后保存：</p><pre class="language-text" data-language="text"><code class="language-text">git --work-tree=/home/hexo --git-dir=/home/git/hexo.git checkout -f</code></pre><p>授予钩子文件可执行权限。</p><pre class="language-text" data-language="text"><code class="language-text">chmod +x ~/hexo.git/hooks/post-receivecd ~sudo chmod -R 777 /home/hexo</code></pre><p>重启 ECS 实例。<code>reboot</code></p><p>至此，我们就完成了服务端的配置</p><h2 id="本地Hexo配置"><a href="#本地Hexo配置" class="headerlink" title="本地Hexo配置"></a>本地Hexo配置</h2><p>安装两个插件</p><p>修改 <code>_config.yml</code> 文件</p><p>把 <code>deploy</code> 参数改成如下方式，注意填写自己的公网 IP 哦。</p><img src="/2021/02/09/a-li-yun-fu-wu-qi-da-jian-hexo-bo-ke-jiao-cheng/image-20210209133357909.png" alt="" style="zoom:67%;" loading="lazy"><p>除此之外，URL 项改为自己的域名，没有备案的化可以先填写公网 IP。</p><p>然后我们就可以进行发布啦</p><pre class="language-text" data-language="text"><code class="language-text">hexo cleanhexo generatehexo deploy或hexo clhexo ghexo d或hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><blockquote><p>发布三件套命令，哪个都行</p></blockquote><p>这时，在浏览器中输入自己的公网 IP，你就可以看到自己的博客了。</p><p>还有一件事，就是域名是需要解析的，具体步骤请参考这篇<a href="http://www.godhearing.cn/2021/02/09/a-li-yun-yu-ming-jie-xi/">攻略</a></p><p><a href="https://zhuanlan.zhihu.com/p/144774977">参考文章</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云域名解析</title>
      <link href="2021/02/09/a-li-yun-yu-ming-jie-xi/"/>
      <url>2021/02/09/a-li-yun-yu-ming-jie-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于刚开始接触网站搭建的新手来说，好多东西都需要去了解学习，搭建网站首先需要购买服务器，然后购买域名，然后是域名解析，最后是域名备案等这些大的流程步骤。本节就来将将域名解析的步骤，服务器是以阿里云服务器来讲。</p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ol><li>打开控制台，进入域名<img src="/2021/02/09/a-li-yun-yu-ming-jie-xi/image-20210209114350762.png" alt="" style="zoom:50%;" loading="lazy"></li><li>找到想要解析的域名<img src="/2021/02/09/a-li-yun-yu-ming-jie-xi/image-20210209114439874.png" alt="" style="zoom:50%;" loading="lazy"></li><li>添加记录。服务器公网ip<img src="/2021/02/09/a-li-yun-yu-ming-jie-xi/image-20210209114545682.png" alt="" style="zoom:50%;" loading="lazy"></li><li>主机记录，就填写www就可以</li><li>解析线路。选择系统默认即可。</li><li>记录值。指的是服务器/虚拟主机的外网IP地址。查看外网IP地址，就直接去购买的服务器详情里面查看。</li><li>TTL。一般以系统默认的情况就行，默认的10分钟就行。</li></ol><p>填写完添加记录之后，最后点击“确定”按钮即可解析完成。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3获取微信小程序码</title>
      <link href="2021/02/09/python3-huo-qu-wei-xin-xiao-cheng-xu-ma/"/>
      <url>2021/02/09/python3-huo-qu-wei-xin-xiao-cheng-xu-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>微信小程序是现在开发者经常接触到的了，对微信小程序的一些功能也在逐渐的了解当中，这篇文章记录一下获取微信小程序码遇到的问题</p></blockquote><h2 id="获取access-token"><a href="#获取access-token" class="headerlink" title="获取access_token"></a>获取access_token</h2><blockquote><p>话不多说，直接上代码</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">url = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential"res = requests.get(    url=url,    params={        'appid': 你的APPID,        'secret': 你的SECRET,    }).json().get('access_token')</code></pre><h2 id="获取小程序码"><a href="#获取小程序码" class="headerlink" title="获取小程序码"></a>获取小程序码</h2><p>首先就是要注意，它发送的是json，而不是data数据，所以我们在使用<code>requests</code>的时候，一定要先注意，发送json</p><pre class="language-python" data-language="python"><code class="language-python"># 获取小程序码url2 = "https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=TOKEN"req = {    'scene': scene,    'page': page,    'width': width,}res = requests.post(url=url2, json=req).contentbuf = io.BytesIO()buf.write(res)response = HttpResponse(content=buf.getvalue(), content_type='image/png')response['sss'] = 'sss'return response</code></pre><p>此时要注意，我们在url里传<code>access_token</code>，而不是在json里。他的文档写的并不是很清楚，如果在json中加上<code>access_token</code>，那么就有可能会报错<code>47001</code>。</p><p>还有，如果没注意到，用了data传参，也有可能会报错<code>47129</code>，改成json即可。</p><p>如果成功，返回的是一个二进制文件，需要怎么处理就看自己的了。我这里是以文件流形式返回回去并且添加一个响应头参数。</p><p>还有最重要的一点，<code>41030</code>状态码，并不是说你错了，而是你的小程序还没有上线，这个page路径找不到。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python PIL中文变方框的解决办法</title>
      <link href="2021/02/06/python-pil-zhong-wen-bian-fang-kuang-de-jie-jue-ban-fa/"/>
      <url>2021/02/06/python-pil-zhong-wen-bian-fang-kuang-de-jie-jue-ban-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近有个小功能，我看来十分容易，无非就是往图片上添加个文字，但是，在服务器上，瞬间爆炸，所有的中文，都变成一个个的框框，我走了很多弯路，踩了很多坑，在这里记录一下，希望能帮助到同样遇到这个问题的人。</p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><img src="/2021/02/06/python-pil-zhong-wen-bian-fang-kuang-de-jie-jue-ban-fa/image-20210206090744358.png" alt="" style="zoom:67%;" loading="lazy"><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-python" data-language="python"><code class="language-python">from PIL import Image, ImageDraw, ImageFont image= Image.new('RGB', (559, 320),(255,255,255))draw = ImageDraw.Draw(image) # draw.text()font = ImageFont.truetype("arial", 40, encoding="unic") # 设置字体draw.text((100, 50), "哈哈哈", 'black', font)# del drawimage.show()</code></pre><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>我踩了很多的坑，发现有一种及其简易的方式来解决这个问题</p><p>修改字体为simsun.ttc即可，听着简单，但是，假如身处服务器，根本没有这个字体，你需要从windows下copy过去</p></blockquote><ol><li><p>打开”C:\Windows\WinSxS\amd64_microsoft-windows-font-truetype-simsun_31bf3856ad364e35_10.0.18362.1_none_cd668f05ece74044</p><blockquote><p>名字可能会不同，可以搜索simsun.ttc</p></blockquote></li><li><p>通过连接服务器，传到服务器的 <code>/usr/share/fonts</code>文件夹下，如果没有就自己建一个</p></li><li><p>在此目录下，执行<code>#fc-cache -fv</code>，扫描字体目录并生成字体信息的缓存，然后应用程序就可以”立即”使用这些新安装的字体</p></li><li><p>然后重启你的服务器</p></li><li><p>按照相对路径或者绝对路径来进行使用即可。</p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><img src="/2021/02/06/python-pil-zhong-wen-bian-fang-kuang-de-jie-jue-ban-fa/image-20210206091500505.png" alt="" style="zoom:67%;" loading="lazy">]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署Django应用</title>
      <link href="2021/01/29/docker-bu-shu-django-ying-yong/"/>
      <url>2021/01/29/docker-bu-shu-django-ying-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在开发完成之后，我们所有的应用，都是要部署到生产环境中的，而docker的出现，让我们看到了容器式部署的好处，就是便捷。</p></blockquote><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><blockquote><p>安装docker和开发web应用我就不多说了，既然能了解到这里，那这些步骤相信对大家来说都是小菜一碟。</p><p>我们从打包开始，首先就是我们使用的Gunicorn的配置，在项目根目录下新建一个<code>gunicorn.conf.py</code></p></blockquote><pre class="language-none"><code class="language-none">import multiprocessingworkers=3 # 并行工作进程数threads = 2 # 指定每个工作者的线程数bind=['0.0.0.0:8000'] # 监听内网端口8000proc_name='yawp' # 进程名称pidfile='/tmp/yawp.pid' # 设置进程文件目录worker_class='gevent' # 工作模式协程timeout=30 # 超时errorlog = '/home/gunicorn.error.log'  # 发生错误时log的路径accesslog = '/home/gunicorn.access.log'  # 正常时的log路径</code></pre><p>然后我们改完项目的一些配置之后，在根目录下新建一个<code>Dockerfile</code>，注意，名字一定要正确，没有任何的后缀，不要自行脑补</p><pre class="language-none"><code class="language-none">FROM python:3.7WORKDIR /Project/你的项目名COPY requirements.txt ./RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simpleCOPY . .ENV LANG C.UTF-8CMD ["gunicorn", "Blue_Lake.wsgi:application","-c","./gunicorn.conf.py"]</code></pre><blockquote><p>给不懂Dockerfile命令的同志讲解一下，Dockerfile一般有以下几个基础命令</p><ol><li><p>基础镜像，以哪个镜像作为基础进行制作，用法是FROM基础镜像名称</p></li><li><p>维护者信息，需要写下该Dockerfile编写人的姓名和邮箱，用法是MIANTAINER</p><p>名字/邮箱</p></li><li><p>镜像操作命令，对基础的镜像要进行的改造命令，比如安装新的软件，进行哪些特殊配置等，常见的是RUN命令</p></li><li><p>容器启动命令，当基于该镜像的容器启动时需要执行哪些命令，常见的是CMD命令或ENTRYPOINT命令</p></li></ol></blockquote><p>然后准备工作完成后，我们就可以进行打包了</p><pre class="language-none"><code class="language-none">docker build -t 项目名 .</code></pre><p>第一次打包可能会比较慢，如果遇到网络问题，重复执行打包命令即可</p><p>还有一件事，重复执行打包命令，会产生空悬镜象，这个解决办法请自行百度，不过不占用我们的空间，不管他也没有事。</p><p>然后键入命令<code>docker images</code> 就可以在看到你的项目镜像了，如果想把这个打包好的项目导出，只需要执行</p><pre class="language-none"><code class="language-none">docker save -o 你要导出的文件名.tar 镜像名</code></pre><p>这样你就可以把他装进U盘，随时带走，也可以进行docker push操作将其上传到dockerhub上。</p><p>然后启动项目</p><pre class="language-none"><code class="language-none">docker run --name 容器名 -d -p 8000:8000 镜像名</code></pre><p>以前也写过一篇类似的攻略，不过当时有点懵懂，所以，我又再次写了一篇攻略，另外，还有一些细小的命令，比如挂载和复制出来。</p><pre class="language-none"><code class="language-none">docker cp 4570:/Project/你的项目/settings.py 宿主机地址/settings.py</code></pre><p>这种场景主要是体现在我们需要修改某些配置的时候，我们需要知道的是，不同的项目打包完之后，项目目录并不是你所熟知的项目目录，就比如我这个django项目，打包完成之后，他的容器内部项目结构是这样的。</p><img src="/2021/01/29/docker-bu-shu-django-ying-yong/image-20210129142315983.png" alt="" style="zoom:67%;" loading="lazy"><p>我们所熟知的项目，就在Project里。</p><p>然后修改，可以使用vim，也可以使用别的，这都无所谓了。修改完之后，怎么将这个给挂载回去呢，这时候，需要用到我们的-v命令。</p><pre class="language-none"><code class="language-none">docker run --name 你的镜像名 -d -p 8001:8000 -v /宿主机文件地址/settings.py:/Project/你的项目/settings.py 镜像名</code></pre><p>docker的部署，就是这么简单，比一条条的输入命令要强的多了吧。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue解决html2canvas截图不全的问题</title>
      <link href="2021/01/27/vue-jie-jue-html2canvas-jie-tu-bu-quan-de-wen-ti/"/>
      <url>2021/01/27/vue-jie-jue-html2canvas-jie-tu-bu-quan-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="问题截图"><a href="#问题截图" class="headerlink" title="问题截图"></a>问题截图</h2><img src="/2021/01/27/vue-jie-jue-html2canvas-jie-tu-bu-quan-de-wen-ti/image-20210127160346525.png" alt="" style="zoom:67%;" loading="lazy"><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>我所知道的原因有两点，</p><p><strong>第一点</strong>：在点击保存图片时，此时要保存的资源较多，造成模块并没有完全加载完毕，就已经生成了截图；</p><p><strong>解决方案</strong>：(加上一个延时操作)</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 利用 html2canvas 下载 canvas</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token function">html2canvas</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token punctuation">{</span> canvas<span class="token operator">:</span> canvas <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">canvas</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        _this<span class="token punctuation">.</span>photoUrl <span class="token operator">=</span> canvas<span class="token punctuation">.</span><span class="token function">toDataURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>第二点</strong>：滚轮滑动造成的，主要是html2canvas是根据body进行截图，若内容高度高于body时，就会出现这样的问题(大概意思就是有滚动条时造成的)<br><strong>解决方案</strong>：(在生成截图前，先把滚动条置顶)</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span>pageYOffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>scrollTop <span class="token operator">=</span> <span class="token number">0</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>scrollTop <span class="token operator">=</span> <span class="token number">0</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker编译时遇到的bug</title>
      <link href="2021/01/25/docker-bian-yi-shi-yu-dao-de-bug/"/>
      <url>2021/01/25/docker-bian-yi-shi-yu-dao-de-bug/</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><img src="/2021/01/25/docker-bian-yi-shi-yu-dao-de-bug/image-20210125175514698.png" alt="" style="zoom:50%;" loading="lazy"><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>在<a href="https://hub.docker.com/">这里</a>注册一个账号，然后终端输入<code>docker login</code>，输入账号密码之后，再次执行打包命令即可</p></blockquote><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><blockquote><p>第二种方法就比较简单加粗暴了，换源，推荐阿里的镜像源， 其他的也可以</p></blockquote><ol><li><p>按照<a href="https://help.aliyun.com/document_detail/60750.html?spm=5176.12901015.0.i12901015.281e525cFBbUpU">这里</a>，去获得分配的加速器地址。</p></li><li><p>打开docker桌面版的设置，也就是settings</p><img src="/2021/01/25/docker-bian-yi-shi-yu-dao-de-bug/image-20210126163650810.png" alt="" style="zoom:80%;" loading="lazy"><blockquote><p>将这里的地址换成阿里云给分配的地址</p></blockquote></li><li><p>然后终端输入<code>docker info</code> 查看换源成功，即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios获取文件流并且展示为图片</title>
      <link href="2021/01/23/axios-huo-qu-wen-jian-liu-xing-shi-ru-he-zhan-shi/"/>
      <url>2021/01/23/axios-huo-qu-wen-jian-liu-xing-shi-ru-he-zhan-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>axios请求返回的是一张图片，这种情况下，我们可以直接将src定义为请求的地址，但是，如果有请求头等其他信息，这个方法就非常的鸡肋了，所以，我们还是需要搞一下</p></blockquote><h2 id="URL-createObjectURL"><a href="#URL-createObjectURL" class="headerlink" title="URL.createObjectURL()"></a>URL.createObjectURL()</h2><blockquote><p>话不多说，我们直接上代码</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    url<span class="token operator">:</span><span class="token string">'http://127.0.0.1:8000/sss/'</span><span class="token punctuation">,</span>    method<span class="token operator">:</span><span class="token string">'get'</span><span class="token punctuation">,</span>    responseType<span class="token operator">:</span><span class="token string">'arraybuffer'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'data:image/png;base64,'</span> <span class="token operator">+</span> <span class="token function">btoa</span><span class="token punctuation">(</span>        <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> byte</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> data <span class="token operator">+</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>byte<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>image <span class="token operator">=</span> data <span class="token comment">//图片地址 </span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><blockquote><p>要注意，respnseType是必须的，如果不加，会出不来</p><p>我在这里自己定义了一个image，src属性绑定的就是他，这样，我们就获取到了文件流的同时，把图片预览出来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础</title>
      <link href="2021/01/22/go/"/>
      <url>2021/01/22/go/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在一次偶然中，接触到了Go语言，这门语言是一个非常强大的编译型语言，从我接触起，便一直在记录，但愿这些能够帮助到想学习Go语言的人。</p></blockquote><p><a href="https://www.liwenzhou.com/">博客</a></p><p><a href="https://studygolang.com/pkgdoc">文档</a></p><p><a href="http://shouce.jb51.net/gopl-zh/ch1/ch1-01.html">Go语言圣经</a></p><hr><h2 id="1-编译"><a href="#1-编译" class="headerlink" title="1.编译"></a>1.编译</h2><p>使用<code>go build</code></p><p>​    1.在项目目录下执行<code>go build</code></p><p>​    2.在其他路径下执行<code>go build</code>，需要在后面加上项目的路径(项目路径从GOPATH/src后开始写起，编译之后的可执行文件就保存在当前目录下)</p><p>​    3.<code>go build -o ***.exe</code>生成编译文件时执行名字</p><h3 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h3><p>像执行脚本文件一样执行go代码</p><h3 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h3><p><code>go install</code>分为两步：</p><p>​    1.先编译得到一个可执行文件</p><p>​    2.将可执行文件拷贝到GOPATH/bin</p><hr><h4 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h4><p>Go支持跨平台编译</p><p>例如：在windows平添编译一个能在linux平台执行的可执行文件</p><pre class="language-bash" data-language="bash"><code class="language-bash">SET CGO_ENABLED=0 //禁用CGOSET GOOS=linux //目标平台是linuxSET GOARCH=amd64 //目标处理器架构是amd64</code></pre><p>如果要编译可执行文件，必须要有main包和main函数(入口函数，无参数无返回值)</p><hr><h2 id="2-变量和常量"><a href="#2-变量和常量" class="headerlink" title="2.变量和常量"></a>2.变量和常量</h2><pre class="language-go" data-language="go"><code class="language-go">package main//导入语句import "fmt"//函数外只能放标识符(变量，常量，函数，类型)的声明//程序的入口函数func main() {fmt.Println("hello world")}</code></pre><h4 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h4><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p><blockquote><p>如果标识符的首字母是大写的，就表示对外部可见,可以通过包导入</p></blockquote><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><pre class="language-go" data-language="go"><code class="language-go">break        default      func         interface    selectcase         defer        go           map          structchan         else         goto         package      switchconst        fallthrough  if           range        typecontinue     for          import       return       var</code></pre><p><code>nil</code>类似python的<code>null</code></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Go语言中的变量必须先声明再使用</p><p>注意，函数外的每个语句都必须以关键字开始(var，const，func等)</p><p>声明的变量必须使用，不使用就无法编译</p><p>同一个作用域中，不能重复声明同一个变量</p><p><code>var s1 string</code> ：声明了一个s1变量为字符串类型</p><p>批量声明:</p><pre class="language-go" data-language="go"><code class="language-go">var(    a string    b int    c bool)</code></pre><hr><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p><code>fmt.Scan()</code>代表用户输入,输入需要传指针来修改内存地址上的数据</p><pre class="language-go" data-language="go"><code class="language-go">var s stringfmt.Scan(&amp;s)fmt.Println("用户输入的内容：", s)</code></pre><p><code>fmt.Sanf</code>格式化输入</p><pre class="language-go" data-language="go"><code class="language-go">var s stringvar d stringfmt.Scanf(&amp;s &amp;d)fmt.Println("用户输入的内容：", s d)</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Printf(“name:%v”, “天听”)无论是什么类型，都能用%v来打印数值</p><pre class="language-go" data-language="go"><code class="language-go">func main() {fmt.Print("AAA")   //输出打印内容fmt.Println("BBB") //打印完内容之后会加一个换行符    fmt.Printf("name:%s", "天听") //%s:占位符，等于格式化输出}</code></pre><hr><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>占位符%T可以查看类型</p><pre class="language-go" data-language="go"><code class="language-go">fmt.Printf("%T\n", 111)fmt.Printf("%d\n", i1)fmt.Printf("%b\n", i1) //转换为二进制fmt.Printf("%o\n", i1) // 转换为八进制fmt.Printf("%x\n", i1) //转换为十六进制</code></pre><pre class="language-go" data-language="go"><code class="language-go">// %d 十进制// %c 字符// %s 字符串// %p 指针// %v 值// %f 浮点数// %t 布尔值</code></pre><blockquote><p>%%代表的才是%，不能用\转义</p></blockquote><hr><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化</p><pre class="language-go" data-language="go"><code class="language-go">var name = "Q1mi"var age = 18 //根据值判断该变量是什么类型</code></pre><hr><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p><pre class="language-go" data-language="go"><code class="language-go">package mainimport ("fmt")// 全局变量mvar m = 100func main() {n := 10m := 200 // 此处声明局部变量mfmt.Println(m, n)}</code></pre><hr><h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，(<code>_</code>多用于占位，表示忽略值。)例如：</p><pre class="language-go" data-language="go"><code class="language-go">func foo() (int, string) {return 10, "Q1mi"}func main() {x, _ := foo()_, y := foo()fmt.Println("x=", x)fmt.Println("y=", y)}</code></pre><hr><h3 id="常量-const"><a href="#常量-const" class="headerlink" title="常量 const"></a>常量 const</h3><p>声明常量的关键字const</p><pre class="language-go" data-language="go"><code class="language-go">const PI = 3.1415926</code></pre><p>也可以批量声明常量，和批量声明变量一致，只不过关键字从var变为const</p><p>批量声明常量时，如果某一行声明后没有赋值，默认就和上一行一样</p><pre class="language-go" data-language="go"><code class="language-go">const(n1 = 100    n2    n3)</code></pre><hr><h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p><p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用</p><pre class="language-go" data-language="go"><code class="language-go">const (n1 = iota //0n2        //1n3        //2n4        //3)</code></pre><p>使用<code>_</code>跳过某些值</p><pre class="language-go" data-language="go"><code class="language-go">const (n1 = iota //0n2        //1_n4        //3)</code></pre><p><code>iota</code>声明中间插队</p><pre class="language-go" data-language="go"><code class="language-go">const (n1 = iota //0n2 = 100  //100n3 = iota //2n4        //3)const n5 = iota //0</code></pre><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p><pre class="language-go" data-language="go"><code class="language-go">const (_  = iotaKB = 1 &lt;&lt; (10 * iota)MB = 1 &lt;&lt; (10 * iota)GB = 1 &lt;&lt; (10 * iota)TB = 1 &lt;&lt; (10 * iota)PB = 1 &lt;&lt; (10 * iota))</code></pre><p>多个<code>iota</code>定义在一行</p><pre class="language-go" data-language="go"><code class="language-go">const (a, b = iota + 1, iota + 2 //1,2c, d                      //2,3e, f                      //3,4)</code></pre><hr><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p><p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint8</td><td align="center">无符号 8位整型 (0 到 255)</td></tr><tr><td align="center">uint16</td><td align="center">无符号 16位整型 (0 到 65535)</td></tr><tr><td align="center">uint32</td><td align="center">无符号 32位整型 (0 到 4294967295)</td></tr><tr><td align="center">uint64</td><td align="center">无符号 64位整型 (0 到 18446744073709551615)</td></tr><tr><td align="center">int8</td><td align="center">有符号 8位整型 (-128 到 127)</td></tr><tr><td align="center">int16</td><td align="center">有符号 16位整型 (-32768 到 32767)</td></tr><tr><td align="center">int32</td><td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="center">int64</td><td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h4 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h4><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint</td><td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td></tr><tr><td align="center">int</td><td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td></tr><tr><td align="center">uintptr</td><td align="center">无符号整型，用于存放一个指针</td></tr></tbody></table><p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p><p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code></p><p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p><pre class="language-go" data-language="go"><code class="language-go">package mainimport (        "fmt"        "math")func main() {        fmt.Printf("%f\n", math.Pi)        fmt.Printf("%.2f\n", math.Pi)}</code></pre><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p><p><strong>注意：</strong></p><ol><li>布尔类型变量的默认值为<code>false</code>。</li><li>Go 语言中不允许将整型强制转换为布尔型.</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li></ol><hr><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Go语言中字符串是用<strong>双引号</strong>包裹的</p><p>单引号包裹的是字符，字符是单独的字母、汉字、符号</p><h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5><p>转义：</p><p>\代表转义，如果单纯的想打印一个\，需要在前面再加一个\</p><table><thead><tr><th align="center">转义符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>\r</code></td><td align="center">回车符（返回行首）</td></tr><tr><td align="center"><code>\n</code></td><td align="center">换行符（直接跳到下一行的同列位置）</td></tr><tr><td align="center"><code>\t</code></td><td align="center">制表符</td></tr><tr><td align="center"><code>\'</code></td><td align="center">单引号</td></tr><tr><td align="center"><code>\"</code></td><td align="center">双引号</td></tr><tr><td align="center"><code>\\</code></td><td align="center">反斜杠</td></tr></tbody></table><p>多行字符串:    `，使用此符号时，无需用\转义</p><pre class="language-go" data-language="go"><code class="language-go">s1 := `aaabbbccc`</code></pre><table><thead><tr><th align="center">方法</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">len(str)</td><td align="center">求长度</td></tr><tr><td align="center">+或fmt.Sprintf</td><td align="center">拼接字符串</td></tr><tr><td align="center">strings.Split</td><td align="center">分割</td></tr><tr><td align="center">strings.contains</td><td align="center">判断是否包含</td></tr><tr><td align="center">strings.HasPrefix,strings.HasSuffix</td><td align="center">前缀/后缀判断</td></tr><tr><td align="center">strings.Index(),strings.LastIndex()</td><td align="center">子串出现的位置(下标)</td></tr><tr><td align="center">strings.Join(a[]string, sep string)</td><td align="center">join操作</td></tr></tbody></table><p> byte和rune类型</p><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><pre class="language-go" data-language="go"><code class="language-go">var a := '中'var b := 'x'</code></pre><p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code></p><p>修改字符串：</p><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><pre class="language-go" data-language="go"><code class="language-go">func changeString() {s1 := "big"// 强制类型转换byteS1 := []byte(s1)byteS1[0] = 'p'fmt.Println(string(byteS1))s2 := "白萝卜"runeS2 := []rune(s2)runeS2[0] = '红'fmt.Println(string(runeS2))}</code></pre><p>类型转换：</p><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p><p>强制类型转换的基本语法如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">T(表达式)</code></pre><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组的长度是数组类型的一部分，例如<code>var al [3]bool</code>，代表了al是一个长度为3元素类型为布尔的数组</p><h5 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h5><pre class="language-go" data-language="go"><code class="language-go">var a1 [3]bool//初始化a1 = [3]bool{true, true, false}//根据初始值自动推断数组的长度是多少a2 := [...]int{1, 2, 3, 4, 5, 6, 7}fmt.Println(a2)//根据索引初始化a3 := [5]int{0:2,4:3}fmt.Println(a3)</code></pre><h5 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h5><pre class="language-go" data-language="go"><code class="language-go">citys := [...]string{"北京", "上海", "深圳"}for i := 0; i &lt; len(citys); i++ {fmt.Println(citys[i])}</code></pre><pre class="language-go" data-language="go"><code class="language-go">//range遍历for i, v := range citys {fmt.Println(i, v)}</code></pre><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><blockquote><p>多维数组就是数组的嵌套，如[[1,2],[2,3],[3,4]]</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">var a4 [3][2]int//[3]是外层数组，[2]int是该数组的数据类型，元素为两个inta4 = [3][2]int{[2]int{1, 2},[2]int{3, 4},[2]int{5, 6},}fmt.Println(a4)</code></pre><h5 id="多维数组的遍历"><a href="#多维数组的遍历" class="headerlink" title="多维数组的遍历"></a>多维数组的遍历</h5><pre class="language-go" data-language="go"><code class="language-go">var a4 [3][2]inta4 = [3][2]int{[2]int{1, 2},[2]int{3, 4},[2]int{5, 6},}for _, v := range a4 {for _, i := range v {fmt.Println(i)}}</code></pre><hr><h2 id="4-if与for"><a href="#4-if与for" class="headerlink" title="4.if与for"></a>4.if与for</h2><h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><pre class="language-go" data-language="go"><code class="language-go">age := 16if age &gt;= 18 {fmt.Println("成年")} else {fmt.Println("未成年")}</code></pre><p>也可以将变量定义到if的作用域中,这样，该变量只会在if作用域中</p><pre class="language-go" data-language="go"><code class="language-go">if age := 16; age &gt;= 18 {fmt.Println("成年")} else {fmt.Println("未成年")}</code></pre><p>else if</p><pre class="language-go" data-language="go"><code class="language-go">if age := 16; age &gt;= 18 {fmt.Println("成年")} else if age &gt;= 16 {fmt.Println("小成年")} else {fmt.Println("未成年")}</code></pre><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>基本格式</p><p>for 初始语句;条件;结束语句{}</p><pre class="language-go" data-language="go"><code class="language-go">for i := 0; i &lt; 10; i++ {fmt.Println(i)}</code></pre><p>省略初始语句的写法 **;**不能少</p><pre class="language-go" data-language="go"><code class="language-go">var i=5for ;i&lt;10;i++{    fmt.Println(i)}</code></pre><p>省略结束语句的写法,如果不加条件，则是无限循环，由于go语言运行速度极快，不要轻易尝试</p><pre class="language-go" data-language="go"><code class="language-go">var i=5for ;i&lt;10;{    fmt.Println(i)    i++}</code></pre><p>for range循环，有两个变量接收，第一个是索引，第二个是值</p><pre class="language-go" data-language="go"><code class="language-go">s:= "hello天听"for i,v := range s{    fmt.Printf("%d,%c\n",i,v)}</code></pre><p>break：跳出for循环</p><p>contiune：跳过本次循环，继续下一次</p><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>简化大量的判断</p><pre class="language-go" data-language="go"><code class="language-go">var a = 3switch a {case 1:fmt.Println("1")case 2:fmt.Println("2")case 3:fmt.Println("3")case 4:fmt.Println("4")    default:        fmt.Println("无效") }</code></pre><hr><h2 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5.运算符"></a>5.运算符</h2><p>Go语言是<code>强类型</code>,相同类型的变量才能比较</p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">相加</td></tr><tr><td align="center">-</td><td align="center">相减</td></tr><tr><td align="center">*</td><td align="center">相乘</td></tr><tr><td align="center">/</td><td align="center">相除</td></tr><tr><td align="center">%</td><td align="center">求余</td></tr></tbody></table><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td align="center">!=</td><td align="center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td align="center">&gt;</td><td align="center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&gt;=</td><td align="center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&lt;</td><td align="center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&lt;=</td><td align="center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td align="center">||</td><td align="center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td align="center">!</td><td align="center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符对整数在内存中的<code>二进制</code>位进行操作。</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td></tr><tr><td align="center">|</td><td align="center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td></tr><tr><td align="center">^</td><td align="center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><table><thead><tr><th>=</th><th>简单的赋值运算符，将一个表达式的值赋给一个左值</th></tr></thead><tbody><tr><td>+=</td><td>相加后再赋值</td></tr><tr><td>-=</td><td>相减后再赋值</td></tr><tr><td>*=</td><td>相乘后再赋值</td></tr><tr><td>/=</td><td>相除后再赋值</td></tr><tr><td>%=</td><td>求余后再赋值</td></tr><tr><td>&lt;&lt;=</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;=</td><td>右移后赋值</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td></tr><tr><td>|=</td><td>按位或后赋值</td></tr><tr><td>^=</td><td>按位异或后赋值</td></tr></tbody></table><hr><h2 id="6-切片"><a href="#6-切片" class="headerlink" title="6.切片"></a>6.切片</h2><p><code>len</code>代表长度</p><p><code>cap</code>代表容量</p><blockquote><p>切片必须初始化分配内存</p><p>切片不存值，指向同一个底层数组，所以，怎样赋值切片之后改变，都会使同样的底层数组发生改变，类似浅拷贝</p></blockquote><h4 id="自定义切片"><a href="#自定义切片" class="headerlink" title="自定义切片"></a>自定义切片</h4><pre class="language-go" data-language="go"><code class="language-go">var s1 []int //定义一个存放int类型元素的切片//初始化s1 = []int{1,2,3}</code></pre><h4 id="由数组得到切片"><a href="#由数组得到切片" class="headerlink" title="由数组得到切片"></a>由数组得到切片</h4><pre class="language-go" data-language="go"><code class="language-go">a1 :=[...]int{1,2,3,4,5}s3 := a1[0:4]</code></pre><h4 id="make函数创建切片"><a href="#make函数创建切片" class="headerlink" title="make函数创建切片"></a>make函数创建切片</h4><blockquote><p>make([]int,元素数量,容量)</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">s1 := make([]int, 5,10)fmt.Printf("s1=%v len(s1)=%d cap(s1)=%d\n", s1, len(s1), cap(s1))</code></pre><p>切片的本质就是一个框，框住了一块连续的内存，属于引用类型，真正的数据都保存在底层数组里</p><p>切片不能<strong>直接比较</strong>，只能和<strong>nil</strong>比较</p><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><h4 id="append函数添加"><a href="#append函数添加" class="headerlink" title="append函数添加"></a>append函数添加</h4><blockquote><p>调用append函数必须使用原来的切片变量接收返回值</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">s1 := []string{"龙潭", "四海门", "空境"}s1 = append(s1, "洞天")fmt.Println(s1)//多个元素添加，用...进行拆开s1 := []string{"龙潭", "四海门", "空境"}s2 := []string{"望苍城", "天下城", "万象城"}s1 = append(s1, s2...)fmt.Println(s1)</code></pre><h4 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h4><pre class="language-go" data-language="go"><code class="language-go">首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</code></pre><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><pre class="language-go" data-language="go"><code class="language-go">//此处，将s1的值拷贝给了s3，深拷贝，此时s1如何修改都与s3无关s1 := []string{"龙潭", "四海门", "空境"}s2 := s1var s3 = make([]string, 3, 3)fmt.Println(s1, s2, s3)copy(s3, s1)fmt.Println(s1, s2, s3)</code></pre><h4 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h4><pre class="language-go" data-language="go"><code class="language-go">// 从切片中删除元素a := []int{30, 31, 32, 33, 34, 35, 36, 37}// 要删除索引为2的元素a = append(a[:2], a[3:]...)fmt.Println(a) //[30 31 33 34 35 36 37]</code></pre><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7.指针"></a>7.指针</h2><p>在Go语言中对于引用类型的变量，在使用的时候不仅要声明它，还要为它分配内存空间，否则值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。Go语言中new和make是内建的两个函数，主要用来分配内存。</p><blockquote><p>go语言中不存在指针操作，只需要记住两个符号</p><p><code>&amp;</code>：取地址</p><p><code>*</code>：根据地址取值</p></blockquote><ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li></ul><pre class="language-go" data-language="go"><code class="language-go">//&amp;a := 20fmt.Println(&amp;a)//*p := &amp;am := *pfmt.Println(m)</code></pre><h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p>new函数是一个内置的函数，可以申请一个内存地址</p><p>new很少用，一般用来给基本数据类型申请内存，int/string等</p><pre class="language-go" data-language="go"><code class="language-go">var a *int  //声明一个变量fmt.Println(a)var a2 = new(int) // new函数申请内存地址fmt.Println(*a2)*a2 = 100 //重新赋值fmt.Println(*a2)</code></pre><blockquote><p>返回的是指针</p></blockquote><h3 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h3><blockquote><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针。</p></blockquote><hr><h2 id="8-map"><a href="#8-map" class="headerlink" title="8.map"></a>8.<strong><code>map</code></strong></h2><blockquote><p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p></blockquote><blockquote><p>map是一种<strong>无序</strong>的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p></blockquote><p>map[键类型]值类型</p><pre class="language-go" data-language="go"><code class="language-go">var a map[string]int // 声明一个mapa = make(map[string]int, 10) //初始化a["天听"] = 20//添加数据a["并轩"] = 30a["冰冰"] = 16fmt.Println(a)v, ok := a["冰冰"]  //返回两个值，一个是数据，一个是布尔值，约定成俗是okif !ok { //如果ok为false，则查找不到fmt.Println("查无此人")} else {fmt.Println(v)}</code></pre><h3 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h3><pre class="language-go" data-language="go"><code class="language-go">for k, v := range a {fmt.Println(k, v)}</code></pre><p>如果只用一个参数接收，默认接收k</p><pre class="language-go" data-language="go"><code class="language-go">for k := range a {fmt.Println(k)}</code></pre><p>如果只是单纯的想拿到值，可以用_接收k</p><pre class="language-go" data-language="go"><code class="language-go">for _, v := range a {fmt.Println(v)}</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>用delete删除</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">delete(a,键)</code></pre><h2 id="9-函数"><a href="#9-函数" class="headerlink" title="9.函数"></a>9.函数</h2><p>函数是一段代码的<strong>封装</strong></p><blockquote><p>在go语言中，函数格式为<code>func 函数名(参数)(返回值){}</code></p><p>并且要指定参数类型和返回值类型</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func sum(x int, y int) (ret int) {return x * y}func main() {a := sum(2, 55)fmt.Println(a)}</code></pre><blockquote><p>无参数有返回值</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func a1() string {return "jajajaj"}</code></pre><blockquote><p>返回值可以命名也可以不命名，但是，需要声明返回值</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func a2(x int,y int)(ret int){ //声明ret    ret = x+y //直接可以使用}//也可以不命名返回值func a2(x int,y int) int{    ret := x+y //声明    return ret //使用}</code></pre><blockquote><p>返回值可以有多个，需要用()括起来</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func a2(x int,y int)(int,string){    return 1,"天听"}</code></pre><blockquote><p>参数类型简写</p><p>当参数中，连续两个参数类型一致，可以将前边的参数类型省略</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func a2(x,y int)(ret int){    ret = x+y}</code></pre><blockquote><p>可变长参数</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func a2(x string,y ...int){ //...int，可变长，但是，都得是int类型    fmt.Println(x)    fmt.Println(y)}</code></pre><blockquote><p>注意，go语言中函数传参永远是深拷贝</p></blockquote><h3 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h3><blockquote><p><code>defer</code>语句会将其后边跟随的语句进行延迟处理，在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行</p><p>也就是说，有多个<code>defer</code>语句时，最先写的<code>defer</code>最后被执行，最后写的<code>defer</code>最先被执行</p></blockquote><blockquote><p>defer多用于函数结束之前释放资源</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func deferDemo() {fmt.Println("start")defer fmt.Println("AAA")defer fmt.Println("BBB")defer fmt.Println("CCC")fmt.Println("end")}/*执行结果为startendCCCBBBAAA*/</code></pre><p>Go语言中的<strong>return</strong>不是原子操作，在底层是分为两步来执行</p><blockquote><p>第一步：返回值赋值</p><p>第二步：真正的RET返回</p><p>函数中如果存在defer，那么defer执行的时机是在第一步和第二步之间</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func f1() (x int) {    x = 5   //返回值赋值defer func() {x++  //执行defer}()return x //RET返回}</code></pre><pre class="language-go" data-language="go"><code class="language-go">func f1() int {   //此时的返回值没有命名x := 5defer func() {  //defer修改的是x而不是返回值x++}()return x  }</code></pre><blockquote><p>函数也可以作为参数和返回值</p><p>只要是满足参数和返回值的类型要求</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func f1(){ //类型为func()    }func f2() int{  // 类型为func()int    return 100}func f3(x func()){ //此处可以将类型为func()的函数传进来    }func f4(x func()int){//此处可以将类型为func()int的函数传进来    }</code></pre><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><blockquote><p>因为函数内部无法声明有名字的函数，所以，在匿名函数多用于在函数内部</p></blockquote><p>匿名函数定义：<code>func(){}</code></p><pre class="language-go" data-language="go"><code class="language-go">func main(){    func(x,y int){        fmt.Println(x+y)    }(1,2)//如果只是调用一次的函数，可以简写成立即执行函数，加个括号}</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p>闭包的本质就是一个函数，函数可以作为返回值，因为函数内部查找变量的顺序是由内而外，所以，在自己内部找不到变量就得去外层找，包含了一个外部作用域变量的特殊函数</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func f1(a int) (func(int) int, func(int) int) {//声明一个函数，有参数a，两个有参有返的函数返回值add := func(i int) int {a += ireturn a}    //内部声明匿名函数sub := func(i int) int {a -= ireturn a}    //内部声明匿名函数return add, sub    //满足了条件}func main() {q1, q2 := f1(10) //  q1,q2的类型为func(int) int// 参数a是10fmt.Println(q1(1), q2(2)) //11 9}</code></pre><blockquote><p>上面的例子中为什么不是8而是9，因为传的参数a并不是内部匿名函数的参数，所以，按照返回值的顺序，先执行了add，再执行sub</p></blockquote><h2 id="10-作用域"><a href="#10-作用域" class="headerlink" title="10.作用域"></a>10.作用域</h2><blockquote><p>和python相同点，全局作用域和局部作用域</p><p>不同点为，Go语言的if…else，switch..case等都会产生<strong>语句块作用域</strong></p></blockquote><h2 id="11-内置函数"><a href="#11-内置函数" class="headerlink" title="11.内置函数"></a>11.内置函数</h2><table><thead><tr><th align="center">内置函数</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">close</td><td align="center">主要用来关闭channel</td></tr><tr><td align="center">len</td><td align="center">用来求长度，比如string、array、slice、map、channel</td></tr><tr><td align="center">new</td><td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td align="center">make</td><td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td align="center">append</td><td align="center">用来追加元素到数组、slice中</td></tr><tr><td align="center">panic和recover</td><td align="center">用来做错误处理</td></tr></tbody></table><h3 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a>panic/recover</h3><blockquote><p>Go语言中目前是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func f2() {defer func() {err := recover()fmt.Println(err)fmt.Println("关闭程序")}()fmt.Println("B")panic("错误")}</code></pre><blockquote><p>注意，<code>recover</code>一定要搭配<code>defer</code>使用</p></blockquote><h2 id="12-自定义类型和类型别名"><a href="#12-自定义类型和类型别名" class="headerlink" title="12.自定义类型和类型别名"></a>12.自定义类型和类型别名</h2><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><p><code>type 自定义类型 内置类型</code></p><pre class="language-go" data-language="go"><code class="language-go">type ssint int</code></pre><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p><code>type 别名 = 内置类型</code></p><pre class="language-go" data-language="go"><code class="language-go">type yourInt = int</code></pre><h2 id="13-结构体"><a href="#13-结构体" class="headerlink" title="13.结构体"></a>13.结构体</h2><blockquote><p>结构体的内存地址是连续的，并不是每个字段一个内存</p></blockquote><blockquote><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p></blockquote><p>Go语言中通过<code>struct</code>来实现面向对象</p><blockquote><p>使用<code>type</code>和<code>struct</code>关键字来定义结构体</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">type 类型名 struct{    字段名 字段类型    字段名 字段类型}type person struct{    name string    age int    gender string}//实例化"对象"var a persona.name = "天听"a.age = 18a.gender = "男"</code></pre><h4 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h4><pre class="language-go" data-language="go"><code class="language-go">var s struct{    name string    age int}</code></pre><blockquote><p>和定义结构体不同的是，匿名结构体是在声明变量，而不是声明结构体类型</p></blockquote><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><blockquote><p>结构体可以当做值传进函数内，通过指针，也可以将某个值的内存地址传过去</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func f1(x person) {  //此时传的是结构体x.gender = "女"}func f2(x *person) { // 此时，传的是结构体的指针(*x).gender = "女"    //x.gender = "女"   //两种写法都可以}func main() {var a persona.name = "天听"a.gender = "男"f1(a)fmt.Println(a.gender) //由于传过去的是深拷贝，所以，修改不会成功f2(&amp;a)fmt.Println(a.gender)//通过指针修改了内存地址上的值，所以，修改成功了}</code></pre><h4 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h4><pre class="language-go" data-language="go"><code class="language-go">var b = persson{name:   "并轩",gender: "女",}fmt.Println(b)</code></pre><pre class="language-go" data-language="go"><code class="language-go">var c = persson{"狮子","男",}fmt.Println(c)</code></pre><blockquote><p>注意，以上两种方法不能混用</p></blockquote><blockquote><p>当结构体比较大的时候尽量使用结构体指针，减少程序的内存开销</p></blockquote><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote><p>返回一个结构体变量的函数</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func newDog(name string) dog {    return dog{        name:name,    }}</code></pre><h4 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h4><blockquote><p>方法是作用域特定类型的函数</p></blockquote><blockquote><p>接收者表示的是调用该方法的具体类型变量，多用类型名首字母小写表示，写在函数名前面</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">type dog struct{    name string}func (d dog)wang(){    fmt.Printf("%s:汪汪汪~",d.name)}func main(){    d1 := newDog("哈士奇")    d1.wang()}</code></pre><h5 id="接收者"><a href="#接收者" class="headerlink" title="接收者"></a>接收者</h5><pre class="language-go" data-language="go"><code class="language-go">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {    函数体}</code></pre><p>什么时候需要用指针接收者：</p><blockquote><p>需要修改接收者的值，需要用指针接收者</p></blockquote><blockquote><p>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者</p></blockquote><blockquote><p>接收者是拷贝代价比较大的大对象</p></blockquote><h4 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h4><blockquote><p>结构体中只有类型没有名字的字段，并且类型不能重复</p><p>当字段比较少也比较简单时使用</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">type person struct{    string    int    //string  此时再写string就会报错，因为类型不能重复}</code></pre><h4 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h4><blockquote><p>结构体嵌套结构体</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">type address struct{  //类型1    name string    age int}type ren struct{    gender string    addr address   // 嵌套了类型1}func main(){    f1 := ren{        gender:"男",        addr:address{   //嵌套结构体构造数据            name:"天听",            age:20,        }    }}</code></pre><h4 id="匿名嵌套结构体"><a href="#匿名嵌套结构体" class="headerlink" title="匿名嵌套结构体"></a>匿名嵌套结构体</h4><pre class="language-go" data-language="go"><code class="language-go">type address struct{      name string    age int}type ren struct{    gender string    address   // 匿名嵌套}func main(){    f1 := ren{        gender:"男",        addr:address{               name:"天听",            age:20,        }    }    // fmt.Println(f1.addr.name)    fmt.Println(f1.name)}</code></pre><blockquote><p>匿名嵌套结构体的好处是可以直接调用被嵌套结构体中的字段</p><p>但是，如果嵌套了两个结构体，而这两个结构体中有一样的字段，这种写法会有字段冲突，解决办法就是写全</p></blockquote><h4 id="结构体模拟“继承”"><a href="#结构体模拟“继承”" class="headerlink" title="结构体模拟“继承”"></a>结构体模拟“继承”</h4><pre class="language-go" data-language="go"><code class="language-go">//动物类type animal struct {name string}//动物的方法func (a animal) move() {fmt.Printf("%s会动\n", a.name)}//狗类，继承动物类type dog struct {id uint8animal}//狗类的方法func (d dog) wang() {fmt.Printf("%s在叫", d.name)}func main() {d1 := dog{id:     1,animal: animal{name: "哈士奇"},}d1.wang()d1.move()  //动物类的方法，狗类同样也能使用}</code></pre><h4 id="结构体与JSON"><a href="#结构体与JSON" class="headerlink" title="结构体与JSON"></a>结构体与JSON</h4><blockquote><p>序列化：把go语言中的结构体变量转换为json格式的字符串</p><p>反序列化：json格式的字符串转换为go语言中能够识别的结构体变量</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">import "encoding/json"func main(){    f1 := person{        name:"天听",        age:18,    }    b,err := json.Marshal(f1)}</code></pre><h2 id="14-接口"><a href="#14-接口" class="headerlink" title="14.接口"></a>14.接口</h2><p>关键字：<code>interface</code></p><blockquote><p>注意：接口是一种类型,他规定了数据有哪些方法</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">//造接口，只要是有speak方法的变量，他就是speaker类型的接口type speaker interface {speak()}//造两个结构体type dog struct{}type cat struct{}//各有一个speak方法func (d dog) speak() {fmt.Println("汪汪汪")}func (c cat) speak() {fmt.Println("喵喵喵")}//只需要将接口传进来即可func da(x speaker) {x.speak()}func main() {var c catvar d dogda(c)da(d)}</code></pre><blockquote><p>一个接口中可以有多个方法，但是需要全部实现才算是这个接口类型的变量，只实现其中的某个方法不算这个接口变量.</p><p>同一个结构体可以实现多个接口</p></blockquote><p> 使用<strong>值接收者</strong>和<strong>指针接收者</strong>实现接口区别：</p><pre><code>1. 使用**值接收者**实现接口，结构体类型和结构体指针类型的变量都能存 2. **指针接收者**实现接口，只能存结构体指针类型的变量</code></pre><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><pre class="language-go" data-language="go"><code class="language-go">interface{}   // 空接口</code></pre><blockquote><p>所有的类型都实现了空接口，也就是任意类型的变量都能保存在空接口中</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func main(){    var m1 map[string]interface{}//注意加括号，否则只是关键字    m1 = make(map[string]interface{})    m1["name"] = "天听"    m1["age"] = 18}</code></pre><blockquote><p>在上面的例子中，既可以保存字符串，又能保存整型</p></blockquote><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p><code>x.(T)</code> </p><ul><li>x:表示类型为<code>interface{}</code>的变量</li><li>T:表示断言，x可能是的类型</li></ul><pre class="language-go" data-language="go"><code class="language-go">func ss(a interface{}){    str,ok := a.(string) //类型断言    if !ok{        fmt.Println("猜错了")    }else{        fmt.Println("字符串")    }}</code></pre><pre class="language-go" data-language="go"><code class="language-go">func ss(a interface{}){    switch t := a.(type){        case string:        fmt.Println("字符串")        case int:        fmt.Println("整型")        case bool:        fmt.Println("布尔")    }}</code></pre><h2 id="15-包"><a href="#15-包" class="headerlink" title="15.包"></a>15.包</h2><p>包中的<code>标识符</code>首字母大写才可以对外部可见</p><blockquote><p>根据自己的需要创建自己的包。一个包可以简单理解为一个存放<code>.go</code>文件的<strong>文件夹</strong>。 该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">package 包名   //包的定义</code></pre><ul><li>一个文件夹下面直接包含的文件只能归属一个<code>package</code>，同样一个<code>package</code>的文件不能在多个文件夹下。</li><li>包名可以不和文件夹的名字一样，包名不能包含 <code>-</code> 符号。</li><li>包名为<code>main</code>的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含<code>main</code>包的源代码则不会得到可执行文件。</li></ul><blockquote><p>要在代码中引用其他包的内容，需要使用<code>import</code>关键字导入使用的包</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">import "包的路径"   // 包的导入</code></pre><p>注意事项：</p><ul><li>import导入语句通常放在文件开头包声明语句的下面。</li><li>导入的包名需要使用双引号包裹起来。</li><li>包名是从<code>$GOPATH/src/</code>后开始计算的，使用<code>/</code>进行路径分隔。</li><li>Go语言中禁止循环导入包。</li></ul><h4 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a>匿名导入包</h4><blockquote><p>如果只希望导入包，而不使用包内部的数据时，可以使用匿名导入包</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">import _ "包的路径"</code></pre><blockquote><p>匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中</p></blockquote><h4 id="init初始化函数"><a href="#init初始化函数" class="headerlink" title="init初始化函数"></a>init初始化函数</h4><blockquote><p>在Go语言程序执行时导入包语句会自动触发包内部<code>init()</code>函数的调用。需要注意的是： <code>init()</code>函数没有参数也没有返回值。 <code>init()</code>函数在程序运行时自动被调用执行，不能在代码中主动调用它</p></blockquote><h2 id="16-文件操作"><a href="#16-文件操作" class="headerlink" title="16.文件操作"></a>16.文件操作</h2><blockquote><p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>和一个<code>err</code>。对得到的文件实例调用，<code>close()</code>方法能够关闭文件。</p></blockquote><blockquote><p>为了防止文件忘记关闭，通常使用defer注册文件关闭语句</p></blockquote><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><pre class="language-go" data-language="go"><code class="language-go">//打开文件，返回两个参数fileobj, err := os.Open("./main.go")if err != nil {fmt.Println("错误为:", err)return}defer fileobj.Close()var tmp = make([]byte, 128)//var tmp = [128]bytefor {n, err := fileobj.Read(tmp[:])if err != nil {fmt.Println("读取错误为：", err)return}fmt.Println("读取的字节数为：", n)fmt.Println(string(tmp[:n]))if n &lt; 128 {return}}</code></pre><h4 id="file-Read"><a href="#file-Read" class="headerlink" title="file.Read()"></a>file.Read()</h4><blockquote><p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code></p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func (f *File) Read(b []byte) (n int, err error)//Read方法定义</code></pre><h4 id="bufio"><a href="#bufio" class="headerlink" title="bufio"></a>bufio</h4><blockquote><p>bufio是在file的基础上封装了一层API，支持更多的功能</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">fileobj, err := os.Open("./main.go")if err != nil {fmt.Println("错误为：", err)return}defer fileobj.Close()//创建一个用来从文件中读取内容的对象reader := bufio.NewReader(fileobj)for {line, err := reader.ReadString('\n')if err == io.EOF {return}if err != nil {fmt.Println("！！！！", err)return}fmt.Print(line)}</code></pre><h4 id="ioutil"><a href="#ioutil" class="headerlink" title="ioutil"></a>ioutil</h4><p><code>io/ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入</p><pre class="language-go" data-language="go"><code class="language-go">content, err := ioutil.ReadFile("./main.go")if err != nil {    fmt.Println("read file failed, err:", err)    return}fmt.Println(string(content))</code></pre><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能</p><p><code>name</code>：要打开的文件名</p><p> <code>flag</code>：打开文件的模式：</p><table><thead><tr><th align="center">模式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>os.O_WRONLY</code></td><td align="center">只写</td></tr><tr><td align="center"><code>os.O_CREATE</code></td><td align="center">创建文件</td></tr><tr><td align="center"><code>os.O_RDONLY</code></td><td align="center">只读</td></tr><tr><td align="center"><code>os.O_RDWR</code></td><td align="center">读写</td></tr><tr><td align="center"><code>os.O_TRUNC</code></td><td align="center">清空</td></tr><tr><td align="center"><code>os.O_APPEND</code></td><td align="center">追加</td></tr></tbody></table><h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><blockquote><p>写入字节切片数据</p></blockquote><h4 id="WriteString"><a href="#WriteString" class="headerlink" title="WriteString"></a>WriteString</h4><blockquote><p>直接写入字符串数据</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">fileobj, err := os.OpenFile("./ss.txt", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)if err != nil {fmt.Println(err)return}fileobj.Write([]byte("执子之魂，与子共生\n"))fileobj.WriteString("那些逃离死亡的人，其生命，早已停滞不前")defer fileobj.Close()</code></pre><h4 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h4><pre class="language-go" data-language="go"><code class="language-go">fileobj, err := os.OpenFile("./ss.txt", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)if err != nil {fmt.Println(err)return}wr := bufio.NewWriter(fileobj)//将数据先写入缓存wr.WriteString("明天，只是一个希望，不是一个承诺")//将缓存中的内容写入文件wr.Flush()defer fileobj.Close()</code></pre><h4 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h4><pre class="language-go" data-language="go"><code class="language-go">str := "hello 龙潭"err := ioutil.WriteFile("./xx.txt", []byte(str), 0666)if err != nil {    fmt.Println("write file failed, err:", err)    return}</code></pre><h2 id="17-时间模块"><a href="#17-时间模块" class="headerlink" title="17.时间模块"></a>17.时间模块</h2><h4 id="time包"><a href="#time包" class="headerlink" title="time包"></a><code>time</code>包</h4><blockquote><p>time包是时间模块</p></blockquote><blockquote><p>当前时间</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func main(){    now := time.Now()    fmt.Println(now)    fmt.Println(now.Year())}</code></pre><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><blockquote><p><code>Unix()</code></p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func main(){    now := time.Now()    fmt.Println(now.Unix()) //时间戳    fmt.Println(now.UnixNano()) //纳秒时间戳}</code></pre><h4 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h4><p><code>time.Duration</code>是<code>time</code>包定义的一个类型，它代表两个时间点之间经过的时间，以<strong>纳秒</strong>为单位。</p><p>time包中定义的时间间隔类型的常量如下：</p><pre class="language-go" data-language="go"><code class="language-go">const (    Nanosecond  Duration = 1    Microsecond          = 1000 * Nanosecond    Millisecond          = 1000 * Microsecond    Second               = 1000 * Millisecond    Minute               = 60 * Second    Hour                 = 60 * Minute)</code></pre><blockquote><p><code>time.Duration</code>表示1纳秒，<code>time.Second</code>表示1秒。</p></blockquote><h4 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h4><blockquote><p>在日常编码可能会遇到要求时间+时间间隔需求，这时，需要用到<code>Add</code></p></blockquote><pre class="language-go" data-language="go"><code class="language-go">fmt.Println(time.Second)//当前时间+24小时fmt.Println(now.Add(24*time.Hour))</code></pre><h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><blockquote><p>通俗的讲，就是把语言中的时间对象转换成字符串类型的时间</p></blockquote><blockquote><p>格式化时间模板不是常见的<code>Y-m-d H:M:S</code>而是使用Go的诞生时间2006年1月2号15点04分（记忆口诀为2006 1 2 3 4）</p></blockquote><p><code>now.Format</code></p><pre class="language-go" data-language="go"><code class="language-go">// 注意，格式化是从2006-01-02开始，这个值不可变fmt.Println(now.Format("2006-01-02"))fmt.Println(now.Format("2006-01-02 15:04:05"))</code></pre><h4 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h4><blockquote><p>按照对应的格式解析字符串类型的时间</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">time.Parse("2006-01-02","2020-8-20")</code></pre><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><blockquote><p>使用<code>time.Tick(时间间隔)</code>来设置定时器，定时器的本质上是一个通道（channel）</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">func tickDemo() {ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器for i := range ticker {fmt.Println(i)//每秒都会执行的任务}}</code></pre><h2 id="18-log日志服务"><a href="#18-log日志服务" class="headerlink" title="18.log日志服务"></a>18.log日志服务</h2><blockquote><p>Go语言内置的<code>log</code>包实现了简单的日志服务。</p></blockquote><pre class="language-go" data-language="go"><code class="language-go">log.Println("打印的日志")//输入结果//2020/08/20 16:28:50 打印的日志</code></pre><p><code>log.SetOutput()</code>设置输出位置</p><h2 id="19-反射"><a href="#19-反射" class="headerlink" title="19.反射"></a>19.反射</h2><blockquote><p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p></blockquote><blockquote><p>反射类似于ORM</p></blockquote><h4 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h4><blockquote><p>在Go语言的反射机制中，任何接口值都由是<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成</p></blockquote><blockquote><p>在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p></blockquote><hr><p><code>VScode</code>中，<code>ctrl+shift+p</code>搜索<code>snippet</code> 之后选择go，可以定义快捷键输出</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序用户认证逻辑</title>
      <link href="2021/01/21/wei-xin-xiao-cheng-xu-yong-hu-ren-zheng-luo-ji/"/>
      <url>2021/01/21/wei-xin-xiao-cheng-xu-yong-hu-ren-zheng-luo-ji/</url>
      
        <content type="html"><![CDATA[<p><strong>调用</strong></p><ol><li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.login.html">wx.login()</a>获取临时登录凭证code，并回传到开发者服务器。</li><li>调用<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/code2Session.html">code2Session</a>接口，换取用户唯一标识 OpenID和会话密钥 session_key。</li></ol><p>之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。</p><p><strong>注意：</strong></p><p>会话密钥<code>session_key</code>是对用户数据进行<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html">加密签名</a>的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。</p><p>临时登录凭证 code 只能使用一次</p><p><strong>总结:</strong><br>小程序端执行wx.login后在回调函数中就能拿到上图的code,然后把这个code传给我们后端程序，后端拿到这个这个code后，可以请求code2Session接口拿到用的openid和session_key,openid是用户在微信中唯一标识，我们就可以把这个两个值(val)存起来，然后返回一个键（key）给小程序端，下次小程序请求我们后端的时候，带上这个key，我们就能找到这个val,就可以，这样就把登入做好了。</p><p><strong>wx.login</strong></p><p>调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户的唯一标识（openid）及本次登录的会话<br>密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。[/code]</p><p>参数</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th><th align="left">最低版本</th></tr></thead><tbody><tr><td align="left">timeout</td><td align="left">number</td><td align="left"></td><td align="left">否</td><td align="left">超时时间，单位ms</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.9.90</a></td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td><td align="left"></td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td><td align="left"></td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td><td align="left"></td></tr></tbody></table><p>object.success 回调函数</p><p>参数</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">code</td><td align="left">string</td><td align="left">用户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/code2Session.html">code2Session</a>，使用 code 换取 openid 和 session_key 等信息</td></tr></tbody></table><p><strong>code2Session</strong></p><p>本接口应在服务器端调用，详细说明参见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/backend-api.html">服务端API</a>。</p><p>登录凭证校验。通过<a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.login.html">wx.login()</a>接口获得临时登录凭证 code 后传到开发者服务器调用此接口完成登录流程。更多使用方法详见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">小程序登录</a>。</p><p>请求地址</p><p>GET <a href="https://api.weixin.qq.com/sns/jscode2sessionappid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code">https://api.weixin.qq.com/sns/jscode2sessionappid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code</a></p><p>请求参数</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">appid</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">小程序 appId</td></tr><tr><td align="left">secret</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">小程序 appSecret</td></tr><tr><td align="left">js_code</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">登录时获取的 code</td></tr><tr><td align="left">grant_type</td><td align="left">string</td><td align="left"></td><td align="left">是</td><td align="left">授权类型，此处只需填写 authorization_code</td></tr></tbody></table><p>返回值</p><p>Object</p><p>返回的 JSON 数据包</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">openid</td><td align="left">string</td><td align="left">用户唯一标识</td></tr><tr><td align="left">session_key</td><td align="left">string</td><td align="left">会话密钥</td></tr><tr><td align="left">unionid</td><td align="left">string</td><td align="left">用户在开放平台的唯一标识符，在满足 UnionID 下发条件的情况下会返回，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html">UnionID 机制说明</a>。</td></tr><tr><td align="left">errcode</td><td align="left">number</td><td align="left">错误码</td></tr><tr><td align="left">errmsg</td><td align="left">string</td><td align="left">错误信息</td></tr></tbody></table><p>errcode 的合法值</p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-1</td><td align="left">系统繁忙，此时请开发者稍候再试</td></tr><tr><td align="left">0</td><td align="left">请求成功</td></tr><tr><td align="left">40029</td><td align="left">code 无效</td></tr><tr><td align="left">45011</td><td align="left">频率限制，每个用户每分钟100次</td></tr></tbody></table><p><strong>二.信息授权wx.getUserInfo</strong></p><p>获取用户信息。</p><p>参数</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">withCredentials</td><td align="left">boolean</td><td align="left"></td><td align="left">否</td><td align="left">是否带上登录态信息。当 withCredentials 为 true 时，要求此前有调用过 wx.login 且登录态尚未过期，此时返回的数据会包含 encryptedData, iv 等敏感信息；当 withCredentials 为 false 时，不要求有登录态，返回的数据不包含 encryptedData, iv 等敏感信息。</td></tr><tr><td align="left">lang</td><td align="left">string</td><td align="left">en</td><td align="left">否</td><td align="left">显示用户信息的语言</td></tr><tr><td align="left">success</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">function</td><td align="left"></td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p>object.lang 的合法值</p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">en</td><td align="left">英文</td></tr><tr><td align="left">zh_CN</td><td align="left">简体中文</td></tr><tr><td align="left">zh_TW</td><td align="left">繁体中文</td></tr></tbody></table><p>object.success 回调函数</p><p>参数</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">userInfo</td><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/api/UserInfo.html">UserInfo</a></td><td align="left">用户信息对象，不包含 openid 等敏感信息</td></tr><tr><td align="left">rawData</td><td align="left">string</td><td align="left">不包括敏感信息的原始数据字符串，用于计算签名</td></tr><tr><td align="left">signature</td><td align="left">string</td><td align="left">使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html">用户数据的签名验证和加解密</a></td></tr><tr><td align="left">encryptedData</td><td align="left">string</td><td align="left">包括敏感数据在内的完整用户信息的加密数据，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95">用户数据的签名验证和加解密</a></td></tr><tr><td align="left">iv</td><td align="left">string</td><td align="left">加密算法的初始向量，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95">用户数据的签名验证和加解密</a></td></tr></tbody></table><p>注意:</p><p>1.小程序端获取授权信息要用button按钮触发</p><p>2.小程序端需要将 encryptedData, iv, login_key 传到后端用于解密</p><p><strong>案例:</strong></p><p>登录:</p><p>当小程序第一次执行的时候就调用wx.login</p><p>小程序端:apps.js</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function-variable function">onLaunch</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">var</span> _this<span class="token operator">=</span><span class="token keyword">this</span> <span class="token comment">// 登录</span> wx<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token comment">// 发送 res.code 到后台换取 openId, sessionKey, unionId</span>  wx<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{</span>   url<span class="token operator">:</span> _this<span class="token punctuation">.</span>globalData<span class="token punctuation">.</span>Url<span class="token operator">+</span><span class="token string">'/login/'</span><span class="token punctuation">,</span> <span class="token comment">// 后端路径</span>   data<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"code"</span><span class="token operator">:</span>res<span class="token punctuation">.</span>code<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// code</span>   header<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"content-type"</span><span class="token operator">:</span><span class="token string">"application/json"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>   method<span class="token operator">:</span><span class="token string">"POST"</span><span class="token punctuation">,</span>   <span class="token function-variable function">success</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>   <span class="token comment">// 小程序端存储login_key</span>   wx<span class="token punctuation">.</span><span class="token function">setStorageSync</span><span class="token punctuation">(</span><span class="token string">"login_key"</span><span class="token punctuation">,</span>res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data<span class="token punctuation">.</span>login_key<span class="token punctuation">)</span>   <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> globalData<span class="token operator">:</span> <span class="token punctuation">{</span> Url<span class="token operator">:</span><span class="token string">"http://127.0.0.1:8000"</span><span class="token punctuation">,</span> userInfo<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>后端 django</p><pre class="language-none"><code class="language-none">wx ├── settings.py  # 小程序id,code2Session等配置 ├── wx_login.py  # 用于调用code2Session拿到openid等 └── WXBizDataCrypt.py # 获取用户授权信息的解密算法,官方下载</code></pre><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95">微信官方解密算法代码</a></p><p>项目/settings.py</p><pre class="language-python" data-language="python"><code class="language-python"># 配置数据库DATABASES = { 'default': {  'ENGINE': 'django.db.backends.mysql',  'NAME': 'wx',  'USER':'root',  'PASSWORD':'root',  'HOST':'127.0.0.1',  'PORT': 3306,  'OPTIONS': {'charset': 'utf8mb4'}, # 微信用户名可能有标签,所以用utf8mb4 }}# 配置 django-redisCACHES = { 'default': {  'BACKEND': 'django_redis.cache.RedisCache',  'LOCATION': 'redis://127.0.0.1:6379',  "OPTIONS": {   "CLIENT_CLASS": "django_redis.client.DefaultClient",    "PASSWORD": "",  }, },}</code></pre><p>wx/settings.py</p><pre class="language-python" data-language="python"><code class="language-python"># 小程序开发者idAppId="..."# 小程序的AppSecretAppSecret="..."code2Session="https://api.weixin.qq.com/sns/jscode2session?appid={}&amp;secret={}&amp;js_code={}&amp;grant_type=authorization_code"pay_mchid ='...'pay_apikey = '...'</code></pre><p>wx/wx_login.py</p><pre class="language-python" data-language="python"><code class="language-python">from app01.wx import settingsimport requests# 调用微信code2Session接口,换取用户唯一标识 OpenID 和 会话密钥 session_keydef login(code): response = requests.get(settings.code2Session.format(settings.AppId,settings.AppSecret,code)) data = response.json() if data.get("openid"):  return data else:  return False</code></pre><p>项目/views.py</p><pre class="language-python" data-language="python"><code class="language-python">from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom app01.wx import wx_loginfrom django.core.cache import cachefrom app01 import modelsimport time, hashlibclass Login(APIView): def post(self, request):  param = request.data  # 拿到小程序端提交的code  if param.get('code'):   # 调用微信code2Session接口,换取用户唯一标识 OpenID 和 会话密钥 session_key   data = wx_login.login(param.get('code'))   if data:    # 将openid 和 session_key拼接    val = data['openid'] + "&amp;" + data["session_key"]    key = data["openid"] + str(int(time.time()))    # 将 openid 加密    md5 = hashlib.md5()    md5.update(key.encode("utf-8"))    key = md5.hexdigest()    # 保存到redis内存库,因为小程序端后续需要认证的操作会需要频繁校验    cache.set(key, val)    has_user = models.Wxuser.objects.filter(openid=data['openid']).first()    # 用户不存在则创建用户    if not has_user:     models.Wxuser.objects.create(openid=data['openid'])    return Response({     "code": 200,     "msg": "ok",     "data": {"login_key": key} # 返回给小程序端    })   else:    return Response({"code": 401, "msg": "code无效"})  else:   return Response({"code": 401, "msg": "缺少参数"})</code></pre><p><strong>用户信息授权</strong></p><p>小程序端test.wxml</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--用户信息授权--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">open-type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getUserInfo<span class="token punctuation">"</span></span> <span class="token attr-name">bindgetuserinfo</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>授权登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span></code></pre><p>test.js</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">Page</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token function-variable function">info</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// console.log(res)</span> wx<span class="token punctuation">.</span><span class="token function">checkSession</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//session_key 未过期，并且在本生命周期一直有效</span>  wx<span class="token punctuation">.</span><span class="token function">getUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>   <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// console.log(res)</span>   wx<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    url<span class="token operator">:</span> app<span class="token punctuation">.</span>globalData<span class="token punctuation">.</span>Url <span class="token operator">+</span> <span class="token string">"/getinfo/"</span><span class="token punctuation">,</span>    data<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string">"encryptedData"</span><span class="token operator">:</span> res<span class="token punctuation">.</span>encryptedData<span class="token punctuation">,</span> <span class="token string">"iv"</span><span class="token operator">:</span> res<span class="token punctuation">.</span>iv<span class="token punctuation">,</span> <span class="token string">"login_key"</span><span class="token operator">:</span> wx<span class="token punctuation">.</span><span class="token function">getStorageSync</span><span class="token punctuation">(</span><span class="token string">"login_key"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    method<span class="token operator">:</span> <span class="token string">"POST"</span><span class="token punctuation">,</span>    header<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token string">"content-type"</span><span class="token operator">:</span> <span class="token string">"application/json"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>后端 django</p><p>wx/WXBizDataCrypt.py</p><pre class="language-python" data-language="python"><code class="language-python">import base64import jsonfrom Crypto.Cipher import AESfrom app01.wx import settingsclass WXBizDataCrypt: def __init__(self, appId, sessionKey):  self.appId = appId  self.sessionKey = sessionKey def decrypt(self, encryptedData, iv):  # base64 decode  sessionKey = base64.b64decode(self.sessionKey)  encryptedData = base64.b64decode(encryptedData)  iv = base64.b64decode(iv)  cipher = AES.new(sessionKey, AES.MODE_CBC, iv)  decrypted = json.loads(self._unpad(cipher.decrypt(encryptedData)))  if decrypted['watermark']['appid'] != self.appId:   raise Exception('Invalid Buffer')  return decrypted def _unpad(self, s):  return s[:-ord(s[len(s)-1:])] @classmethod def getInfo(cls,encryptedData,iv,session_key):  return cls(settings.AppId,session_key).decrypt(encryptedData, iv)</code></pre><p>项目/serializer.py</p><pre class="language-python" data-language="python"><code class="language-python">from rest_framework.serializers import ModelSerializerfrom app01 import modelsclass User_ser(ModelSerializer): class Meta:  model=models.Wxuser  fields="__all__"</code></pre><p>项目/views.py</p><pre class="language-python" data-language="python"><code class="language-python">from app01.wx import WXBizDataCryptfrom app01 import serializerfrom app01 import modelsclass GetInfo(APIView): def post(self,request):  param=request.data  # 需要小程序端将 encryptedData iv login_key 的值传到后端  # encryptedData iv seesion_key 用于解密获取用户信息  # login_key 用于校验用户登录状态  if param['encryptedData'] and param['iv'] and param['login_key']:   # 从redis中拿到login_key并切分拿到 openid 和 session_key   openid,seesion_key=cache.get(param['login_key']).split("&amp;")   # 利用微信官方提供算法拿到用户的开放数据   data=WXBizDataCrypt.WXBizDataCrypt.getInfo(param['encryptedData'] ,param['iv'] ,seesion_key)   save_data={    "name":data['nickName'],    "avatar":data['avatarUrl'],    "language":data['language'],    "province":data['province'],    "city":data['city'],    "country":data['country'],   }   # 将拿到的用户信息更新到用户表中   models.Wxuser.objects.filter(openid=openid).update(**save_data)   # 反序列化用户对象,并返回到小程序端   data=models.Wxuser.objects.filter(openid=openid).first()   data=serializer.User_ser(instance=data,many=False).data   return Response({"code":200,"msg":"缺少参数","data":data})  else:   return Response({"code":200,"msg":"缺少参数"})</code></pre><p>到此，微信小程序实现后端授权登录就结束了</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uvicorn+Gunicorn部署</title>
      <link href="2021/01/20/uvicorn-he-gunicorn/"/>
      <url>2021/01/20/uvicorn-he-gunicorn/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是wsgi"><a href="#什么是wsgi" class="headerlink" title="什么是wsgi"></a>什么是wsgi</h2><blockquote><p>Wsgi是同步通信服务规范，客户端请求一项服务，并等待服务完成，只有当它收到服务的结果时，它才会继续工作。当然了，可以定义一个超时时间，如果服务在规定的时间内没有完成，则认为调用失败，调用方继续工作。</p></blockquote><img src="/2021/01/20/uvicorn-he-gunicorn/image-20210120124037533.png" alt="" style="zoom:50%;" loading="lazy"><p>wsgi简单工作图</p><h2 id="什么是asgi"><a href="#什么是asgi" class="headerlink" title="什么是asgi"></a>什么是asgi</h2><p>Asgi是异步通信服务规范。客户端发起服务呼叫，但不等待结果。调用方立即继续其工作，并不关心结果。如果调用方对结果感兴趣，有一些机制可以让其随时被回调方法返回结果。</p><img src="/2021/01/20/uvicorn-he-gunicorn/image-20210120124131615.png" alt="" style="zoom:75%;" loading="lazy"><p>简单总结一下：Asgi是异步的，Wsgi是同步的，而基于Wsgi的Flask是同步框架，基于Asgi的FastAPI是异步框架，就这么简单。</p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><blockquote><p>普及一下小知识，下面我们进入正题，什么是Uvicorn，Uvicorn 是基于 uvloop 和 httptools 构建的非常快速的 ASGI 服务器。目前，Python 仍缺乏异步网关协议接口，ASGI 的出现填补了这一空白，现在开始，我们能够使用共同的标准为所有的异步框架来实现一些工具，ASGI 帮助 Python 在 Web 框架上和 Node.Js 及 Golang 相竞争，目标是获得高性能的 IO 密集型任务，ASGI 支持 HTTP2 和 WebSockets，WSGI 是不支持的。</p></blockquote><h4 id="进程管理器"><a href="#进程管理器" class="headerlink" title="进程管理器"></a>进程管理器</h4><blockquote><p>使用进程管理器确保你以弹性方式运行运行多个进程，你可以执行服务器升级而不会丢弃客户端的请求。</p><p>一个进程管理器将会处理套接字设置，启动多个服务器进程，监控进程活动，监听进程重启、关闭等信号。</p><p>Uvicorn 提供一个轻量级的方法来运行多个工作进程，比如 <code>--workers 4</code>，但并没有提供进行的监控。</p></blockquote><p>Gunicorn 是成熟的，功能齐全的服务器，Uvicorn 内部包含有 Guicorn 的 workers 类，允许你运行 ASGI 应用程序，这些 workers 继承了所有 Uvicorn 高性能的特点，并且给你使用 Guicorn 来进行进程管理。</p><p>这样的话，你可能动态增加或减少进程数量，平滑地重启工作进程，或者升级服务器而无需停机。</p><p>在生产环境中，Guicorn 大概是最简单的方式来管理 Uvicorn 了，生产环境部署我推荐使用 Guicorn 和 Uvicorn</p><h2 id="简单部署fastapi"><a href="#简单部署fastapi" class="headerlink" title="简单部署fastapi"></a>简单部署fastapi</h2><pre class="language-python" data-language="python"><code class="language-python">from fastapi import FastAPIfrom fastapi.responses import RedirectResponseapp = FastAPI()@app.get("/items/")async def update_item(assetid:str):    print(assetid)    assetid = assetid.strip()    url = 'https://god_hearing.gitee.io/myhexo/?assetid=%s'%assetid    print(url)    return RedirectResponse(url=url)if __name__ == '__main__':    import uvicorn    uvicorn.run(        app='transfer:app',        host='0.0.0.0',        port=8000,        workers=5,        debug=False                )</code></pre><p>我们简单的写了一个接口，这里，我是使用了跳转重定向，可以直接return一个response</p><p>然后启动的这里，我们采用的是启动五个进程，并且关闭debug模式，不过我还没有发现这个debug关不关的区别在哪</p><p>这时候，我们直接运行即可。</p><p>但是，这样是阻塞式的，并且在关闭控制台之后就会停止，所以，我们使用gunicorn来解决</p><ol><li><p>安装</p><pre class="language-python" data-language="python"><code class="language-python">pip install gunicorn </code></pre></li><li><p>在项目文件下</p><pre class="language-python" data-language="python"><code class="language-python">gunicorn main:app -b 0.0.0.0:8000  -w 5 -k uvicorn.workers.UvicornH11Worker --daemon</code></pre><p>然后，我们的项目就已经在运行了，然后访问一下你的域名+<code>items/assetid=asfdg</code></p></li></ol><h3 id="关闭gunicron进程"><a href="#关闭gunicron进程" class="headerlink" title="关闭gunicron进程"></a>关闭gunicron进程</h3><pre class="language-python" data-language="python"><code class="language-python"># 查询pstree -ap|grep gunicorn</code></pre><p>结果为：</p><img src="/2021/01/20/uvicorn-he-gunicorn/image-20210120134339197.png" alt="" style="zoom:67%;" loading="lazy"><p>关闭进程</p><pre class="language-python" data-language="python"><code class="language-python">kill -9 15624...</code></pre><p>ok，部署完成，就是这么简单</p>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> FastAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu系统下安装mysql8.0以及Django与mysql交互的问题</title>
      <link href="2021/01/18/ubuntu-xi-tong-xia-an-zhuang-mysql8.0-yi-ji-django-yu-mysql-jiao-hu-de-wen-ti/"/>
      <url>2021/01/18/ubuntu-xi-tong-xia-an-zhuang-mysql8.0-yi-ji-django-yu-mysql-jiao-hu-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="Django-运行时出错总结"><a href="#Django-运行时出错总结" class="headerlink" title="Django 运行时出错总结"></a>Django 运行时出错总结</h2><h4 id="一、利用mysql作为数据库时，会报的错："><a href="#一、利用mysql作为数据库时，会报的错：" class="headerlink" title="一、利用mysql作为数据库时，会报的错："></a>一、利用mysql作为数据库时，会报的错：</h4><pre class="language-none"><code class="language-none">#macospip install Django             #version==3.1pip install PyMySQL        #Pure Python MySQL Driver version==0.10.0brew install mysqlpip install mysqlclient  # version==2.0.1</code></pre><p>直接运行会报错:</p><pre class="language-none"><code class="language-none">version_info, _mysql.version_info, _mysql.__file__ NameError: name '_mysql' is not defined</code></pre><p>原因：Django连接MySQL时默认使用MySQLdb驱动，但MySQLdb不支持Python3，因此这里将MySQL驱动设置为pymysql</p><p>解决方法：需要在Django项目的<code>__init__.py</code>文件添加以下</p><pre class="language-none"><code class="language-none">import pymysqlpymysql.install_as_MySQLdb()</code></pre><p>此时，仍会报错：</p><pre class="language-none"><code class="language-none">'mysqlclient 1.4.0 or newer is required; you have 0.10.0.'</code></pre><p>是因为将MySQL驱动设置为pymysql，MySQLdb的版本为0.10.0，所以不够，但实际上不影响使用。因此将报错的位置注释掉就可以了。</p><p>出错文件在：<code>/Users/xinzipanghuang/Anaconda/anaconda3/lib/python3.7/site-packages/django/db/backends/mysql/base.py</code></p><p>注释掉这几句:</p><pre class="language-none"><code class="language-none">if version &lt; (1, 4, 0):  raise ImproperlyConfigured('mysqlclient 1.4.0 or newer is required; you have %s.' % Database.__version__)</code></pre><p>即可。</p><h4 id="二、运行时可能出现的问题"><a href="#二、运行时可能出现的问题" class="headerlink" title="二、运行时可能出现的问题"></a>二、运行时可能出现的问题</h4><p>1、<code>python manage.py runserver</code>，打开时产生的链接会报错：</p><pre class="language-none"><code class="language-none">You're accessing the development server over HTTPS, but it only supports HTTP.</code></pre><p>浏览器会出现：<code>This site can’t provide a secure connection</code></p><p>解决方法：<br><code>setting.py</code>中<code>INSTALLED_APPS</code>添加<code>'sslserver'</code>;<br>运行命令改为:<code>python manage.py runsslserver</code></p><p>2、pycharm可以新建一个Django项目，做个小APP改动几个地方就可以。</p><p>新建<code>views.py</code>在app目录下，定义返回函数（html内容）<br>同时在<code>templates</code>目录下，添加返回的html。<br>修改<code>urls.py</code>中<code>urlpatterns</code>,添加刚加入的<code>views.py</code>函数</p><p>3、css和js路径设置问题</p><p>Django静态style文件会放在<code>static</code>文件夹下，需要在<code>setting.py</code>中添加：</p><pre class="language-none"><code class="language-none">STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static/')]</code></pre><p>html文件也需要相对应改为<code>/static/***.css</code></p><h2 id="ubuntu升级mysql"><a href="#ubuntu升级mysql" class="headerlink" title="ubuntu升级mysql"></a>ubuntu升级mysql</h2><h3 id="1-升级前的检查准备"><a href="#1-升级前的检查准备" class="headerlink" title="1 升级前的检查准备"></a>1 升级前的检查准备</h3><p>在终端运行命令：</p><pre class="language-none"><code class="language-none">mysqlcheck -u root -p --all-databases --check-upgrade</code></pre><p>返回结果如果全部都是OK, 就表示检查没问题，进入下一步。如果有错误，看这里：<a href="https://dev.mysql.com/doc/refman/8.0/en/upgrade-prerequisites.html">https://dev.mysql.com/doc/refman/8.0/en/upgrade-prerequisites.html</a></p><h3 id="2-备份"><a href="#2-备份" class="headerlink" title="2 备份"></a>2 备份</h3><p><strong>备份数据库</strong><br>之前都没有使用过备份数据库，参考的这个命令：</p><pre class="language-none"><code class="language-none">mkdir mysql-backupcd mysql-backupmysqldump --all-databases --single-transaction --quick --lock-tables=false &gt; full-backup-$(date +%F).sql -u root -p</code></pre><p>该命令各个参数解释：</p><p>–all-databases ： 表示导出全部数据库</p><p>–single-transaction ： 这个不太懂，网上的解释也没看明白，需要补充补充数据库基础了。。</p><p>–quick ： 导出时不会将数据加载到缓存，而是直接输出。默认就是启用状态。可以使用–skip-quick 取消该选项。</p><p>–lock-tables：开始导出前，锁定所有表。当导出多个数据库时，–lock-tables分别为每个数据库锁定表。</p><p>$(date+%F)表示获取当前时间，在Linux Shell中：</p><pre class="language-none"><code class="language-none">date       //获取时间2019年 08月 08日 星期四 11:40:20 CSTdate +%F   //获取日期2019-08-08date +%s   //获取时间戳1565235736</code></pre><p>–user, –u指定连接的用户名</p><p>–password, –p连接数据库密码</p><p><strong>备份MySQL设置</strong></p><pre class="language-none"><code class="language-none">cd mysql-backupsudo tar zcvf mysql_config.tar.gz /etc/mysql/</code></pre><h3 id="3-添加MySQL-APT"><a href="#3-添加MySQL-APT" class="headerlink" title="3 添加MySQL APT"></a>3 添加MySQL APT</h3><p>下载mysql-apt-config_0.8.13-1_all.deb：<a href="https://dev.mysql.com/downloads/repo/apt/">https://dev.mysql.com/downloads/repo/apt/</a></p><p>安装：</p><pre class="language-none"><code class="language-none">sudo dpkg -i mysql-apt-config_0.8.13-1_all.debsudo apt-get update</code></pre><h3 id="4-安装新版的MySQL"><a href="#4-安装新版的MySQL" class="headerlink" title="4 安装新版的MySQL"></a>4 安装新版的MySQL</h3><pre class="language-none"><code class="language-none">service mysql stop  # 先停了MySQL servicesudo apt-get install mysql-serversudo service mysql start  # 开启MySQL service</code></pre><p>最后检查下升级后的版本：</p><pre class="language-none"><code class="language-none">mysql -V</code></pre><p>显示：</p><pre class="language-none"><code class="language-none">mysql  Ver 8.0.17 for Linux on x86_64 (MySQL Community Server - GPL)</code></pre><p>已经升级成功。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue生成图片并下载</title>
      <link href="2021/01/17/vue-sheng-cheng-tu-pian-bing-xia-zai/"/>
      <url>2021/01/17/vue-sheng-cheng-tu-pian-bing-xia-zai/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近，碰到了一个很尴尬的需求，在我使用python苦苦支撑却实现不了的时候，vue就像一道光，哗啦啦的就来了，这个需求就是合成一张图片，然后把这张图片下载下来，而python我又不会使用opencv等库，所以，只能使用PIL强行搞，但是效果并不好。然后，我求助了我的小伙伴，她很轻易的就帮助我搞定了，(太感谢我的小伙伴了。)，但是下载这个图片，成了一个事。所以，今天这篇攻略带来如何生成图片并且下载</p></blockquote><h2 id="html2canvas"><a href="#html2canvas" class="headerlink" title="html2canvas"></a>html2canvas</h2><blockquote><p>这就是我们要使用到的库，我们通过npm或者yarn来进行下载</p></blockquote><ol><li>安装</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript">npm install <span class="token operator">--</span>save html2canvas</code></pre><p>或者：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">yarn add html2canvas</code></pre><ol start="2"><li>将html2canvas引入到组件中</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> html2canvas <span class="token keyword">from</span> <span class="token string">"html2canvas"</span></code></pre><ol start="3"><li>将你想生成的区域转成图片，你需要让html2canvas获取到你想要转换的节点内容，因此，你需要添加ref标记。</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"container"</span> ref<span class="token operator">=</span><span class="token string">"imageDom"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></code></pre><blockquote><p>imageDom需要是你想转换的页面内容的父容器，即你想转换的页面内容需要全部包含在imageDom节点内。</p></blockquote><ol start="4"><li>转换</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">clickGeneratePicture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token function">html2canvas</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>imageDom<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">canvas</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token comment">// 转成图片，生成图片地址</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>imgUrl <span class="token operator">=</span> canvas<span class="token punctuation">.</span><span class="token function">toDataURL</span><span class="token punctuation">(</span><span class="token string">"image/png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>imgUrl<span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><blockquote><p>返回的canvas参数就是一个生成好的canvas元素，如果你想将他转成图片，直接使用toDataURL方法即可，将转换的图片地址赋值给你想显示的图片元素，就可以在页面上看到转换后的图片。</p></blockquote><ol start="5"><li>直接触发方法， 将图片下载下来</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">clickGeneratePicture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">html2canvas</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>imageDom<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">canvas</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>        <span class="token comment">// 转成图片，生成图片地址</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>imgUrl <span class="token operator">=</span> canvas<span class="token punctuation">.</span><span class="token function">toDataURL</span><span class="token punctuation">(</span><span class="token string">"image/png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建隐藏的可下载链接</span>        <span class="token keyword">var</span> eleLink <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        eleLink<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>imgUrl<span class="token punctuation">;</span> <span class="token comment">// 转换后的图片地址</span>        eleLink<span class="token punctuation">.</span>download <span class="token operator">=</span> <span class="token string">"pictureName"</span><span class="token punctuation">;</span>        <span class="token comment">// 触发点击</span>        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>eleLink<span class="token punctuation">)</span><span class="token punctuation">;</span>        eleLink<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 然后移除</span>        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>eleLink<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>随便做个点击事件就好了，不过图片如果展示的过大的话，就会只下载显示的部分，还未解决，待补</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastAPI学习之路-3  模型与校验</title>
      <link href="2021/01/15/fastapi-xue-xi-zhi-lu-3-mo-xing-yu-xiao-yan/"/>
      <url>2021/01/15/fastapi-xue-xi-zhi-lu-3-mo-xing-yu-xiao-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="预设值"><a href="#预设值" class="headerlink" title="预设值"></a>预设值</h2><blockquote><p>如果你有一个接收路径参数的路径操作，但你希望预先设定可能的有效参数值，则可以使用标准的 Python <code>Enum</code> 类型。</p><p>就类似于choise枚举，举个栗子，你现在可能要接收一个性别</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from enum import Enumclass ModelName(str, Enum):    nan = "男"    nv = "女"    lenet = "未知"@app.post("/Yawp/")async def transfer(model_name: ModelName):    return {'msg':model_name}</code></pre><p>这样，我们需要传的model_name，只剩下这三个选项</p><p>同时，他也可以声明路径参数</p><blockquote><p>补充关于参数的一点，如果你想要让这个参数是一个必填的参数，只需要将其不设置默认值即可，例如：</p><p><code>async def read_user_item(item_id: str, needy: str=None):</code></p><p>像这种情况，item_id，就是必须填进的一个参数了，而needy有默认值，None，所以，他并不是一个必填的参数</p></blockquote><p>另外一个小技巧，在fastapi交互式文档上操作，可以最大限度的避免一些基础错误，所以，要养成使用交互式文档的习惯哦</p><h2 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h2><blockquote><p>请求体就不用过多介绍了，这是基础中的基础了，如果不懂请自行百度</p><p>我们需要先导入BaseModel，来创建数据模型</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from pydantic import BaseModelclass Item(BaseModel):    name:str    description: Optional[str] = None    price:float    tax:Optional[float] = Noneasync def main(item:Item):    print(item.dict())    print(item.name)    return </code></pre><p>和声明查询参数时一样，当一个模型属性具有默认值时，它不是必需的。否则它是一个必需属性。将默认值设为 <code>None</code> 可使其成为可选属性。</p><p>我们可以在函数内通过某个字段来进行查看，或者直接dict，获取所有数据</p><p>值得说的一点是，请求体传值并不影响url传参，也就是说，我们依旧可以使用路径参数</p><p>函数参数将依次按如下规则进行识别：</p><ul><li>如果在<strong>路径</strong>中也声明了该参数，它将被用作路径参数。</li><li>如果参数属于<strong>单一类型</strong>（比如 <code>int</code>、<code>float</code>、<code>str</code>、<code>bool</code> 等）它将被解释为<strong>查询</strong>参数。</li><li>如果参数的类型被声明为一个 <strong>Pydantic 模型</strong>，它将被解释为<strong>请求体</strong>。</li></ul><p>如果你不想使用 Pydantic 模型，你还可以使用 <strong>Body</strong> 参数。稍后介绍</p><h2 id="约束校验"><a href="#约束校验" class="headerlink" title="约束校验"></a>约束校验</h2><p>Query(查询参数)<br>Query第一个参数用来定义默认值</p><blockquote><p>可用于限制长度或者正则表达式</p></blockquote><blockquote><p>#q参数必须为字符串，默认值为None，如果为…,则这个参数必须给值，最小长度3，最大长度50<br><code>async def reds(q:str = Query(None,min_length=3,max_length=50)</code></p><p><code>async def read_items(q: Optional[List[str]] = Query(None)):</code>这种情况，是可以接收多个q参数的，?q=foo&amp;q=bar</p></blockquote><h2 id="声明必须参数"><a href="#声明必须参数" class="headerlink" title="声明必须参数"></a>声明必须参数</h2><blockquote><p>之前说过，我们声明必须传的参数，只需要将其不设默认即可，现在可以有第二种方法，就是<code>...</code>，</p><p>将其默认值设置为<code>...</code>时，他就是一个必须传入的参数了</p></blockquote><h2 id="请求体字段验证"><a href="#请求体字段验证" class="headerlink" title="请求体字段验证"></a>请求体字段验证</h2><p>与使用 <code>Query</code>、<code>Path</code> 和 <code>Body</code> 在<em>路径操作函数</em>中声明额外的校验和元数据的方式相同，你可以使用 Pydantic 的 <code>Field</code> 在 Pydantic 模型内部声明校验和元数据。像这样</p><pre class="language-python" data-language="python"><code class="language-python">class Item(BaseModel):    name:str    description: Optional[str] = Field(None, title="The description of the item", max_length=300)    price:float    tax:Optional[float] = None</code></pre><h2 id="模型嵌套"><a href="#模型嵌套" class="headerlink" title="模型嵌套"></a>模型嵌套</h2><blockquote><p>在我们声明模型的时候，他的值不只是单一的字符串，数字等， 像一些列表，集合也同样可以定义，像这样</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">class Item(BaseModel):    name: str    description: Optional[str] = None    price: float    tax: Optional[float] = None    tags: list = []</code></pre><p>这将使 <code>tags</code> 成为一个由元素组成的列表。不过它没有声明每个元素的类型。</p><p>但是 Python 有一种特定的方法来声明具有子类型的列表。</p><p>我们需要从<code>typing</code>导入<code>List</code>，将模型内部改为<code>tags: List[str] = []</code></p><p>Pydantic 模型的每个属性都具有类型。</p><p>但是这个类型本身可以是另一个 Pydantic 模型。</p><p>因此，你可以声明拥有特定属性名称、类型和校验的深度嵌套的 JSON 对象。</p><p>上述这些都可以任意的嵌套。</p><blockquote><p>最后，有一点很重要，我们如果希望传一种像这样的数据:<code>[{a:1},{a:2}]</code>，则可以在路径操作函数的参数中声明此类型，就像声明 Pydantic 模型一样：<code>images: List[Image]</code></p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from pydantic import BaseModel,Field,HttpUrlclass img(BaseModel):    url:HttpUrl    name:str@app.post("/Yawp/")async def transfer(*,a:List[img]):    for i in a:        print(i.name)        print(i.url)    # for i in a:    #     print(i)    return {'msg':a}</code></pre>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序授权登录</title>
      <link href="2021/01/15/wei-xin-xiao-cheng-xu-shou-quan-deng-lu/"/>
      <url>2021/01/15/wei-xin-xiao-cheng-xu-shou-quan-deng-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在开发小程序的过程中， 用户的认证是必不可少的，而微信又取消了小程序的自己认证，所以，我们只能通过微信进行授权登录，而如果将微信授权的信息录入到自己的表中，则需要做一点点的开发，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/">官方文档</a></p></blockquote><p>微信小程序的后端开发和普通的restful API 大致上相同，只不过要注意以下几点限制</p><ul><li>必须使用HTTPS协议请求后端服务器</li><li>不支持COOKIE</li><li>不支持django内置的user登录, 因为它使用的是微信的用户系统</li></ul><h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><img src="/2021/01/15/wei-xin-xiao-cheng-xu-shou-quan-deng-lu/image-20210115133429492.png" alt="" style="zoom:70%;" loading="lazy"><blockquote><p>只获取<code>openid</code>，只调用<code>wx.login</code>获取code交给后台即可，如果还要获取用户详细信息还要接着调用<code>wx.getUserInfo</code>获取<code>encryptedData</code>，<code>iv</code>提交后台解密用户信息</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">@api_view(['GET','POST'])def wx_login(request):    openidUrl = 'https://api.weixin.qq.com/sns/jscode2session?'    code = request.GET['code']    res = requests.get(        url = openidUrl,        params = {            'appid':APPID,            'secret':APP_SECRET,            'js_code':code,            'grant_type':'authorization_code'        }    ).json()    openid = res['openid']    return Response(openid</code></pre><p>这样，我们便获取到了openid，然后返回给前端即可</p><p>如果要换取用户信息，则需要前端再次请求我们服务器，需要传入<code>encryptedData  iv</code>和<code>session_key</code>来获取用户的信息，</p><p><code>encryptedData</code>就是获取到的用户信息，只是得解密一下，通过iv</p><pre class="language-python" data-language="python"><code class="language-python">#  解密类class WXBizDataCrypt:    def __init__(self, appId, sessionKey):        self.appId = appId        self.sessionKey = sessionKey    def decrypt(self, encryptedData, iv):        # base64 decode        sessionKey = base64.b64decode(self.sessionKey)        encryptedData = base64.b64decode(encryptedData)        iv = base64.b64decode(iv)        cipher = AES.new(sessionKey, AES.MODE_CBC, iv)        decrypted = json.loads(self._unpad(cipher.decrypt(encryptedData)))        if decrypted['watermark']['appid'] != self.appId:            raise Exception('Invalid Buffer')        return decrypted    def _unpad(self, s):        return s[:-ord(s[len(s)-1:])]</code></pre><pre class="language-python" data-language="python"><code class="language-python">def main():    appId = '你的appid'    sessionKey = '获取到的sessionkey'    encryptedData = '获取openid那里的数据'    iv = '获取openid那里的数据'    pc = WXBizDataCrypt(appId, sessionKey)    res = pc.decrypt(encryptedData, iv)    print(res)</code></pre><p>res就是解密出来的内容，就是用户的信息</p><img src="/2021/01/15/wei-xin-xiao-cheng-xu-shou-quan-deng-lu/image-20210116220241505.png" alt="" style="zoom:67%;" loading="lazy"><p>至此，前台将openid存下，而后台，获取了用户信息，该入库还是该做怎样的操作，就可以自定义了，我是将其入库了，完整代码如下：</p><pre class="language-python" data-language="python"><code class="language-python">class Applets_RegisterView(APIView):    def post(self,request):        session_key = request.data.get('session_key')        encryptedData = request.data.get("encryptedData")        iv = request.data.get("iv")        pc = WXBizDataCrypt(APPID, session_key)        data = pc.decrypt(encryptedData, iv)        username = data['nickName']        avatar = data['avatarUrl']        gender = data['gender']        user_data = {            'username':username,            'avatar':avatar,            'gender':gender,        }        with transaction.atomic():            try:                userobj = RegisterSerializer(data=user_data)                if userobj.is_valid() and secretobj.is_valid():                    userobj.save()                    return Response({'code': 1000, 'msg': '注册成功'})                else:                    return Response({'code':1004,'msg':'网络错误，请稍后再试'})            except Exception as exc:                print(exc)                return Response({'code': 1004, 'msg': '网络错误，请稍后再试'})</code></pre><blockquote><p>被一个小小的登录绊倒，我也是没想到的，感谢有位大神孜孜不倦的一直给我讲解。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python获取微信公众号历史文章</title>
      <link href="2021/01/14/python-huo-qu-wei-xin-gong-zhong-hao-li-shi-wen-zhang/"/>
      <url>2021/01/14/python-huo-qu-wei-xin-gong-zhong-hao-li-shi-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们经常能够在微信公众号上看到各种的文章，而如果我们需要保存到自己本地，难道还需要一个个去复制粘贴吗，答案，根本不需要，只需要一个小小的调用接口，即可将文章悉数拿到，也算一个小爬虫吧</p></blockquote><h2 id="获取assetoken"><a href="#获取assetoken" class="headerlink" title="获取assetoken"></a>获取assetoken</h2><blockquote><p>我们通过微信的<a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html">开发者平台</a>，可以看到，我们只需要调用一个接口，即可获取assettoken</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">def access_token():    appid = 'APPID'    secret = 'SECRET'    url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%s&amp;secret=%s'%(appid,secret)    res = requests.get(url=url)    res = json.loads(res.text)    return res['access_token']</code></pre><blockquote><p>appid和secret就不用细说了，获取这个是很简单的一件事，不仅仅是获取这个文章，调用任何微信公众号的接口，都需要先获取了这个asset_token</p></blockquote><h2 id="获取素材"><a href="#获取素材" class="headerlink" title="获取素材"></a>获取素材</h2><p>获取素材就非常的让我暴躁了，因为他的编码格式问题，让我头疼了好久，我们先来看一下这个官方的<a href="https://developers.weixin.qq.com/doc/offiaccount/Asset_Management/Get_materials_list.html">文档</a>,</p><p>需要三个参数，type，offset，count，我们要获取的是图文，所以，type使用news，offset和count就是从哪一个开始返回和返回的个数，不过需要注意的是，返回的个数最大值是20</p><pre class="language-python" data-language="python"><code class="language-python">token = access_token()    url = 'https://api.weixin.qq.com/cgi-bin/material/batchget_material?access_token=%s'%(token)    data = {    "type":'news',    "offset":1,    "count":1    }    data = json.dumps(data)    res = requests.post(url=url,data=data)    r = res.text.encode('ISO-8859-1').decode('utf8')    r = json.loads(r)</code></pre><blockquote><p>这里，我们接入他的接口，但是返回的是<code>ISO-8859-1</code>编码，所以我们需要进行解码</p><p>如何查看返回的编码，有一个小技巧，就是打印一下<code>res.encoding</code> 即可</p><p>由于这个编码的特殊性，我们需要先对其进行编码，在进行解码</p></blockquote><p>我们再根据他的数据格式，存入到我们的数据库</p><img src="/2021/01/14/python-huo-qu-wei-xin-gong-zhong-hao-li-shi-wen-zhang/image-20210114151117113.png" alt="" style="zoom:50%;" loading="lazy"><p>完善代码</p><pre class="language-python" data-language="python"><code class="language-python">def obtain_article():    token = access_token()    url = 'https://api.weixin.qq.com/cgi-bin/material/batchget_material?access_token=%s'%(token)    data = {    "type":'news',    "offset":1,    "count":1    }    data = json.dumps(data)    res = requests.post(url=url,data=data)    r = res.text.encode('ISO-8859-1').decode('utf8')    r = json.loads(r)    conn = pymysql.connect(host='127.0.0.1',port=3306,user='root',password='mySQL',database='blue_lake_user',charset='utf8')    cursor = conn.cursor()    for i in range(len(r['item'])):        title = r['item'][i]['content']['news_item'][0]['title']        link = r['item'][i]['content']['news_item'][0]['url']        img_url = r['item'][i]['content']['news_item'][0]['thumb_url']        create_time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time()))        sql = "insert into article(title,img,link,create_time,status) values(%s,%s,%s,%s,'1')" % (conn.escape(title),conn.escape(img_url),conn.escape(link),conn.escape(create_time),)        cursor.execute(sql)        conn.commit()        conn.close()</code></pre><p>由于之前说过，数据过长的话，会导致错误，所以，我们采用了<code>escape</code>来进行处理</p><p>一个编码整半天，哎，心累</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提问的智慧(下)</title>
      <link href="2021/01/13/ti-wen-de-zhi-hui-xia/"/>
      <url>2021/01/13/ti-wen-de-zhi-hui-xia/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接上节，较长，请耐心观看</p><h3 id="低声下气不能代替你的功课"><a href="#低声下气不能代替你的功课" class="headerlink" title="低声下气不能代替你的功课"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="描述问题症状而非你的猜测"><a href="#描述问题症状而非你的猜测" class="headerlink" title="描述问题症状而非你的猜测"></a>描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p><h3 id="按发生时间先后列出问题症状"><a href="#按发生时间先后列出问题症状" class="headerlink" title="按发生时间先后列出问题症状"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， 但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id="别要求使用私人电邮回复"><a href="#别要求使用私人电邮回复" class="headerlink" title="别要求使用私人电邮回复"></a>别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p><h3 id="清楚明确的表达你的问题以及需求"><a href="#清楚明确的表达你的问题以及需求" class="headerlink" title="清楚明确的表达你的问题以及需求"></a>清楚明确的表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="询问有关代码的问题时"><a href="#询问有关代码的问题时" class="headerlink" title="询问有关代码的问题时"></a>询问有关代码的问题时</h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 ，但实际出现的是 </code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="别把自己家庭作业的问题贴上来"><a href="#别把自己家庭作业的问题贴上来" class="headerlink" title="别把自己家庭作业的问题贴上来"></a>别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p><h3 id="去掉无意义的提问句"><a href="#去掉无意义的提问句" class="headerlink" title="去掉无意义的提问句"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html">是或否类型的回答</a>。</p><h3 id="即使你很急也不要在标题写紧急"><a href="#即使你很急也不要在标题写紧急" class="headerlink" title="即使你很急也不要在标题写紧急"></a>即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id="礼多人不怪，而且有时还很有帮助"><a href="#礼多人不怪，而且有时还很有帮助" class="headerlink" title="礼多人不怪，而且有时还很有帮助"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h2><h3 id="RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM 和 STFW：如何知道你已完全搞砸了"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **<a href="http://lmgtfy.com/">Google 是你的朋友</a>**！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="如果还是搞不懂"><a href="#如果还是搞不懂" class="headerlink" title="如果还是搞不懂"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="处理无礼的回应"><a href="#处理无礼的回应" class="headerlink" title="处理无礼的回应"></a>处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id="如何避免扮演失败者"><a href="#如何避免扮演失败者" class="headerlink" title="如何避免扮演失败者"></a>如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 —— 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="不该问的问题"><a href="#不该问的问题" class="headerlink" title="不该问的问题"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q1">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q2">我怎样用 X 做 Y？</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q3">如何设定我的 shell 提示？</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q5">我的程序/设定/SQL 语句没有用</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#q9">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p><hr><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="http://www.google.com/">Google</a> 吗？</p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#RTFM">RTFM</a>，然后自己去找出来。</p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p><blockquote><p>问题：我的{程序/设定/SQL 语句}不工作</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我屁事？</li></ul><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到使用者群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id="好问题与蠢问题"><a href="#好问题与蠢问题" class="headerlink" title="好问题与蠢问题"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#RTFM">STFW</a> 这样的回答。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong>聪明问题</strong>：</p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p><h2 id="如何更好地回答问题"><a href="#如何更好地回答问题" class="headerlink" title="如何更好地回答问题"></a>如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章真的给予了我很大的启发，也希望能够帮助到任何观看到这篇文章的人，<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提问的智慧(上)</title>
      <link href="2021/01/13/ti-wen-de-zhi-hui-shang/"/>
      <url>2021/01/13/ti-wen-de-zhi-hui-shang/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p><p>不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><h2 id="在提问之前"><a href="#在提问之前" class="headerlink" title="在提问之前"></a>在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（搜索 <a href="http://groups.google.com/">Google 论坛</a>和网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h2><h3 id="慎选提问的论坛"><a href="#慎选提问的论坛" class="headerlink" title="慎选提问的论坛"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 —— 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p><h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p><p>近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>Stack Exchange 已经成长到<a href="http://stackexchange.com/sites">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id="网站和-IRC-论坛"><a href="#网站和-IRC-论坛" class="headerlink" title="网站和 IRC 论坛"></a>网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id="第二步，使用项目邮件列表"><a href="#第二步，使用项目邮件列表" class="headerlink" title="第二步，使用项目邮件列表"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id="使用有意义且描述明确的标题"><a href="#使用有意义且描述明确的标题" class="headerlink" title="使用有意义且描述明确的标题"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p></blockquote><blockquote><p>聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p></blockquote><blockquote><p>更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id="使问题容易回复"><a href="#使问题容易回复" class="headerlink" title="使问题容易回复"></a>使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id="用清晰、正确、精准且语法正确的语句"><a href="#用清晰、正确、精准且语法正确的语句" class="headerlink" title="用清晰、正确、精准且语法正确的语句"></a>用清晰、正确、精准且语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it's</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox">Alan Cox</a> 也许可以这样做，但你不行）。</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E7%99%BD">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%96%87">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的： [译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法。</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me; I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请寄信/私讯给我；我需要有人协助我翻译我的问题。</li></ul><blockquote><p>I am familiar with the technical terms, but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English. I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li></ul><h3 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id="精确地描述问题并言之有物"><a href="#精确地描述问题并言之有物" class="headerlink" title="精确地描述问题并言之有物"></a>精确地描述问题并言之有物</h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="话不在多而在精"><a href="#话不在多而在精" class="headerlink" title="话不在多而在精"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。 第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加； 第二，简化问题使你更有可能得到<strong>有用</strong>的答案； 第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="别动辄声称找到-Bug"><a href="#别动辄声称找到-Bug" class="headerlink" title="别动辄声称找到 Bug"></a>别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=807854861407358976#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><hr><p>未完待续….</p>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python使用RSA非对称加密</title>
      <link href="2021/01/07/python-shi-yong-rsa-fei-dui-cheng-jia-mi/"/>
      <url>2021/01/07/python-shi-yong-rsa-fei-dui-cheng-jia-mi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。RSA就是他们三人姓氏开头字母拼在一起组成的。<br>RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><p>RSA算法的原理，目前网络上有许多优秀的文章，特别推荐阅读阮一峰老师的文章：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理1</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理2</a></li></ul><p>本文主要描述如何使用RSA来对文件进行不对称加密。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>crypto这个模块的安装比较特殊，可能会有点小坑，安装时需要注意。</p><p>crypto，pycrypto，pycryptodome的功能是一样的。crypto与pycrypto已经没有维护了，后面可以使用pycryptodome。</p><p>但是，三个名字，再分Linux和Windows操作系统，再分Python2和Python3，叠加起来就有12种情况了，非常复杂。</p><p>在 Windows 中，不管是 Python2 和 Python3 ，都不能用 crypto 和 pycrypto ，可以用 pycryptodome 。</p><p>在 Linux 中，不管是 Python2 和 Python3 ，都不能用 crypto ，可以用 pycrypto 和 pycryptodome 。</p><p>所以，总结一句话，直接都用 pycryptodome 就行了，(保证pip正常能用的情况下)安装命令如下：</p><pre class="language-none"><code class="language-none">pip install pycryptodome</code></pre><blockquote><p>安装之前，最好先把 crypto 和 pycrypto 卸载了(uninstall)，避免不必要的麻烦。</p></blockquote><h2 id="生成RSA公钥和私钥"><a href="#生成RSA公钥和私钥" class="headerlink" title="生成RSA公钥和私钥"></a>生成RSA公钥和私钥</h2><pre class="language-python" data-language="python"><code class="language-python">from Crypto import Randomfrom Crypto.PublicKey import RSAdef generate_Key():    random_generator = Random.new().read    rsa = RSA.generate(2048, random_generator)    private_key = rsa.exportKey()    # 写入私钥文件    with open('private_rsa_key.bin', 'wb') as f:        f.write(private_key)    public_key = rsa.publickey().exportKey()    # 写入公钥文件    with open('rsa_public.pem', 'wb') as f:        f.write(public_key)</code></pre><p>上面的代码中，生成了一对公钥和私钥。</p><p>导入了 RSA ，通过 RSA 的 generate() 方法实例化一个对象 rsa 。再通过 rsa 的 exportKey() 方法和 publickey() 方法生成公钥和私钥。</p><p>执行这个函数，可以看到，生成了一对公钥和私钥</p><blockquote><p>当然每次运行的结果都不一定，公钥是公开的，任何人都可以看到，但是私钥一定要保存好，否则一旦泄露，意味着你的信息也不安全了。</p></blockquote><h2 id="进行加密和解密"><a href="#进行加密和解密" class="headerlink" title="进行加密和解密"></a>进行加密和解密</h2><pre class="language-python" data-language="python"><code class="language-python">from Crypto import Randomfrom Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5 as PKCS1_cipherimport base64# 加密def encryption(keys):    with open('rsa_public.pem') as f:        key = f.read()        pub_key = RSA.importKey(str(key))        cipher = PKCS1_cipher.new(pub_key)        rsa_text = base64.b64encode(cipher.encrypt(bytes(keys.encode("utf8"))))        return rsa_text.decode('utf-8')# 解密def decrypt(keys):    with open('private_rsa_key.bin') as f:        key = f.read()        pri_key = RSA.importKey(key)        cipher = PKCS1_cipher.new(pri_key)        back_text = cipher.decrypt(base64.b64decode(keys),0)        return back_text.decode('utf-8')</code></pre><blockquote><p>上面的函数，我们将保存的公钥和私钥读出来，然后进行加密和解密的过程，不过千万要注意的是，私钥不要泄露。</p></blockquote><h2 id="签名和验签"><a href="#签名和验签" class="headerlink" title="签名和验签"></a>签名和验签</h2><blockquote><p>RSA还可以用来签名和验签，正好与加密相反的是，他是使用私钥来签名，公钥来验签</p><p>废话不多说，上代码</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from Crypto.PublicKey import RSAfrom Crypto.Hash import SHAimport base64from Crypto.Signature import PKCS1_v1_5 as PKCS1_signaturemessage = "需要加密的信息"# 使用私钥生成签名with open('private_rsa_key.bin') as f:    key = f.read()    pri_key = RSA.importKey(key)    signer = PKCS1_signature.new(pri_key)    digest = SHA.new()    digest.update(message.encode("utf8"))    sign = signer.sign(digest)    signature = base64.b64encode(sign)    print(signature.decode('utf-8'))# 使用公钥验证签名with open('rsa_public.pem') as f:    key = f.read()    pub_key = RSA.importKey(key)    verifier = PKCS1_signature.new(pub_key)    digest = SHA.new()    digest.update(message.encode("utf8"))    print(verifier.verify(digest, base64.b64decode(signature)))</code></pre><blockquote><p>继续使用之前写入文件中的私钥和公钥，使用私钥来生成信息的签名，然后使用公钥来验证签名。</p><p>生成签名时，使用 RSA 的 importKey() 方法对(从文件中读取的)私钥字符串进行处理，处理成可用的私钥用于生成签名。</p><p>从 Crypto.Signature 中导入 PKCS1_v1_5 ，重命名为 PKCS1_signature 。然后实例化一个签名对象 signer ，传入的参数是私钥，通过的 signer 的 sign() 方法对信息生成签名。</p><p>信息需要先转换成 sha 字符串，使用 Crypto.Hash 中的 SHA 来转换。生成的签名是字节串，为了显示得更友好，可以将结果转换成 base64 字符串。</p><p>验证签名时，使用 RSA 的 importKey() 方法对(从文件中读取的)公钥字符串进行处理，处理成可用的公钥用于验证签名。</p><p>实例化一个验证对象 verifier ，传入的参数是公钥，通过的 verifier 的 verify() 方法对签名进行验证。验证结果是一个布尔值，验证成功返回 True , 不成功返回 False 。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pymysql的坑以及django多个数据库迁移</title>
      <link href="2020/12/30/mysql-de-keng/"/>
      <url>2020/12/30/mysql-de-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>今日有个爬虫的需求，就在我把各个组件都测试完毕，将他们自信的组装到一起，结果，除了意外，这个意外就是显示sql语句有错误，可是，在我反复的在终端试验，却没有任何的错误，于是我开始了漫长的资料查询。</p></blockquote><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><blockquote><p>pymysql在储存长文本，有时会出现转义字符，可能导致两个连续的数据会被挤到一起</p></blockquote><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>我研究了很多的解决办法，选出两种最为方便的</p></blockquote><ol><li><p>在连接时，将编码格式改为<code>utf8mb4</code></p></li><li><p>在需要转义的对象用<code>连接.escape(value)</code>方法转义</p><pre class="language-none"><code class="language-none">sql = "insert into article(title,img,link,create_time,status) values(%s,%s,%s,%s,'1')" % (conn.escape(title),conn.escape(img),conn.escape(link),conn.escape(create_time),)</code></pre><h2 id="django多数据库的迁移"><a href="#django多数据库的迁移" class="headerlink" title="django多数据库的迁移"></a>django多数据库的迁移</h2></li></ol><blockquote><p>首先，我们需要在settings中链接上多个数据库，并且指定app</p></blockquote><img src="/2020/12/30/mysql-de-keng/image-20201230181824302.png" alt="" style="zoom:50%;" loading="lazy"><p>然后指定哪个模型使用哪个数据库</p><pre class="language-python" data-language="python"><code class="language-python">DATABASE_APPS_MAPPING = {    # 'app_name':'database_name',    'user': 'user',}</code></pre><p>如果不想每个应用同步到特定数据库，可以定义 <a href="https://docs.djangoproject.com/zh-hans/3.1/topics/db/multi-db/#topics-db-multi-db-routing">database router</a> ，它实施限制特定模型可用性的策略。</p><p>在迁移时，生成迁移文件，命令不变</p><pre class="language-python" data-language="python"><code class="language-python">python manage.py makemigrations</code></pre><p>迁移时需要指定哪个app进行数据迁移</p><pre class="language-python" data-language="python"><code class="language-python">python manage.py migrate --database=user</code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维码与python</title>
      <link href="2020/12/24/er-wei-ma-yu-python/"/>
      <url>2020/12/24/er-wei-ma-yu-python/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在二维码泛滥无比的今天，我们作为开发者，怎样生成二维码可谓是基础了，今天带来一篇python生成二维码的攻略</p></blockquote><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h2 id="qrcode"><a href="#qrcode" class="headerlink" title="qrcode"></a><strong>qrcode</strong></h2><p>首先安装这个库</p><pre class="language-js" data-language="js"><code class="language-js">pip install qrcode</code></pre><p>这个库的GitHub地址也给大家，方便大家更进一步了解</p><pre class="language-js" data-language="js"><code class="language-js">https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>lincolnloop<span class="token operator">/</span>python<span class="token operator">-</span>qrcode</code></pre><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a><strong>简单使用</strong></h3><p>用这个库来生成二维码，简直不要太简单了，只需一行代码！</p><pre class="language-js" data-language="js"><code class="language-js">img <span class="token operator">=</span> qrcode<span class="token punctuation">.</span><span class="token function">make</span><span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token string">"你好"</span><span class="token punctuation">)</span></code></pre><p>当然我们还需要导入库以及保存为图片格式：</p><pre class="language-j" data-language="j"><code class="language-j">import qrcode# 生成二维码img = qrcode.make(data="昊烨向你问好")# 将二维码保存为图片with open('test.png', 'wb') as f:    img.save(f)</code></pre><p>运行一下代码，就可以看到生成了一张<code>test.png</code>的图片：</p><img src="/2020/12/24/er-wei-ma-yu-python/image-20201224171159835.png" alt="" style="zoom:50%;" loading="lazy"><blockquote><p>当然你不仅仅能放文本在里面，你还能让它跳转链接，你只需要把data里的数据改为url即可。</p></blockquote><img src="/2020/12/24/er-wei-ma-yu-python/image-20201224171310611.png" alt="" style="zoom:50%;" loading="lazy"><h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a><strong>高级使用</strong></h3><p>除了简单生成二维码外，我们还能够自定义一些属性。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> qrcodeqr <span class="token operator">=</span> qrcode<span class="token punctuation">.</span><span class="token function">QRCode</span><span class="token punctuation">(</span>    version<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span>    error_correction<span class="token operator">=</span>qrcode<span class="token punctuation">.</span>constants<span class="token punctuation">.</span><span class="token constant">ERROR_CORRECT_L</span><span class="token punctuation">,</span>    box_size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>    border<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">)</span>qr<span class="token punctuation">.</span><span class="token function">add_data</span><span class="token punctuation">(</span><span class="token string">'Some data'</span><span class="token punctuation">)</span>qr<span class="token punctuation">.</span><span class="token function">make</span><span class="token punctuation">(</span>fit<span class="token operator">=</span>True<span class="token punctuation">)</span>img <span class="token operator">=</span> qr<span class="token punctuation">.</span><span class="token function">make_image</span><span class="token punctuation">(</span>fill_color<span class="token operator">=</span><span class="token string">"black"</span><span class="token punctuation">,</span> back_color<span class="token operator">=</span><span class="token string">"white"</span><span class="token punctuation">)</span><span class="token keyword">with</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'test1.png'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token operator">:</span>    img<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span></code></pre><p>可以看到，属性都在QRCode对象中设置，下面我来简单介绍一下上面的参数。</p><ol><li><code>version</code>：二维码大小，用1~40之间的整数来设置。最小的version=1，是一个21x21的矩阵。如果你想自动生成，将值设置为 None 并使用 fit=True 参数即可。</li><li><code>error_correction</code>: 二维码的纠错范围，可以选择4个常量：</li><li>ERROR_CORRECT_L 7%以下的错误会被纠正</li><li>ERROR_CORRECT_M (default) 15%以下的错误会被纠正</li><li>ERROR_CORRECT_Q 25 %以下的错误会被纠正</li><li>ERROR_CORRECT_H. 30%以下的错误会被纠正</li><li><code>box_size</code>：每一个点中的像素个数</li><li><code>border</code>：二维码距图像外围边框距离，默认为4，而且相关规定最小为4</li><li><code>fill_color</code>和<code>back_color</code>：可以更改QR的背景和绘画颜色。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seaweedfs</title>
      <link href="2020/12/22/seaweedfs/"/>
      <url>2020/12/22/seaweedfs/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p> <code>Saeweedfs</code>是一个由<code>golang</code>语言开发的分布式对象存储系统，很适合做图片服务器，性能很好，并且可兼容挂载提供路径访问的方式，使得文件储存在云端变得非常方便。</p></blockquote><p><code>seaweedfs</code>的特点： </p><ol><li>可以成存储上亿的文件（根据你硬盘大小变化） </li><li>速度刚刚的</li></ol><p><a href="https://github.com/chrislusf/seaweedfs">github地址</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装呢，需要从官网上下载对应系统的版本，<a href="https://github.com/chrislusf/seaweedfs/releases">地址</a>，我以windows为例，可以看到，下载下来的是个压缩包，解压后就是一个exe安装包，但是我们直接点是没有用的，所以，我们通过命令来进行</p><p>首先呢，我们查看一下所有的命令，得知，可以使用master命令来进行启动</p><pre class="language-python" data-language="python"><code class="language-python">weed master -ip=127.0.0.1</code></pre><img src="/2020/12/22/seaweedfs/image-20201222171848122.png" alt="" style="zoom:50%;" loading="lazy"><p>master节点设置好了之后，继续看文档，来设置volume节点</p><blockquote><p>如果没有data这个文件夹，就自己创建一个</p><p><code>mserver</code>是master节点地址</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">weed volume -dir="./data" -max=10 -mserver="127.0.0.1:9333" -port=9000 -index=leveldb</code></pre><img src="/2020/12/22/seaweedfs/image-20201222172215662.png" alt="" style="zoom:50%;" loading="lazy"><p>然后访问一下<code>http://localhost:9333/</code>即可，好，一切ok，再查看一下状态</p><pre class="language-python" data-language="python"><code class="language-python">"http://127.0.0.1:9333/cluster/status?pretty=y"</code></pre><img src="/2020/12/22/seaweedfs/image-20201222172408636.png" alt="" style="zoom:50%;" loading="lazy"><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>继续看文档，如果要写入文件，则需要发送请求到<code>/dir/assign</code>来获取<code>fid</code>和volume服务器url</p><img src="/2020/12/22/seaweedfs/image-20201222173140239.png" alt="" style="zoom:50%;" loading="lazy"><p>然后将fid拼接，发送文件，这里用postman测试一下</p><img src="/2020/12/22/seaweedfs/image-20201222175621056.png" alt="" style="zoom:50%;" loading="lazy"><p>发送成功，这时候你可以将<code>fid</code>存下</p><blockquote><p><code>fid</code>：</p><p>开头的数字3表示卷ID。逗号后是一个文件密钥01和一个文件<code>cookie 637037d6</code>。</p><p>卷ID是32位无符号整数。文件密钥是一个无符号的64位整数。文件cookie是32位无符号整数，用于防止URL猜测。</p><p>文件密钥和文件cookie均以十六进制编码。可以使用自己的格式存储&lt;卷ID，文件密钥，文件cookie&gt;元组，也可以将<code>fid</code>存储。</p></blockquote><p>然后，怎么访问呢，当然是通过刚刚保存的fid啦，不过要<strong>注意</strong>，一定要先查找卷服务器的url，<code>http://localhost:9333/dir/lookup?volumeId=卷ID</code>，然后通过返回的<code>publicUrl</code>这个域名来进行查找</p><img src="/2020/12/22/seaweedfs/image-20201222180246784.png" alt="" style="zoom:50%;" loading="lazy"><p>要注意，这时，不只是可以用这个方式来访问，还可以使用</p><pre class="language-none"><code class="language-none"># 卷id/密钥+文件cookie/文件名http://localhost:8080/3/01637037d6/my_preferred_name.jpg# 卷id/密钥+文件你cookie.后缀名http://localhost:8080/3/01637037d6.jpg还有其他方法，不一一列举啦http://localhost:8080/3,01637037d6.jpghttp://localhost:8080/3/01637037d6http://localhost:8080/3,01637037d6</code></pre><p>如果要获取图像的缩放版本，则可以添加一些参数：</p><pre class="language-none"><code class="language-none">http://localhost:8080/3/01637037d6.jpg?height=200&amp;width=200http://localhost:8080/3/01637037d6.jpg?height=200&amp;width=200&amp;mode=fithttp://localhost:8080/3/01637037d6.jpg?height=200&amp;width=200&amp;mode=fill</code></pre><p>要更新，请发送另一个具有更新文件内容的POST请求，就是fid不变的情况下，再发一个新的文件，它就会自动给覆盖掉</p><p>删除的话，直接发送delete请求到相同的地址，删除成功会给你返回一个size，文件不存在的话这个size的值为0</p><p>何谓分布式，当然是可以分布啦，它本身提供了机架感知和数据中心感知复制，SeaweedFS在卷级别应用复制策略。因此，在获取文件ID时，可以指定复制策略。例如：</p><pre class="language-none"><code class="language-none">curl http://localhost:9333/dir/assign?replication=001</code></pre><p>复制参数选项包括：</p><pre class="language-none"><code class="language-none">000:无复制001:在同一机架上复制一次010:在不同机架上复制一次，但数据中心相同100:在不同的数据中心复制一次200:在两个不同的数据中心复制两次110:在不同的机架上复制一次，在不同的数据中心复制一次</code></pre><p>还可以在启动主服务器时设置默认复制策略。额..暂时没有搞，稍后补</p><h2 id="python中使用seaweedfs"><a href="#python中使用seaweedfs" class="headerlink" title="python中使用seaweedfs"></a>python中使用seaweedfs</h2><blockquote><p>我们如果要在python中使用这个seaweedfs，则需要先安装一个包<code>pip install pyseaweed</code></p></blockquote><p>使用的方法，非常的简单，在GitHub上，作者也给写的相当明白了</p><pre class="language-python" data-language="python"><code class="language-python">from pyseaweed import WeedFS# File uploadw = WeedFS("localhost", 9333) # weed-fs master address and portfid = w.upload_file("n.txt") # path to file# Get file urlfile_url = w.get_file_url(fid)# Delete fileres = w.delete_file(fid)# res is boolean (True if file was deleted)</code></pre><p>我们简单的封装一下</p><pre class="language-python" data-language="python"><code class="language-python">from pyseaweed import WeedFS# 上传文件def upload_file(seaweed_address,file,name):    w = WeedFS(*seaweed_address)    fid = w.upload_file(stream=file,name=name)    if fid:        return fid    else:        return False## 查看文件的域名def get_file_url(seaweed_address, fid):    w = WeedFS(*seaweed_address)    file_url = w.get_file_url(fid)    if file_url:        return file_url    else:        return '该资源不存在'def del_file(seaweed_address,fid):    w = WeedFS(*seaweed_address)    res = w.delete_file(fid)    return res  # True or False</code></pre><blockquote><p>这里为什么要指定stream和name呢，这是因为如果传一个参数，就必须是文件的路径，如果不传文件路径，就只能将他的数据流和名字传进来。</p></blockquote><p>我们使用视图来测试一下吧,<code>seaweed_address</code>是我自己配置的一个地址，这个可以写死，也可以写成元组，然后像我这样使用</p><pre class="language-python" data-language="python"><code class="language-python">class avatar_upload(APIView):    def post(self,request):        avatar = request.FILES.get('avatar')        # 调用文件存储系统，将返回的fid存下        for chunk in avatar.chunks():            fid = upload.upload_file(USER_AVATAR,chunk,avatar.name)            print(fid)            return Response({})</code></pre><p>ok，完美，不过需要注意的是，在本地是没法测的，我也在找这个问题，服务器上是没有问题</p>]]></content>
      
      
      <categories>
          
          <category> 文件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bigchaindb安装</title>
      <link href="2020/12/20/bigchaindb-an-zhuang/"/>
      <url>2020/12/20/bigchaindb-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在很久没有更新博客以及自己技术的前提下，感受到了来自编程界的毒打，接受新事物，本是开发者应该作为本能的一件事，但实际上，我并没有坚持多久，很拒绝的接受新事物，所以，今日起，重铸开发荣光，我辈义不容辞。</p><p>今天带来的是<code>BigChainDB</code>，这是一个可用的<strong>去中心</strong>数据库，听到这个词，是不是意识到另一样某个同样是去中心的东西，是的，区块链。</p><p><code>BigChainDB</code>是一个区块链数据库，它具有每秒百万次写操作，储存PB级别的数据和亚秒级响应时间的性能。<code>BigChainDB</code>的设计起始于分布式数据库，通过创新加入了很多区块链的特性，像区中心控制、不可改变性、数字资产的创建和移动。</p><p><code>BigChainDB</code>继承了现代分布式数据库的特性：吞吐量和容量都是与节点数量线性相关，功能齐全的NoSQL查询语言，高效的查询和权限管理。因为构建在已有的分布式数据库上，它在代码层面也继承了企业级的健壮性。可扩展的容量意味着具有法律效力的合同和认证可以直接存储在区块链数据库里。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>安装我采用的是docker</p></blockquote><p>在安装了docker的前提下，直接拉取镜像</p><pre class="language-none"><code class="language-none">docker pull  bigchaindb/bigchaindb:all-in-one</code></pre><p>大概有300M左右，可以执行命令启动一下</p><pre class="language-none"><code class="language-none">docker run -it -d -p 9984:9984 镜像id</code></pre><p>访问一下9984，可以看到你的版本号</p><img src="/2020/12/20/bigchaindb-an-zhuang/image-20201220154358244.png" alt="" style="zoom:67%;" loading="lazy"><p>安装一些依赖</p><pre class="language-none"><code class="language-none">sudo apt-get updatesudo apt-get install libffi-devpip install --upgrade setuptoolspip3 install pytest-runner</code></pre><p>然后安装驱动，对应你的版本号</p><img src="/2020/12/20/bigchaindb-an-zhuang/image-20201220154540628.png" alt="" style="zoom:67%;" loading="lazy"><pre class="language-none"><code class="language-none">pip install -U bigchaindb-driver==版本号</code></pre><p>不过，可能会找不到这个包啊这些错误，没关系，我们直接去github上拉取他源码<code>git clone https://github.com/bigchaindb/bigchaindb-driver.git</code></p><p>然后进入这个文件夹，执行<code>python setup.py install</code>，强行给他装上，不只是这个包，任何包都可以通过这个办法来进行安装</p><p>之后，在docker内重新启动服务，命令为：</p><pre class="language-none"><code class="language-none">$ docker run \  --detach \  --name bigchaindb \  --publish 9984:9984 \  --publish 9985:9985 \  --publish 27017:27017 \  --publish 26657:26657 \  --volume $HOME/bigchaindb_docker/mongodb/data/db:/data/db \  --volume $HOME/bigchaindb_docker/mongodb/data/configdb:/data/configdb \  --volume $HOME/bigchaindb_docker/tendermint:/tendermint \  bigchaindb/bigchaindb:all-in-one</code></pre><blockquote><p>含义为：</p><ul><li><p><code>docker run</code> 告诉Docker运行一些映像</p></li><li><p><code>--detach</code> 在后台运行容器</p></li><li><pre><code>publish 9984:9984 将主机端口映射9984到容器端口9984<pre class="language-none"><code class="language-none">   （BigchainDB API服务器）  - `9985` BigchainDB Websocket服务器  - `27017` MongoDB的默认端口  - `26657` Tendermint RPC服务器- ```  --volume "$HOME/bigchaindb_docker/mongodb:/data"</code></pre>将主机目录映射 <pre class="language-none"><code class="language-none">$HOME/bigchaindb_docker/mongodb</code></pre>到容器目录<pre class="language-none"><code class="language-none">/data</code></pre>; 这使我们能够将数据持久保存在主机上，您可以在[官方Docker文档中](https://docs.docker.com/engine/tutorials/dockervolumes)阅读更多内容- `$HOME/bigchaindb_docker/tendermint:/tendermint` 保留Tendermint数据。</code></pre></li><li><p><code>bigchaindb/bigchaindb:all-in-one</code>要使用的图像。容器名称之后的所有选项都将传递到容器内部的入口点。</p></li></ul></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>官方文档可以说是非常详细了，我们从创建开始</p></blockquote><pre class="language-python" data-language="python"><code class="language-python"># 创建用户的密钥与公钥alice, bob = generate_keypair(), generate_keypair()# 链接def conn():    bdb = BigchainDB('http://127.0.0.1:9984')    return bdb# 创建一个链接bdb = conn()# 构造交易数据bicycle_asset = {    'data': {        'bicycle': {            'serial_number': 'abcd1234',            'manufacturer': 'bkfab'        },    },}# 元数据bicycle_asset_metadata = {    'planet': 'earth'}# 准备交易(operation是操作，create代表创建，singners是公钥，创建出来供谁拥有，asset是交易的东西，metadata是元数据)prepared_creation_tx = bdb.transactions.prepare(    operation='CREATE',    signers=alice.public_key,    asset=bicycle_asset,    metadata=bicycle_asset_metadata)# 通过私钥签名来完成交易(拥有者的私钥来进行交易签名)fulfilled_creation_tx = bdb.transactions.fulfill(    prepared_creation_tx,    private_keys=alice.private_key)# 发送到bigchaindb节点sent_creation_tx = bdb.transactions.send_commit(fulfilled_creation_tx)# 完成创建txid = fulfilled_creation_tx['id']</code></pre><p>这样，我们就创建好了一个可交易的资产</p>]]></content>
      
      
      <categories>
          
          <category> bigchaindb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> bigchaindb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobaXterm操作prometheus和grafana搭建监控预警</title>
      <link href="2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/"/>
      <url>2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>MobalXterm又名MobalXVT，是一款增强型终端，X服务器和Unix命令集工具箱，可以用它来连接服务器</p></blockquote><p><strong>MobaXterm主要功能：</strong></p><ul><li>支持各种连接 SSH，X11，RDP，VNC，FTP，MOSH</li><li>支持 Unix 命令(bash，ls，cat，sed，grep，awk，rsync，…)</li><li>连接 SSH 终端后支持 SFTP 传输文件</li><li>各种丰富的插件(git/dig/aria2…)</li><li>可运行 Windows 或软件</li></ul><h2 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h2><p><a href="https://mobaxterm.mobatek.net/">官网地址</a>，安装过程不再阐述，解压会比较慢，后续就正常了</p><p>然后打开，连接服务器</p><img src="/2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/image-20201207170236919.png" alt="" style="zoom:80%;" loading="lazy"><ul><li>先点击session，连接设置可以按需选择，这里我用了SSH，输入你服务器的公网IP即可</li></ul><img src="/2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/image-20201207170459123.png" alt="" style="zoom:67%;" loading="lazy"><ul><li>然后登录，就可以进入你的服务器内</li></ul><img src="/2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/image-20201207170844756.png" alt="" style="zoom:67%;" loading="lazy"><p>左边是主机文件，右边是操作台，也就是终端勾选左下角的 <code>Follow terminal folder</code>可以让两个的工作路径保持一致。</p><blockquote><p>文件传输和下载，可以采用直接拖拽的方式，或者采用鼠标右键选择相应功能。</p><p>但是，有一个问题，就是编码，编码问题是一个难以看出的问题，基本上，一些根本找不出错误的代码，一运行就出错，这就有可能是编码的问题，今天我在服务器上修改docker容器内的配置文件，但是由于想偷个懒，在主机上将配置文件拖出来，然后修改完再挂载回去，可是呢，报了一个及其恶心的错误</p></blockquote><pre class="language-none"><code class="language-none">level=error ts=2018-12-07T07:16:42.642Z caller=main.go:808 err="error loading config from \"/etc/prometheus/prometheus.yml\": one or more errors occurred while applying the new configuration (--config.file=\"/etc/prometheus/prometheus.yml\")"</code></pre><p>这个呢，找了很久也没有找到问题，最后灵机一动，是不是编码有问题，然后又转头回来整编码，结果还是没用，没办法，只能使用服务器里唯一的一个神一样的编辑器<strong>VIM</strong>，来进行一个字一个字的敲，最后神奇的是，问题解决了</p><p>虽然呢，编码都是<code>utf8</code>，但是，总有些说不上来的错误，反正呢，乖乖的用内部的<strong>VIM</strong>，一点问题没有。</p><p>还有一点是，在使用MobaXerm中的vim时，在修改文件的时候，经常会遇到<code>readonly option is set （add！to override）</code>这样的错误，解决办法也非常简单，如果是root权限，可以直接<code>:wq!</code>，或者按下ESC，输入<code>set noreadonly</code>，然后就正常保存就可以了</p><p>在服务器上部署，用docker是很方便的，我之前也有过几篇攻略，虽然可能说的很磕磕绊绊，但是还是希望能帮到大家。</p><h2 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h2><p><code>Prometheus</code>，是自动化运维领域很常用的软件，它中文名为普罗米修斯，它的作用就是监控告警</p><p>话不多说，路程还长，首先是安装问题，安装呢，我们在MobalXterm的终端中，使用docker来进行安装</p><pre class="language-python" data-language="python"><code class="language-python">#升级yumsudo yum update#卸载旧版本dockersudo yum remove docker  docker-common docker-selinux docker-engine#安装依赖sudo yum install -y yum-utils device-mapper-persistent-data lvm2#设置源sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposudo yum makecache fast#安装dockersudo yum install docker-ce#启动服务sudo systemctl start docker</code></pre><p>安装成功后查看版本:</p><pre class="language-python" data-language="python"><code class="language-python">docker -v</code></pre><p>显示版本号即为成功</p><p>然后可以换国内源来提升下载速度</p><pre class="language-python" data-language="python"><code class="language-python">1.先执行sudo vim /etc/docker/daemon.json2.添加如下代码{    "registry-mirrors": ["https://d7grpode.mirror.aliyuncs.com"]}</code></pre><p>重启docker</p><pre class="language-python" data-language="python"><code class="language-python">sudo systemctl restart docker</code></pre><p>随后拉取普罗米修斯的镜像</p><pre class="language-python" data-language="python"><code class="language-python">docker pull prom/prometheus:latest</code></pre><p>这里我们以监控Redis数据库为例子，所以还需要拉取redis和redis状态收集器两个镜像：</p><pre class="language-python" data-language="python"><code class="language-python">docker pull redisdocker pull oliver006/redis_exporter:latest</code></pre><p>然后启动一下</p><pre class="language-python" data-language="python"><code class="language-python">docker run -d --name redis -p 6379:6379 redis    docker run -d --name redis_exporter -p 9121:9121 oliver006/redis_exporter:latest --redis.addr redis://公网ip:6379</code></pre><p>随后创建普罗米修斯的配置文件</p><pre class="language-none"><code class="language-none"># 执行这条命令vim /tmp/prometheus.yml# 加入下面代码scrape_configs:  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.  - job_name: 'redis'     # Override the global default and scrape targets from this job every 5 seconds.    scrape_interval: 5s    static_configs:      - targets: ['公网ip:9121']</code></pre><p>这里每隔5秒获取一下运行的信息，然后启动</p><pre class="language-python" data-language="python"><code class="language-python">docker run -d -p 9090:9090 -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus:latest</code></pre><p>然后可以访问一下<code>http://公网ip:9090/targets</code></p><p>然后，我们新创建一个机器人</p><img src="/2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/image-20201207190120623.png" alt="" style="zoom:50%;" loading="lazy"><p>需要注意的是，要将公网ip写上</p><img src="/2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/image-20201207190245136.png" alt="" style="zoom:50%;" loading="lazy"><p>然后再拉取一个告警模块以及顶顶机器人的插件</p><p>如果普罗米修斯的告警模块检测到异常，就会通过钉钉机器人的webhook的地址发送消息</p><p>编写告警配置文件</p><pre class="language-none"><code class="language-none">global:  resolve_timeout: 5mroute:  receiver: webhook  group_wait: 30s  group_interval: 5m  repeat_interval: 5m  group_by: [alertname]  routes:  - receiver: webhook    group_wait: 10sreceivers:- name: webhook  webhook_configs:  - url: http://公网ip:8060/dingtalk/webhook1/send    send_resolved: true</code></pre><p>编写警告规则</p><pre class="language-none"><code class="language-none"># 运行这条命令vim /tmp/redis.rules# 添加代码groups:- name: redis  rules:  - alert: redis    expr: up{job="redis"} == 0    for: 15s    labels:      severity: 1      team: node    annotations:      summary: "Redis服务在您的帮助下已经成功死机，老板限你一小时之内把它救回来。"</code></pre><p>修改普罗米修斯的配置文件，将告警设置配置好</p><pre class="language-none"><code class="language-none"># 执行这条命令vim /tmp/prometheus.yml# 追加这些代码alerting:  alertmanagers:  - static_configs:    - targets:      - 公网ip:9093rule_files:  - "/etc/prometheus/redis.rules"</code></pre><p>重启普罗米修斯服务，我们需要再次挂载一个redis.rules。</p><pre class="language-none"><code class="language-none">docker run -d -p 9090:9090 -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml -v /tmp/redis.rules:/etc/prometheus/redis.rules  prom/prometheus:latest</code></pre><p>启动告警模块</p><pre class="language-none"><code class="language-none">docker run -d --name alertmanager -p 9093:9093 -v /tmp/alertmanager.yml:/etc/alertmanager/alertmanager.yml prom/alertmanager:latest</code></pre><p>启动钉钉插件</p><pre class="language-none"><code class="language-none">docker run -d -p 8060:8060 --name webhook timonwong/prometheus-webhook-dingtalk --ding.profile="webhook1=https://oapi.dingtalk.com/robot/send?access_token=钉钉token"</code></pre><p>然后访问一下<code>http://公网ip:9090/rules</code></p><img src="/2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/MobaXterm操作prometheus和grafana搭建监控预警\image-20201207192642565.png" alt="" style="zoom:80%;" loading="lazy"><p>然后我们关闭<code>redis_exporter</code>，来模拟redis宕机</p><pre class="language-none"><code class="language-none">docker stop redis_exporter</code></pre><p>普罗米修斯的监控立刻就发现了问题</p><img src="/2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/image-20201207192944667.png" alt="" style="zoom:67%;" loading="lazy"><p>然后可以看到，机器人会发送一个消息</p><img src="/2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/image-20201207193106577.png" alt="" style="zoom:50%;" loading="lazy"><p>ok，完毕</p><h2 id="Grafana可视化界面"><a href="#Grafana可视化界面" class="headerlink" title="Grafana可视化界面"></a>Grafana可视化界面</h2><p>这是一个很酷炫的可视化界面，可以将我们的监控界面导入到里面，隔壁小孩崇拜的很</p><p>首先拉取镜像：</p><pre class="language-none"><code class="language-none">sudo docker pull grafana/grafana</code></pre><p>然后启动</p><pre class="language-none"><code class="language-none">sudo docker run -d -p 3000:3000 --name grafana grafana/grafana</code></pre><ul><li>登录<code>http://公网ip:3000</code></li><li>默认账号和密码都是admin</li></ul><img src="/2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/image-20201207194652625.png" alt="" style="zoom:50%;" loading="lazy"><img src="/2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/image-20201207194725114.png" alt="" style="zoom:50%;" loading="lazy"><p>写入公网IP和端口</p><img src="/2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/image-20201207194844677.png" alt="" style="zoom:50%;" loading="lazy"><img src="/2020/05/15/mobaxterm-cao-zuo-prometheus-he-grafana-da-jian-jian-kong-yu-jing/image-20201207195444512.png" alt="" style="zoom:50%;" loading="lazy"><p>ok完美，莫得问题</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> MobaXerm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgrelSQL</title>
      <link href="2020/04/13/postgrelsql/"/>
      <url>2020/04/13/postgrelsql/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>自从mysql被oracle收购以后，PostgrelSQL逐渐成为开源关系型数据库的首选。并且就算mysql没有被收购，它所暴露出的问题也很难让人不追求新的数据库</p><p>比如，Emoji表情坑随后推出这个utfmb4</p><p>与时俱进之下，我们不采用普通的安装方式，而使用Docker来进行安装使用</p></blockquote><h2 id="Docker安装PostgrelSQL"><a href="#Docker安装PostgrelSQL" class="headerlink" title="Docker安装PostgrelSQL"></a>Docker安装PostgrelSQL</h2><p>第一步，拉取镜像</p><pre class="language-python" data-language="python"><code class="language-python">docker pull postgres:11.1</code></pre><p>然后，启动</p><pre class="language-python" data-language="python"><code class="language-python">docker run -d --name dev-postgres -e POSTGRES_PASSWORD=root -p 6432:5432 postgres:11.1</code></pre><blockquote><p>这里的<code>POSTGRES_PASSWORD</code>是PostgrelSQL的用户密码，自己制定一个就可以了。</p></blockquote><p>进入命令行操作一下</p><pre class="language-python" data-language="python"><code class="language-python">docker exec -it dev-postgres bashpsql -h localhost -U postgres</code></pre><p>这样就进入了容器内部的命令行</p><p>下面来介绍一下PostgrelSQL的一些命令</p><h2 id="PostgrelSQL命令"><a href="#PostgrelSQL命令" class="headerlink" title="PostgrelSQL命令"></a>PostgrelSQL命令</h2><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><p>建立数据库</p><pre class="language-python" data-language="python"><code class="language-python">create database 库名</code></pre><p>使用数据库</p><pre class="language-none"><code class="language-none">\c 库名</code></pre><p>查看所有数据库</p><pre class="language-none"><code class="language-none">\l</code></pre><p>删除数据库</p><pre class="language-none"><code class="language-none">drop database 库名</code></pre><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><p>创建表</p><pre class="language-none"><code class="language-none">create table 表名(字段 类型 属性)例子：create table empsal(id int4 not null,name varchar(20) not null,primary key(id))with(oids=FALSE);</code></pre><p>查看所有表</p><pre class="language-none"><code class="language-none">\d</code></pre><p>删除表</p><pre class="language-none"><code class="language-none">drop table if </code></pre><p>更新表结构</p><pre class="language-none"><code class="language-none">alter table 表名 add 字段名 类型 属性;例子：alter table article add email varchar(40);</code></pre><p>查看表结构</p><pre class="language-none"><code class="language-none">\d 表名</code></pre><p>插入数据</p><pre class="language-none"><code class="language-none">insert into 表名 values(对应数据)也可以根据字段来进行添加insert into 表名(字段名) values(对应数据)</code></pre><blockquote><p>这里要提一点，如果想使用可视化工具来操作PostgrelSQL的话，(例如navicat)，无法像mysql一样手动设置属性自增长，而是使用序列的形式来实现自增长</p></blockquote><p>创建序列</p><pre class="language-none"><code class="language-none">create sequence serial start 1这句话的意思是，创建一个名为serial的序列，从1开始计数</code></pre><p>查看结构</p><img src="/2020/04/13/postgrelsql/image-20201203105005032.png" alt="" style="zoom:67%;" loading="lazy"><p>随后，将需要设置的字段的默认值设为序列增长即可</p><pre class="language-none"><code class="language-none">alter table 表名 alter column 要自增长的字段 set default nextval(序列名)例子：ALTER TABLE "public"."article" ALTER COLUMN "id" SET DEFAULT nextval('serial');</code></pre><img src="/2020/04/13/postgrelsql/image-20201203105601012.png" alt="" style="zoom:50%;" loading="lazy"><p>删除数据</p><pre class="language-none"><code class="language-none">delete from 表名 where 条件例子：delete from user where name='李四'</code></pre><p>更新数据</p><pre class="language-none"><code class="language-none">update 表名 set 修改后的字段对应的数据 where 条件例子：update user set name='张三' where name='李四'</code></pre><h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><blockquote><p>聚合函数相信大家都用过，像sum、min、avg等，一般是和group by搭配使用，窗口函数和聚合函数类似，也是计算一些行集合的数据，和常规的聚合函数不同的是，窗口函数不会将参与计算的行合并成一行输出，而是将计算出来的结果带回到了计算行上。</p></blockquote><p>注意，<strong>窗口函数必须和over字句搭配使用</strong>，over字句包含<code>partition by</code>和<code>order by</code>两部分，分别用来分组和确定组内输出顺序，他们都是可选的</p><p>如果两个都省略，整个表会被作为一个分组</p><p>我们来举个例子吧，假设我们有一张表，分别有部门，员工，工资三个字段</p><p>假设我们要查询每个部门的平均工资以及所有员工的对比，在传统做法下，我们需要先通过group by分组，再用表连接统计一下上面的结果</p><p>而使用窗口函数，可以简化很多</p><img src="/2020/04/13/postgrelsql/image-20201203113052844.png" alt="" style="zoom:67%;" loading="lazy"><p>而使用<code>order by</code>的话，会造成怎样的结果呢</p><img src="/2020/04/13/postgrelsql/image-20201203113136091.png" alt="" style="zoom:67%;" loading="lazy"><p>可以看到，第一个是人事部门的平均工资，第二个，是研发和人事的平均工资，第三个，就是所有部门的平均工资。使用的时候要特别注意。</p><h2 id="python使用PostgrelSQL"><a href="#python使用PostgrelSQL" class="headerlink" title="python使用PostgrelSQL"></a>python使用PostgrelSQL</h2><p>和使用mysql一样，先装三方库</p><pre class="language-none"><code class="language-none">pip3 isntall psycopg2</code></pre><p>然后和mysql一样使用</p><pre class="language-python" data-language="python"><code class="language-python">import psycopg2.extrasconn = psycopg2.connect(host='localhost', port=6432, user='postgres', password='root', database='mytest')cursor = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)cursor.execute('SELECT * FROM empsal;')result = cursor.fetchone()print(result)</code></pre><p>ok，完成</p>]]></content>
      
      
      <categories>
          
          <category> PostgrelSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgrelSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket</title>
      <link href="2020/04/09/websocket/"/>
      <url>2020/04/09/websocket/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是websocket"><a href="#1-什么是websocket" class="headerlink" title="1.什么是websocket"></a>1.什么是<code>websocket</code></h2><blockquote><p><code>websocket</code>是<code>HTML5</code>出的协议，和HTTP协议没有什么关系，它的目的在于，在浏览器和服务器之间建立一个不受限制的双向实时通信的通道，比如服务器可以任意时刻向浏览器主动的推送消息</p><p> 它基于TCP，先通过HTTP/<code>HTTPS</code>协议发起一条特殊的HTTP请求进行握手后创建一个用于交换数据的TCP连接</p><p>他们是并行的关系</p></blockquote><p>HTTP和<code>WebScoket</code>的区别</p><ul><li>HTTP不支持常久的连接(长连接\循环连接等不算)</li><li><code>WebScket</code>和服务器只要一次握手动作，HTTP协议每次链接都需要三次握手才能发送消息</li><li>服务器和浏览器都可以在任意时刻相互的推送消息，HTTP的缺点就在于此，浏览器不主动请求，服务器就没法给浏览器发送数据</li><li>HTTP协议每次请求都要发送请求头，<code>websocket</code>一旦建立连接，之后请求都不用发送请求头</li></ul><blockquote><p>虽然HTTP可以用轮询或者comet机制实现<code>WebSocket</code>的功能，但是，每次轮询，就算是再快，也需要间隔时间，这样就造成了它的实时性不够，而且， 频繁的发送请求，会给服务器造成很大的压力，一般情况下，没人会这么做</p></blockquote><ul><li>轮询：<code>js</code>启动定时发送请求，间隔性的请求服务器是否有新的数据</li><li>comet：请求没有超过预定时间或者没有返回数据，一直保持连接状态，等有了数据再进行推送</li></ul><blockquote><p>comet虽然是实时性够了，但是，长时间挂起线程，会浪费服务器的资源，如果长时间没有数据，链路上的任何一个网关都可能关闭这个链接。</p><p>所以，会造成两个后果，要么，你不知道什么时候断开了，要么，你就定期发ping，检查连接是否正常</p></blockquote><h2 id="2-什么是三次握手，四次挥手"><a href="#2-什么是三次握手，四次挥手" class="headerlink" title="2.什么是三次握手，四次挥手"></a>2.什么是三次握手，四次挥手</h2><p>这是基于TCP协议的规则，建立TCP需要三次握手才能建立，而断开连接则需要四次挥手</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一次握手，客户端发送一个待SYN表之的TCP报文到服务器</p><p>第二次握手，服务器回应客户端，发送一个带有SYN和<code>ACK</code>标志的报文，表示它对客户端SYN报文的回应，同时询问客户端是否准备好进行数据通讯</p><p>第三次握手，客户端必须再次回应服务器一个<code>ACK</code>报文</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>第一次挥手，客户端发送一个FIN，用来关闭客户到服务器的数据传送</p><p>第二次挥手，服务器收到这个FIN，它发回一个<code>ACK</code>，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</p><p>第三次挥手，服务器关闭客户端的连接，发送一个FIN给客户端</p><p>第四次挥手，客户段发回<code>ACK</code>报文确认，并将确认序号设置为收到序号加1</p><blockquote><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p></blockquote><h2 id="3-WebSocket的使用"><a href="#3-WebSocket的使用" class="headerlink" title="3.WebSocket的使用"></a>3.<code>WebSocket</code>的使用</h2><p>1.首先需要一个<code>dwebsocket</code>依赖，安装非常简单，直接<code>pip install dwebsocket</code></p><p>2.在<code>settings</code>中需要注册加载，<code>INSTALLED_APPS</code>注册<code>dwebsocket</code></p><blockquote><p><code>dwebsocket</code>在<code>django3.1</code>之后自动加载，在这之前，都需要进行注册这一步骤</p></blockquote><p>3.导包<code>from dwebsocket.decorators import accept_websocket</code></p><p>4.写一个视图函数，需要用**<code>@accept_websocket</code>**，这样，声明了他是一个<code>webscoket</code>连接，这只是链接，不是发送消息，这里，定义了一个公共字典clients，一会儿要用，记住它</p><pre class="language-python" data-language="python"><code class="language-python">clients = {{@accept_websocketdef websocketlink(request):    if request.is_websocket():userid = uuid.uuid1()        while True:            message = request.websocket.wait()            if not message:                break            else:                clients[userid] = request.websocket</code></pre><blockquote><p><code>dwebsocket</code>有两种装饰器：<code>require_websocket</code>和<code>accept_websocekt</code><br>使用<code>require_websocket</code>装饰器会导致视图函数无法接收导致正常的<code>http</code>请求，一般情况使用<code>accept_websocket</code>方式就可以了</p></blockquote><p>5.在前端，发送一个连接，<strong>注意</strong>，此时后端的链接不是<code>http</code>，而是<code>ws</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// websocket连接</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">'WebSocket'</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//  生成websocket链接</span>    <span class="token keyword">var</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">'ws://127.0.0.1:8000/websocketlink/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送链接</span>        ws<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'你好啊世界'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">{</span>    <span class="token comment">// 发送消息</span>    ws<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        <span class="token comment">// 将获取信息打印</span>        <span class="token keyword">var</span> received_msg <span class="token operator">=</span> evt<span class="token punctuation">.</span>data<span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>$notification<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                message<span class="token operator">:</span>received_msg            <span class="token punctuation">{</span><span class="token punctuation">)</span>        ws<span class="token punctuation">.</span><span class="token function-variable function">onclose</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'链接已关闭'</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>    <span class="token punctuation">{</span></code></pre><p>6.推送消息接口，一个函数视图举例：</p><pre class="language-python" data-language="python"><code class="language-python">def sendmessage(request):# 获取消息    msg = request.GET.get('msg')    # 循环公共字典clients，遍历内部所有的链接，    for client in clients:        clients['client'].send(msg.encode('utf-8'))    return HttpResponse({'message':"ok"{)</code></pre><p>然后，链接成功后，再新打开一个页面，访问这个<code>sendmessage</code>方法，就可以在你的前端页面看到你发送的数据啦</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerhub部署Centos+Nginx+gunicorn+django独立架构</title>
      <link href="2020/04/07/dockerhub-bu-shu-centos-nginx-gunicorn-django-du-li-jia-gou/"/>
      <url>2020/04/07/dockerhub-bu-shu-centos-nginx-gunicorn-django-du-li-jia-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在win10简单的使用Docker打包那纯属玩蛇，真正的部署还是要在Centos，这里为什么要用gunicorn呢，因为uwsgi还要编写配置文件，比较麻烦，所以我偷个懒使用gunicorn，日后有时间再讲解uwsgi</p><p>Nginx呢，就好像一层缓冲墙，使用Nginx来反向代理，就相当于用户不能直接访问服务器，而是先访问Nginx，由Nginx来负责分发。</p><p>Nginx的默认策略就是轮询，按照顺序发送，如果服务器要横向扩展，按照顺序一个个的发送，如果服务器配置高低不一，可以将策略改为加权。根据服务器的配置来设置阈值，增加容灾性。</p></blockquote><h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><ul><li><p>首先呢，就是将项目打包，具体流程不再赘述了，请观阅拙作：Docker部署Django项目</p></li><li><p>然后，注册Dockerhub，类似gitee和github的仓库：[地址][<a href="https://hub.docker.com/]">https://hub.docker.com/]</a></p></li></ul><img src="/2020/04/07/dockerhub-bu-shu-centos-nginx-gunicorn-django-du-li-jia-gou/image-20201204215728237.png" alt="" style="zoom:67%;" loading="lazy"><ul><li>创建仓库</li></ul><img src="/2020/04/07/dockerhub-bu-shu-centos-nginx-gunicorn-django-du-li-jia-gou/image-20201204215832694.png" alt="" style="zoom:50%;" loading="lazy"><ul><li>然后呢，我们需要对本地的镜像名重命名</li></ul><pre class="language-python" data-language="python"><code class="language-python">docker tag 本地镜像名 仓库拥有者/仓库名例如：docker tag mydjango godhearing/mydjango</code></pre><ul><li>之后在命令行输入命令</li></ul><pre class="language-none"><code class="language-none">docker login</code></pre><ul><li>使用dockerhub的账号密码登录</li></ul><img src="/2020/04/07/dockerhub-bu-shu-centos-nginx-gunicorn-django-du-li-jia-gou/image-20201204220231612.png" alt="" style="zoom:50%;" loading="lazy"><blockquote><p>这里我是登录过了，输入账号密码后出来这个就是登录成功了</p></blockquote><ul><li><p>然后将本地镜像上传到dockerhub中</p><pre class="language-python" data-language="python"><code class="language-python">docker push godhearing/mydjango</code></pre></li><li><p>然后登录你的云服务器，然后安装docker服务</p><pre class="language-python" data-language="python"><code class="language-python">#升级yumsudo yum update#卸载旧版本dockersudo yum remove docker  docker-common docker-selinux docker-engine#安装依赖sudo yum install -y yum-utils device-mapper-persistent-data lvm2#设置源sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposudo yum makecache fast#安装dockersudo yum install docker-ce#启动服务sudo systemctl start docker</code></pre></li><li><p>安装完成后键入 <code>docker -v</code></p><blockquote><p>如果出来版本号就说明没有问题</p></blockquote><p>然后从dockerhub把镜像拉下来</p><img src="/2020/04/07/dockerhub-bu-shu-centos-nginx-gunicorn-django-du-li-jia-gou/image-20201204220900919.png" alt="" style="zoom:67%;" loading="lazy"></li><li><p>采用后台守护进程模式起服务</p><pre class="language-python" data-language="python"><code class="language-python">sudo docker run -d -p 8000:8000 --name 自定义镜像名 镜像名例如：sudo docker run -d -p 8000:8000 --name testdjango godhearing/mydjango</code></pre><img src="/2020/04/07/dockerhub-bu-shu-centos-nginx-gunicorn-django-du-li-jia-gou/image-20201204221251956.png" alt="" style="zoom:67%;" loading="lazy"><p>可以使用<code>docker ps</code>来查看是否运行成功</p></li><li><p>然后访问一下</p><img src="/2020/04/07/dockerhub-bu-shu-centos-nginx-gunicorn-django-du-li-jia-gou/image-20201204221517697.png" alt="" style="zoom:50%;" loading="lazy"><p>ok，没有问题，额。。。也不能叫没有问题，因为我的mysql是本地的，没有更改，不过也还可以啦，总之，项目呢，是部署的没有问题了。不要在意这些细节</p></li><li><p>然后呢，我们安装Nginx服务</p><pre class="language-python" data-language="python"><code class="language-python">docker pull nginx</code></pre></li><li><p>然后启动</p><pre class="language-python" data-language="python"><code class="language-python">docker run -d -p 80:80 nginx</code></pre><img src="/2020/04/07/dockerhub-bu-shu-centos-nginx-gunicorn-django-du-li-jia-gou/image-20201204221944665.png" alt="" style="zoom:50%;" loading="lazy"></li><li><p>现在，我们将运行Nginx容器里的配置文件copy到宿主机里面(拉到本地)</p><pre class="language-python" data-language="python"><code class="language-python">docker cp 容器id:/etc/nginx/conf.d/default.conf /root/default.conf</code></pre></li><li><p>复制出来之后，输入命令修改这个nginx配置</p><pre class="language-python" data-language="python"><code class="language-python">vim /root/default.conf</code></pre></li><li><p>将Gunicorn配置加到里面</p><pre class="language-none"><code class="language-none">server {    listen       80;    server_name  localhost;    #charset koi8-r;    #access_log  /var/log/nginx/host.access.log  main;     location / {        proxy_pass http://你的服务器公网ip:5000; # 这里是指向 gunicorn host 的服务地址        proxy_set_header Host $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    }    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   /usr/share/nginx/html;    }}</code></pre></li><li><p>修改完配置文件之后，关掉运行的nginx服务容器，并且删掉它</p><pre class="language-none"><code class="language-none">docker stop 容器iddocker rm $(docker ps -a -q)</code></pre></li><li><p>然后再次启动nginx，通过-v来进行挂载，就是将宿主机的文件替换Docker容器内部的文件，达到修改的效果</p><pre class="language-python" data-language="python"><code class="language-python">docker run --name mynginx -d -p 80:80 -v /root/default.conf:/etc/nginx/conf.d/default.conf nginx</code></pre></li><li><p>重新启动成功后，访问服务器ip即可</p></li></ul><p>ok完毕，比原始命令行shell安装不知快了多少倍</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-compons搭建redis集群-哨兵模式</title>
      <link href="2020/04/01/docker-compons-da-jian-redis-ji-qun-shao-bing-mo-shi/"/>
      <url>2020/04/01/docker-compons-da-jian-redis-ji-qun-shao-bing-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h2><blockquote><p>Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施。</p><p>它有几个好处：</p><ul><li>高性能，集群的性能和单节点的性能是同一个级别，并不会降低</li><li>高可用，在使用集群承担高负载的同时，也能进行高可用的容灾机制</li><li>易扩展，向集群添加新的节点，或者移除节点，都是透明化操作，不需要停机</li><li>原生，不需要其他代理或工具，和单机redis几乎完全兼容</li></ul></blockquote><h2 id="何为哨兵模式"><a href="#何为哨兵模式" class="headerlink" title="何为哨兵模式"></a>何为哨兵模式</h2><blockquote><p>哨兵模式，是监控redis集群状态的工具，就好像一个监控器，监控着主从服务器是否健康，是redis的高可用性解决方案，当某个主服务器宕机时，它会选举出一个最优的从服务器来充当主服务器，这样，用户体验不会改变</p><p>需要注意的是，虽然哨兵模式支持创建多个，但是一般建议采取奇数台，道理很简单，假如选举的两个从服务器票数一样，就会使场面瞬间尬住，主从间的切换有可能会崩掉</p><p>还有一点是，哨兵也不是不会出错的，如果哨兵出错，没有下一个哨兵出战，那么程序有可能会出错</p></blockquote><h2 id="使用docker创建镜像"><a href="#使用docker创建镜像" class="headerlink" title="使用docker创建镜像"></a>使用docker创建镜像</h2><ol><li><p>建一个文件夹，进入项目文件夹，再建一个专门存放哨兵的脚本sentinel，cd  sentinel</p></li><li><p>建立sentinel.conf配置文件</p><pre class="language-none"><code class="language-none">sentinel monitor mymaster redis-master 6379 2sentinel down-after-milliseconds mymaster 5000sentinel parallel-syncs mymaster 1sentinel failover-timeout mymaster 5000</code></pre><blockquote><p>该配置的意思是，监控主服务器的6379端口并启动两个实例，如果5秒内没有收到主节点的心跳，则哨兵就认为主节点宕机了，默认是30秒，如果5秒以上连接不上主库同步，则在5秒后进行选举，对其他从服务器进行角色转换</p></blockquote></li><li><p>建立sentinel-entypoint.sh脚本</p><pre class="language-none"><code class="language-none">#!/bin/shsed -i "s/$SENTINEL_QUORUM/$SENTINEL_QUORUM/g" /etc/redis/sentinel.confsed -i "s/$SENTINEL_DOWN_AFTER/$SENTINEL_DOWN_AFTER/g" /etc/redis/sentinel.confsed -i "s/$SENTINEL_FAILOVER/$SENTINEL_FAILOVER/g" /etc/redis/sentinel.confexec docker-entrypoint.sh redis-server /etc/redis/sentinel.conf --sentinel</code></pre><blockquote><p>该脚本文件会对配置文件进行同步，用来启动哨兵</p></blockquote></li><li><p>建立Dockerfile指定基础镜像，同时拷贝配置文件到镜像内部</p><pre class="language-none"><code class="language-none">FROM redisEXPOSE 26379ADD sentinel.conf /etc/redis/sentinel.confRUN chown redis:redis /etc/redis/sentinel.confCOPY sentinel-entrypoint.sh /usr/local/bin/RUN chmod +x /usr/local/bin/sentinel-entrypoint.shENTRYPOINT ["sentinel-entrypoint.sh"]</code></pre></li><li><p>最后退到项目的根目录，建<code>docker-compose.yml</code>配置文件</p><pre class="language-none"><code class="language-none">master:  image: redis  ports:    - "6379:6379"slave1:  image: redis  command: redis-server --slaveof redis-master 6379  links:    - master:redis-master  ports:    - "6380:6379"slave2:  image: redis  command: redis-server --slaveof redis-master 6379  links:    - master:redis-master  ports:    - "6381:6379"sentinel1:  build: sentinel  environment:    - SENTINEL_DOWN_AFTER=5000    - SENTINEL_FAILOVER=5000      links:    - master:redis-master    - slave1sentinel2:  build: sentinel  environment:    - SENTINEL_DOWN_AFTER=5000    - SENTINEL_FAILOVER=5000      links:    - master:redis-master    - slave2</code></pre><blockquote><p> 意思是，我们起三台redis服务，分别跑在6379,6380,6381 ，一主两从，并且有两个哨兵实例来监控他们</p></blockquote><img src="/2020/04/01/docker-compons-da-jian-redis-ji-qun-shao-bing-mo-shi/wwww.png" alt=" " style="zoom:90%;" loading="lazy"></li><li><p>在项目根目录下，启动服务：</p><pre class="language-python" data-language="python"><code class="language-python">docker-compose up --force-recreate# 如果希望在后台运行可以加-d参数</code></pre></li><li><p>测试一下，打开三个终端，分别进入redis-cli -p 6379，6380，6381<br>在主服务器6379下，添加一个数据，然后分别get</p></li><li><p>测试哨兵<br>手动停止主库的容器进程，来模拟宕机的情况</p><pre class="language-python" data-language="python"><code class="language-python">docker stop redissentinel_master_1</code></pre><p>使用<code>info</code>命令查询服务器的角色，可以看到，原本是slave，现在成为了master</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebHook机制</title>
      <link href="2020/03/17/webhook-ji-zhi/"/>
      <url>2020/03/17/webhook-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是web-hook"><a href="#1-什么是web-hook" class="headerlink" title="1.什么是web hook"></a>1.什么是<code>web hook</code></h3><blockquote><p><code>webhook</code>是一个<code>API</code>概念，并且变得越来越流行，我们能用事件描述的事物越来越多，<code>webhook</code>的作用范围也就越大， <code>webhook</code>作为一个清凉的事件处理应用，正变得越来越有用</p></blockquote><p>我们在网上做的工作，大部分其实就是事件，<code>webhooks</code>已经成为了连接系统的主要方式，不管是用户创建，支付成功，<code>DockerHub</code>镜像推送或者<code>Git</code>仓库上的合并请求，这些都是非常有用并且轻量级的共享信息的方式</p><ul><li><p>简单来说，就是一种反向<code>API</code>，类似于触发器一样</p><ul><li><p>打个比方，比如项目A要从项目B获取数据，通常需要项目B提供一个<code>API</code>接口，然后项目A去请求项目B的接口，获取数据</p></li><li><blockquote><p>通过<code>webhook</code>机制，对客户端和服务端的模式进行逆转</p></blockquote></li><li><p>继续新增加一个需求，项目A需要从项目B获取<strong>实时</strong>数据，如果按照传统做法，不停的去请求接口，就算是实现了这个功能，但是，效率和性能都非常的低</p></li><li><p>通过<code>webhook</code>机制，我们在项目B中加上一个触发器，在项目B每次创建新数据或者修改了某个数据，就会自动触发， 便会向项目B的hook地址进行请求，项目A收到项目B的请求，然后对数据进行处理</p></li></ul></li></ul><hr><h3 id="2-mysql外键的选择"><a href="#2-mysql外键的选择" class="headerlink" title="2.mysql外键的选择"></a>2.<code>mysql</code>外键的选择</h3><blockquote><p>所有的web开发都离不开性能和效率，我们就来聊聊<code>mysql</code>物理外键的性能问题</p></blockquote><p>为何说外键有性能问题，让我们慢慢分析一下</p><ol><li>数据库需要维护外键的内部管理，这样就给数据库增加了一些性能负担，尽管是些小负担，但是在数据量庞大的时候，和优化过的数据库差距也是很大的</li><li>外键等于把数据的一致性事务实现，全部交给数据库服务器完成，同样也会增加数据库服务器的压力</li><li>有了外键，当做一些设计外键字段的增删改等操作之后，需要触发相关操作去检查，从而不得不消耗资源</li><li>外键还会因为需要的请求对其他表内部加锁而容易出现死锁的情况</li></ol><p>虽然很多人不推荐你使用物理外键，但你听到更多的是mysql，而不是SQL server或者其他，比较公认的是，他的外键设计得确实不怎么好，限制多功能不强大等等</p><blockquote><p>还有，最重要的一点是，万一主键所在的表需要拆分，重构，那么，物理外键对应的表，也要进行一系列繁琐的操作，另一方面，数据库帮你保证级联关系，自己不保证思路清晰啊</p></blockquote><p>所以，逻辑外键在业界是比较成熟的，不适用物理外键，我们也可以约定逻辑外键，不再数据库中声明，外键，只在程序中实现关联</p><p>那么，逻辑外键实现了物理外键的功能，这，才是开发人员的第一选择</p><hr><p>说到这里，在数据库的策略上，我们也可以选择逻辑删除</p><blockquote><p>逻辑删除，就是，只对表进行更新增加操作，不进行删除，不再使用的历史数据，定期的归档来减少压力</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> WebHook </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写Celery</title>
      <link href="2020/02/27/shou-xie-celery/"/>
      <url>2020/02/27/shou-xie-celery/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>众所周知，celery是一个基于python开发的任务消息队列，轻松实现任务的异步处理，如果对celery不了解，请观阅之前一篇文章Celery</p></blockquote><ul><li>关于celery，它的底层也不是很难，假如，我们在一个需要celery的场景下，例如，我们发送邮件，使用celery是不是有些过重了。这时候，与其调用celery，还不如自己动手去实现一下，这样既轻量，又好用</li><li>我们需要用到的东西，第一就是多线程，因为我们要进行异步操作，使用多线程模拟是最为合理的，然后就是redis，当然了，用List也是可以的，但是我们为了能够贴近真实操作，使用redis中的列表模拟</li></ul><h2 id="实现celery"><a href="#实现celery" class="headerlink" title="实现celery"></a>实现celery</h2><ul><li><p>要知道，celery的本质，是队列，所以，我们手动写一个队列</p><pre class="language-python" data-language="python"><code class="language-python">class MyQueue:    def __init__(self,kename:str,**redis_kwargs):        # 链接redis   decode_response的作用是，字符串不会转换成bytes        self.__db = redis.Redis(**redis_kwargs,decode_responses=True)        self.key = kename        self.queue = []    # 添加数据    def push(self,x:str) -&gt; None:        self.__db.rpush(self.key,x)    # 删除数据    def pop(self) -&gt; int:        return self.queue.pop(0)    # 获取数据    def peek(self) -&gt; str:        return self.__db.lpop(self.key)    # 判断是否执行完毕    def empty(self)-&gt;bool:        return self.__db.llen(self.key)</code></pre></li><li><p>实例化</p><pre class="language-python" data-language="python"><code class="language-python">task_queue = MyQueue('myqueue')</code></pre></li><li><p>我们就以模拟发送邮件为生产者</p><pre class="language-python" data-language="python"><code class="language-python">result = ['1111111@qq.com','22222@qq.com','3333333@qq.com','4444444444@qq.com','55555555555@qq.com']for i in result:    if i[0]:        task_queue.push(i[0])</code></pre></li><li><p>然后，我们使用多线程来模拟消费者</p><pre class="language-python" data-language="python"><code class="language-python">def task():    # 如果队列空了，证明任务完成    while task_queue.empty() != 0:        # 取出任务，模拟消费        print(task_queue.peek())        time.sleep(1)    return '执行完毕'if __name__ == '__main__':    t1 = threading.Thread(target=task)    t2 = threading.Thread(target=task)    t1.start()    t2.start()    t1.join()    t2.join()</code></pre><p>需要几个消费者，就可以开启多个线程，当然了，也可以通过继承threading.Thread创建新的子类，实例化后调用start方法启动新线程，即它调用了线程的<code>run()</code>方法</p><pre class="language-python" data-language="python"><code class="language-python">class Thread_test(threading.Thread):    def __init__(self,queue_task):        threading.Thread.__init__(self)        self.queue = queue_task    def run(self) -&gt; None:        print(self.queue)if __name__ == '__main__':    # 队列为空，即为停止    while task_queue.empty() != 0:        # 创建线程        for i in range(2):            a = Thread_test(task_queue.peek())            a.start()        time.sleep(1)</code></pre></li><li><p>如此，我们便简单的实现了celery的底层</p></li></ul><hr><p>总结，任何名字听起来高大上的工具，不要因为它的触不可及而放弃，我们也可以用很简单的方式实现它们该有的功能。</p>]]></content>
      
      
      <categories>
          
          <category> Celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Celery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件</title>
      <link href="2019/11/30/vue-zu-jian/"/>
      <url>2019/11/30/vue-zu-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-组件定义"><a href="#1-组件定义" class="headerlink" title="1.组件定义"></a>1.组件定义</h2><ol><li><p>定义组件并引用 </p></li><li><p>父组件向子组件传值 </p></li><li><p>子组件向父组件传值 </p></li></ol><p>组件间传值：<a href="https://www.cnblogs.com/xiaonq/p/9697921.html">vuex</a></p><hr><h4 id="1-1-什么是组件"><a href="#1-1-什么是组件" class="headerlink" title="1.1  什么是组件"></a>1.1  什么是组件</h4><ul><li><code>Html</code>中有组件，是一段可以被复用的结构代码</li><li>Css中有组件，是一段可以被复用的样式</li><li>Js中有组件，是一段可以被复用的功能</li><li>Vue中的组件，指的就是一个模块，是一个独立的，完整的(包含<code>html，cssm，js</code>等)，可以直接拿来用</li></ul><h4 id="1-2-组件特性"><a href="#1-2-组件特性" class="headerlink" title="1.2  组件特性"></a>1.2  组件特性</h4><ul><li><p>组件的实例化对象，跟<code>vue</code>实例化对象一样，因此，我们也可以将<code>vue</code>实例化对象看成组件</p></li><li><p>组件间是独立的，因此数据要独立存储，方法要独立定义， **彼此间不能共享 **。</p></li></ul><hr><h2 id="2-父组件向子组件传值"><a href="#2-父组件向子组件传值" class="headerlink" title="2.父组件向子组件传值"></a>2.父组件向子组件传值</h2><h5 id="2-1-components-Child-vue-定义子组件"><a href="#2-1-components-Child-vue-定义子组件" class="headerlink" title="2.1  components/Child.vue 定义子组件"></a>2.1  <code>components/Child.vue</code> <strong>定义子组件</strong></h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span><span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token string">"color: red"</span><span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>子组件内容<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>         <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>data<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>     <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span> <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>     <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>         props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 接收父组件给子组件定义的属性 </span>    <span class="token punctuation">{</span> <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></code></pre><blockquote><p>子组件要使用父组件的数据，只需要一步，在 props中接收父组件的属性</p></blockquote><h5 id="2-2-components-Father-vue-定义父组件"><a href="#2-2-components-Father-vue-定义父组件" class="headerlink" title="2.2   components/Father.vue 定义父组件"></a>2.2   <code>components/Father.vue</code> <strong>定义父组件</strong></h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>     <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>父组件内容<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>     父组件显示<span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>msg<span class="token punctuation">{</span><span class="token punctuation">{</span>     <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token number">3.</span>第三步：把父组件的某一个属性传递给子组件<span class="token operator">--</span><span class="token operator">&gt;</span>     <span class="token operator">&lt;</span>Child <span class="token operator">:</span>data<span class="token operator">=</span><span class="token string">'msg'</span> <span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">&gt;</span>     <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>     <span class="token comment">// @指定的是src路径 </span>    <span class="token keyword">import</span> Child <span class="token keyword">from</span> <span class="token string">'@/components/Child'</span>     <span class="token comment">// 1.第一步：在父组件中导入子组件 </span>    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>         <span class="token comment">// 2.第二步：父组件中注册子组件 </span>        components<span class="token operator">:</span> <span class="token punctuation">{</span>             Child         <span class="token punctuation">{</span><span class="token punctuation">,</span>        <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token punctuation">{</span>                 msg<span class="token operator">:</span> <span class="token string">'父组件的信息'</span>             <span class="token punctuation">{</span>         <span class="token punctuation">{</span><span class="token punctuation">,</span>        methods<span class="token operator">:</span> <span class="token punctuation">{</span>                     <span class="token punctuation">{</span>     <span class="token punctuation">{</span> <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></code></pre><blockquote><p><code>components</code>注册子组件</p></blockquote><h5 id="2-3-router-index-js-中注册路由"><a href="#2-3-router-index-js-中注册路由" class="headerlink" title="2.3  router/index.js 中注册路由"></a>2.3  <code>router/index.js</code> <strong>中注册路由</strong></h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> Father <span class="token keyword">from</span> <span class="token string">'@/components/Father'</span> <span class="token comment">// @修饰符指的是 src目录 </span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>     routes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>         path<span class="token operator">:</span> <span class="token string">'/component'</span><span class="token punctuation">,</span>         name<span class="token operator">:</span> <span class="token string">'Father'</span><span class="token punctuation">,</span>        component<span class="token operator">:</span> Father     <span class="token punctuation">{</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">)</span></code></pre><blockquote><p>子组件中可以通过 定义 <code>props</code> 属性来接收父组件的数据</p></blockquote><h2 id="3-子组件向父组件传值"><a href="#3-子组件向父组件传值" class="headerlink" title="3.子组件向父组件传值"></a>3.<strong>子组件向父组件传值</strong></h2><h5 id="3-1-components-Child-vue-子组件通过触发方法-向父组件传值"><a href="#3-1-components-Child-vue-子组件通过触发方法-向父组件传值" class="headerlink" title="3.1  components/Child.vue 子组件通过触发方法, 向父组件传值"></a>3.1  <code>components/Child.vue</code> <strong>子组件通过触发方法, 向父组件传值</strong></h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>子组件页面<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>子组件<span class="token punctuation">{</span><span class="token punctuation">{</span>data<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"f1"</span><span class="token operator">&gt;</span>调用父<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token comment">//用props接收父组件的属性</span>    props<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    methods<span class="token operator">:</span><span class="token punctuation">{</span>        <span class="token comment">// 接收父组件给子组件定义的属性 </span>        <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment">//1.子组件调用父组件方法，并传值 </span><span class="token comment">// $emit 触发当前实例上的事件，也可以简单的理解为触发父组件上的事件（向上冒泡）</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'changeMsg'</span><span class="token punctuation">,</span><span class="token string">'子的信息'</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></code></pre><h5 id="3-2-components-Father-vue给子组件添加事件及事件处理方法"><a href="#3-2-components-Father-vue给子组件添加事件及事件处理方法" class="headerlink" title="3.2 components/Father.vue给子组件添加事件及事件处理方法"></a>3.2 <code>components/Father.vue</code><strong>给子组件添加事件及事件处理方法</strong></h5><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>父组件页面<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>        <span class="token punctuation">{</span><span class="token punctuation">{</span>msg<span class="token punctuation">{</span><span class="token punctuation">{</span>        <span class="token operator">&lt;</span>Child <span class="token operator">:</span>data<span class="token operator">=</span><span class="token string">'msg'</span> @changeMsg<span class="token operator">=</span><span class="token string">'f2'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token keyword">import</span> Child <span class="token keyword">from</span> <span class="token string">'@/components/Child'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    components<span class="token operator">:</span><span class="token punctuation">{</span>        Child    <span class="token punctuation">{</span><span class="token punctuation">,</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">{</span>            msg<span class="token operator">:</span><span class="token string">'父的数据'</span>        <span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token punctuation">,</span>    methods<span class="token operator">:</span><span class="token punctuation">{</span>        <span class="token comment">// 在父组件中定义一个f2方法，可以在子组件中触发并传值给父组件 </span>        <span class="token function">f2</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// data接收是子组件中传递的数据</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> data<span class="token comment">// 更新父组件的内容 </span>        <span class="token punctuation">{</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue优化之代码层面的优化</title>
      <link href="2019/11/19/vue-you-hua-zhi-dai-ma-ceng-mian-de-you-hua/"/>
      <url>2019/11/19/vue-you-hua-zhi-dai-ma-ceng-mian-de-you-hua/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vue 框架通过数据双向绑定和虚拟 DOM 技术，帮我们处理了前端开发中最脏最累的 DOM 操作部分， 我们不再需要去考虑如何操作 DOM 以及如何最高效地操作 DOM；但 Vue 项目中仍然存在项目首屏优化、Webpack 编译配置优化等问题，所以我们仍然需要去关注 Vue 项目性能方面的优化，使项目具有更高效的性能、更好的用户体验。</p></blockquote><h2 id="代码层面的优化"><a href="#代码层面的优化" class="headerlink" title="代码层面的优化"></a>代码层面的优化</h2><p>在vue中，有很多的功能相似，有略微区别的代码，正确的在使用场景下使用适合它的元素，会让代码运行的更加丝滑</p><h4 id="1-1-v-if和v-show使用场景"><a href="#1-1-v-if和v-show使用场景" class="headerlink" title="1.1 v-if和v-show使用场景"></a>1.1 v-if和v-show使用场景</h4><p><strong>v-if</strong> 是 <strong>真正</strong> 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p><strong>v-show</strong> 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><blockquote><p>比如，你的电脑</p><p>v-if就等于是你完全的将他关闭了，需要用时，再将他打开</p><p>v-show相当于是睡眠模式，他始终都开着，只是你看不到</p></blockquote><hr><h4 id="1-2-computed和watch使用场景"><a href="#1-2-computed和watch使用场景" class="headerlink" title="1.2 computed和watch使用场景"></a>1.2 computed和watch使用场景</h4><p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；</p><blockquote><p>简单来说就是，对计算结果会进行缓存，如果原始数据不改变，不需要重新计算，直接从缓存中读取结果</p><p>但是，方法必须有返回值，减少计算量，牺牲空间，来换取时间，对一些复杂的运算，使用计算属性会非常的有效率</p></blockquote><blockquote><p>假如，你经常的在一家商店购买十箱苹果， 在普通的函数计算中，需要每次取出苹果价格和数量，在计算属性中，只要你价格和数量没变化，就不需要计算，只需要从缓存中取值就好了</p></blockquote><p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><blockquote><p>监听属性简单来说就是数据一旦发生改变，会自动触发执行，watch属性中的对应的函数</p><p>如果函数中，有两个参数 a和b，a就是修改之后的新值，b是修改之前的旧值</p></blockquote><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><hr><h4 id="1-3-v-for遍历必须为item添加key，且避免同时使用v-if"><a href="#1-3-v-for遍历必须为item添加key，且避免同时使用v-if" class="headerlink" title="1.3 v-for遍历必须为item添加key，且避免同时使用v-if"></a>1.3 v-for遍历必须为item添加key，且避免同时使用v-if</h4><ul><li><p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 <code>Vue</code>内部机制精准找到该条列表数据。当 状态更新时，新的状态值和旧的状态值对比，较快地定位到这个循环 。</p></li><li><p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 推荐</span><span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>li    v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"user in activeUsers"</span>    <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">"user.id"</span><span class="token operator">&gt;</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span> user<span class="token punctuation">.</span>name <span class="token punctuation">{</span><span class="token punctuation">{</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>computed<span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token function-variable function">activeUsers</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>users<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> user<span class="token punctuation">.</span>isActive    <span class="token punctuation">{</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token comment">// 不推荐</span><span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>li    v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"user in users"</span>    v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"user.isActive"</span>    <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">"user.id"</span><span class="token operator">&gt;</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span> user<span class="token punctuation">.</span>name <span class="token punctuation">{</span><span class="token punctuation">{</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span></code></pre></li></ul><hr><h4 id="1-4-长列表性能的优化"><a href="#1-4-长列表性能的优化" class="headerlink" title="1.4 长列表性能的优化"></a>1.4 长列表性能的优化</h4><blockquote><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>    users<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>  <span class="token punctuation">{</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">async</span> <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> users <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/api/users"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>users <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">;</span></code></pre><hr><h4 id="1-5-事件的销毁"><a href="#1-5-事件的销毁" class="headerlink" title="1.5 事件的销毁"></a>1.5 事件的销毁</h4><blockquote><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>click<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">,</span><span class="token function">beforeDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>click<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span></code></pre><hr><h4 id="1-6-图片懒加载"><a href="#1-6-图片懒加载" class="headerlink" title="1.6 图片懒加载"></a>1.6 图片懒加载</h4><p>对于图片过多的页面，为了加速页面的加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载，等到滚动到可视区域再去加载，这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件</p><ol><li><p>安装插件</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">npm install vue<span class="token operator">-</span>lazyload <span class="token operator">--</span>save<span class="token operator">-</span>dev</code></pre></li><li><p>在入口文件main.js中引入并使用</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> VueLazyload <span class="token keyword">from</span> <span class="token string">'vue-lazyload'</span></code></pre></li><li><p>在vue中直接使用</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueLazyload<span class="token punctuation">)</span></code></pre><p>或者添加自定义选项</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueLazyload<span class="token punctuation">,</span> <span class="token punctuation">{</span>preLoad<span class="token operator">:</span> <span class="token number">1.3</span><span class="token punctuation">,</span>error<span class="token operator">:</span> <span class="token string">'dist/error.png'</span><span class="token punctuation">,</span>loading<span class="token operator">:</span> <span class="token string">'dist/loading.gif'</span><span class="token punctuation">,</span>attempt<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">{</span><span class="token punctuation">)</span></code></pre></li><li><p>在 vue 文件中将 img 标签的 :src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">v-lazy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/static/img/1.png<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span></code></pre></li></ol><hr><h4 id="1-7-提取公共代码"><a href="#1-7-提取公共代码" class="headerlink" title="1.7 提取公共代码"></a>1.7 提取公共代码</h4><blockquote><p>一个项目，不可能只有一个页面，而多个页面中，有相同资源的，重复加载会浪费用户的流量和服务器的成本，每个页面的加载资源太大，导致网页加载缓慢，影响用户体验</p><p>所以，我们需要提取公共的代码，抽离成单独的文件，以组件的方式在页面中灵活运用，组件间的应用，请参考<a href="https://god_hearing.gitee.io/myhexo/2020/10/30/vue-zu-jian/">这里</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支付宝支付</title>
      <link href="2019/09/13/zhi-fu-bao-zhi-fu/"/>
      <url>2019/09/13/zhi-fu-bao-zhi-fu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>微信与支付宝，国内无现金交易的两个巨头，在我们做项目的过程中，肯定少不了与这两个打交道，但是，涉及到钱的问题，稍微的不谨慎，就会造成不可磨灭的影响，所以，今天带来支付宝支付的攻略</p></blockquote><h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a><code>openssl</code></h2><p>首先，安装一个<code>openssl</code>，<a href="http://slproweb.com/products/Win32OpenSSL.html">地址</a></p><p>选择64位还是32位，看自己电脑</p><p>然后，在命令行输入<code>openssl</code>，进入openssl程序，然后分别执行以下命令：</p><pre class="language-python" data-language="python"><code class="language-python">genrsa -out rsa_private_key.pem   2048  # 生成私钥rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem # 生成公钥</code></pre><blockquote><p>这样就在当前目录生成了两个文件rsa_private_key.pem和rsa_public_key.pem，将这两个秘钥集成到项目中，就可以进行支付宝支付业务的处理了，当然也可以根据阿里提供的支付开放平台来进行生成，具体流程可自行google，并不算难</p></blockquote><p>然后我们后台选择的是<code>django</code>，在Django中集成支付接口的前置操作就是需要安装alipay的sdk，顺便导入加密模块</p><pre class="language-none"><code class="language-none">pip install python-alipay-sdkpip install Crypto</code></pre><p>然后将之前生成好的私钥和公钥(<strong>注意这里的公钥指的是支付宝公钥</strong>)，放入到项目目录中，改个名字好区分</p><pre class="language-python" data-language="python"><code class="language-python">app_public.txt  # 应用公钥app_private.txt # 应用私钥alipay_public.txt  # 支付宝公钥</code></pre><p>其中，填写上自己对应的公钥与私钥，格式为：</p><pre class="language-python" data-language="python"><code class="language-python">alipay_public.txt-----BEGIN PUBLIC KEY----- 密钥-----END PUBLIC KEY-----app_public.txt-----BEGIN PUBLIC KEY----- 密钥-----END PUBLIC KEY-----app_private.txt-----BEGIN RSA PRIVATE KEY-----密钥-----END RSA PRIVATE KEY-----</code></pre><p>然后在settings中配置：</p><pre class="language-python" data-language="python"><code class="language-python">ALIPAY_PUBLIC = os.path.join(BASE_DIR,'keys','alipay_public.txt')APP_PUBLIC = os.path.join(BASE_DIR,'keys','app_public.txt')APP_PRIVATE = os.path.join(BASE_DIR,'keys','app_private.txt')</code></pre><blockquote><p>注意路径</p></blockquote><p>新建个<code>pay.py</code>文件</p><pre class="language-python" data-language="python"><code class="language-python">from datetime import datetimefrom Crypto.PublicKey import RSAfrom Crypto.Signature import PKCS1_v1_5from Crypto.Hash import SHA256from urllib.parse import quote_plusfrom urllib.parse import urlparse, parse_qsfrom base64 import decodebytes, encodebytesimport jsonimport requestsclass AliPay(object):    """    支付宝支付接口(PC端支付接口)    """    def __init__(self, appid, app_notify_url, app_private_key_path,                 alipay_public_key_path, return_url, debug=False):        self.appid = appid        self.app_notify_url = app_notify_url        self.app_private_key_path = app_private_key_path        self.app_private_key = None        self.return_url = return_url        with open(self.app_private_key_path) as fp:            self.app_private_key = RSA.importKey(fp.read())        self.alipay_public_key_path = alipay_public_key_path        with open(self.alipay_public_key_path) as fp:            self.alipay_public_key = RSA.importKey(fp.read())        if debug is True:            self.__gateway = "https://openapi.alipaydev.com/gateway.do"        else:            self.__gateway = "https://openapi.alipay.com/gateway.do"    def direct_pay(self, subject, out_trade_no, total_amount, return_url=None, **kwargs):        biz_content = {            "subject": subject,            "out_trade_no": out_trade_no,            "total_amount": total_amount,            "product_code": "FAST_INSTANT_TRADE_PAY",            # "qr_pay_mode":4        }        biz_content.update(kwargs)        data = self.build_body("alipay.trade.page.pay", biz_content, self.return_url)        return self.sign_data(data)    def build_body(self, method, biz_content, return_url=None):        data = {            "app_id": self.appid,            "method": method,            "charset": "utf-8",            "sign_type": "RSA2",            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),            "version": "1.0",            "biz_content": biz_content        }        if return_url is not None:            data["notify_url"] = self.app_notify_url            data["return_url"] = self.return_url        return data    def sign_data(self, data):        data.pop("sign", None)        # 排序后的字符串        unsigned_items = self.ordered_data(data)        unsigned_string = "&amp;".join("{0}={1}".format(k, v) for k, v in unsigned_items)        sign = self.sign(unsigned_string.encode("utf-8"))        # ordered_items = self.ordered_data(data)        quoted_string = "&amp;".join("{0}={1}".format(k, quote_plus(v)) for k, v in unsigned_items)        # 获得最终的订单信息字符串        signed_string = quoted_string + "&amp;sign=" + quote_plus(sign)        return signed_string    def ordered_data(self, data):        complex_keys = []        for key, value in data.items():            if isinstance(value, dict):                complex_keys.append(key)        # 将字典类型的数据dump出来        for key in complex_keys:            data[key] = json.dumps(data[key], separators=(',', ':'))        return sorted([(k, v) for k, v in data.items()])    def sign(self, unsigned_string):        # 开始计算签名        key = self.app_private_key        signer = PKCS1_v1_5.new(key)        signature = signer.sign(SHA256.new(unsigned_string))        # base64 编码，转换为unicode表示并移除回车        sign = encodebytes(signature).decode("utf8").replace("\n", "")        return sign    def _verify(self, raw_content, signature):        # 开始计算签名        key = self.alipay_public_key        signer = PKCS1_v1_5.new(key)        digest = SHA256.new()        digest.update(raw_content.encode("utf8"))        if signer.verify(digest, decodebytes(signature.encode("utf8"))):            return True        return False    def verify(self, data, signature):        if "sign_type" in data:            sign_type = data.pop("sign_type")        # 排序后的字符串        unsigned_items = self.ordered_data(data)        message = "&amp;".join(u"{}={}".format(k, v) for k, v in unsigned_items)        return self._verify(message, signature)    #请求退款接口    def api_alipay_trade_refund(self,refund_amount,out_trade_no=None,trade_no=None,**kwargs):        #构造参数体        biz_content = { "refund_amount":refund_amount}        #传递可选参数        biz_content.update(**kwargs)        #判断使用站外订单还是支付宝订单        if out_trade_no:            biz_content["out_trade_no"] = out_trade_no        if trade_no:            biz_content["trade_no"] = trade_no        #构造支付接口地址        data = self.build_body("alipay.trade.refund",biz_content)        #构造url        url = self.__gateway+"?" + self.sign_data(data)        #请求接口        r = requests.get(url)        html = r.content.decode("utf-8")        return html</code></pre><p>在视图中：</p><pre class="language-python" data-language="python"><code class="language-python">#导入支付基类from testdjango.settings import BASE_DIRfrom testdjango import settingsimport timefrom django.shortcuts import render, redirect, HttpResponsefrom .pay import AliPayimport os# 支付宝初始化app_private_key_string = os.path.join(BASE_DIR,'keys','app_private.txt')alipay_public_key_string = os.path.join(BASE_DIR,'keys','alipay_public.txt')def get_order_code():    order_no = str(time.strftime('%Y%m%d%H%M%S', time.localtime(time.time())))    return order_no#初始化阿里支付对象def get_ali_object():    app_id = "2016102600762844"  #  APPID （沙箱应用）    # 支付完成后，跳转的地址。    return_url = "http://localhost:8000/alipayreturn/"    alipay = AliPay(        appid=app_id,        app_notify_url=return_url,        return_url=return_url,        app_private_key_path=app_private_key_string,        alipay_public_key_path=alipay_public_key_string,  # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥        debug=True,  # 默认False,    )    return alipaydef page1(request):    # 根据当前用户的配置，生成URL，并跳转。    money = request.POST.get('money')    alipay = get_ali_object()    # 生成支付的url    query_params = alipay.direct_pay(        subject="test",  # 商品简单描述        out_trade_no=get_order_code(),        total_amount=1,  # 交易金额(单位: 元 保留俩位小数)    )    pay_url = "https://openapi.alipaydev.com/gateway.do?{0}".format(query_params)  # 支付宝网关地址（沙箱应用）    print(pay_url)    return redirect(pay_url)def alipay_return(request):    alipay = get_ali_object()    params = request.GET.dict()    out_trade_no = request.GET.get("out_trade_no")    print(out_trade_no)    sign = params.pop('sign', None)    status = alipay.verify(params, sign)    print('==================开始==================')    print('GET验证', status)    print('==================结束==================')    return HttpResponse('支付成功')</code></pre><p>搞完收工，访问一下的视图即可跳转到支付页面，然后回调这些记得和网页环境一致即可。</p><h2 id="退款"><a href="#退款" class="headerlink" title="退款"></a>退款</h2><blockquote><p>退款业务，也是基于订单号。在之前的<code>pay</code>中已经添加过了，我们只需要增加一个视图即可</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">def refund(request):    #实例化支付类    alipay = get_ali_object()    #调用退款方法    order_string = alipay.api_alipay_trade_refund(    #订单号，一定要注意，这是支付成功后返回的唯一订单号    out_trade_no="20201216102213",    #退款金额，注意精确到分，不要超过订单支付总金额    refund_amount="1.00",    #回调网址    notify_url='http://localhost:8000/alipayreturn'    )    return HttpResponse(order_string)</code></pre><p>以上就是支付宝与django的操作，感谢观看</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> 支付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>验证码系列(邮箱、短信)</title>
      <link href="2019/08/31/yan-zheng-ma-xi-lie/"/>
      <url>2019/08/31/yan-zheng-ma-xi-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="python3利用腾讯云发送短信"><a href="#python3利用腾讯云发送短信" class="headerlink" title="python3利用腾讯云发送短信"></a><code>python3</code>利用腾讯云发送短信</h2><h4 id="如何发送短信"><a href="#如何发送短信" class="headerlink" title="如何发送短信"></a>如何发送短信</h4><blockquote><p>首先，注册一个腾讯云的账号，然后点击<a href="https://cloud.tencent.com/product/sms">这里</a></p></blockquote><ol><li><p>注册成功后，腾讯云会自动生成一个短信应用，如果没有默认应用，需要新建一下</p></li><li><p>记录一下应用的 appid 以及 appkey 一会要用到</p><p><img src="/2019/08/31/yan-zheng-ma-xi-lie/012.png" loading="lazy"></p></li><li><p>配置短信的签名，用来限制短信接口的权限，防止被恶意调用</p></li><li><p>然后配置模板</p></li><li><p>好了，进入正题，下面安装腾讯云短信的sdk<br><code>pip install qcloudsms_py</code></p></li><li><p>按照官网文档，准备必要的参数</p><pre class="language-python" data-language="python"><code class="language-python"># 短信应用 SDK AppIDappid = 1400009099  # SDK AppID 以1400开头# 短信应用 SDK AppKeyappkey = "9ff91d87c2cd7cd0ea762f141975d1df37481d48700d70ac37470aefc60f9bad"# 需要发送短信的手机号码phone_numbers = ["21212313123", "12345678902", "12345678903"]# 短信模板ID，需要在短信控制台中申请template_id = 7839  # NOTE: 这里的模板 ID`7839` 只是示例，真实的模板 ID 需要在短信控制台中申请# 签名sms_sign = "腾讯云"  # NOTE: 签名参数使用的是`签名内容`，而不是`签名ID`。这里的签名"腾讯云"只是示例，真实的签名需要在短信控制台中申请</code></pre></li><li><p>指定模板ID单发短信</p><pre class="language-python" data-language="python"><code class="language-python">from qcloudsms_py import SmsSingleSenderfrom qcloudsms_py.httpclient import HTTPErrorssender = SmsSingleSender(appid, appkey)params = ["5678"]  # 当模板没有参数时，`params = []`可以发送随机数，用来做短信验证码,如果指定为["5678",'5']，则过期时间为5分钟try: result = ssender.send_with_param(86, phone_numbers[0],      template_id, params, sign=sms_sign, extend="", ext="") except HTTPError as e: print(e)except Exception as e: print(e)print(result)</code></pre></li><li><p>如果要群发短信，<code>phone_numbers</code>不取0值，发送全部</p></li></ol><hr><h4 id="点击发送短信验证码"><a href="#点击发送短信验证码" class="headerlink" title="点击发送短信验证码"></a>点击发送短信验证码</h4><p>视图定义，获取手机号，这里，我是把上面的脚本封装成函数<code>phone_s</code>了，两个参数，分别为手机号和随机数验证码</p><pre class="language-python" data-language="python"><code class="language-python">class phoneView(APIView):    def post(self,request):        phone = request.POST.get('phone')# 随机数，用来做验证码        uuid = random.randint(1000,9999)        # 调用发送短信的接口，传入手机号和随机数验证码        pwg = phone_s(phone,uuid)        if pwg:            # 连接redis            redis_client = get_redis_connection('phone')            redis_phone = redis_client.get(phone)# 防止频繁发送，如果redis中有，就不必再发            if redis_phone:                return Response({'code': 1003, 'msg': '频繁发送'{)            # 存入redis,邮箱为键，uuid为值            redis_client = get_redis_connection('phone')  # 获取redis客户端            redis_client.setex(phone, 60 * 5, uuid)            return Response({'code':1000,'msg':'发送成功'{)        return Response({'code':1004,'msg':'发送失败'{)</code></pre><p>至于验证，只需要从redis中取出验证码来比对即可</p><hr><h2 id="邮箱验证码"><a href="#邮箱验证码" class="headerlink" title="邮箱验证码"></a>邮箱验证码</h2><p>发送邮箱验证码，我们使用的是QQ邮箱，打开QQ邮箱，打开设置，在里面找到</p><p><strong><code>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</code></strong></p><p>打开POP3/SMTP服务</p><p>获取到授权码之后，我们就可以直接可以开始</p><pre class="language-python" data-language="python"><code class="language-python">#定义参数my_mail = "你申请授权的邮箱"#授权码my_pass = "授权码"#定义发送邮件的方法def mail(subject,content,mailaddr):    #声明邮件对象    msg = MIMEText(content,'plain','utf-8')    #设置发送方对象    msg['From'] = formataddr(['在线教育平台',my_mail])    #设置收件方对象    msg['To'] = formataddr(['尊敬的客户',mailaddr])    #设置标题    msg['Subject'] = subject    #设置smtp服务器    server = smtplib.SMTP_SSL("smtp.qq.com",465)    #登录邮箱    server.login(my_mail,my_pass)    #发送邮件    server.sendmail(my_mail,[mailaddr],msg.as_string())    #关闭smtp链接    server.quit()</code></pre><p>然后定义视图</p><pre class="language-python" data-language="python"><code class="language-python">class Go_emailView(APIView):    def post(self,request):        # 验证邮箱有效性        email = request.POST.get('email',None)        try:            re.match(r'[a-zA-Z0-9]{0,19{@(qq|163|126)\.(com|cn|net)$', email)        except Exception as e:            return Response({'code': 1002, 'msg': '电子邮箱不正确'{)        # 查询redis中是否有这个数据，如果有，则不需要再次发送        # 验证邮箱验证码        redis_client = get_redis_connection('email')        # 获取redis中的库        redis_email = redis_client.get(email)        if redis_email:            return Response({'code':1003,'msg':'频繁发送'{)        uuid = random.randint(0,9999)        try:            # 调用发送邮件的函数            mail('龙潭技术博客验证', '您的验证码是{{，有限期为2分钟'.format(uuid), email)            # 存入redis,邮箱为键，uuid为值            redis_client = get_redis_connection('email')  # 获取redis客户端            redis_client.setex(email, 60 * 2, uuid)            return Response({'code':1000,'msg':'发送成功'{)        except Exception as e:            print(e)            return Response({'code':1001,'msg':'发送失败'{)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABAC权限模型</title>
      <link href="2019/08/29/abac-quan-xian-mo-xing/"/>
      <url>2019/08/29/abac-quan-xian-mo-xing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ABAC权限模型，是基于属性的权限模型，ABAC通过动态计算一个或一组属性来满足某种条件来进行授权判断(可以编写简单的逻辑)，属性通常来说分为四类，用户属性(例如年龄，性别等)，环境属性(比如时间，地点)，操作属性(比如读取)，对象属性(如一篇文章，又称为资源属性),所以理论上能够实现非常灵活的控制权限,几乎能满足所有类型的需求</p></blockquote><p>例如规则：“允许所有班主任在上课时间自由进出校门”这条规则，其中，“班主任”是用户的角色属性，“上课时间”是环境属性，“进出”是操作属性，而“校门”就是对象属性了。为了实现便捷的规则设置和规则判断执行，ABAC通常有配置文件（XML、YAML等）或DSL配合规则解析引擎使用。XACML（eXtensible Access Control Markup Language）是ABAC的一个实现，但是该设计过于复杂，我还没有完全理解，故不做介绍。</p><hr><p>总结一下，ABAC有如下特点</p><ol><li>集中化管理</li><li>可以按需求实现不同颗粒度的权限控制</li><li>不需要预定以判断逻辑，减轻了权限系统的维护成本，特别是需求经常变化的系统中</li><li>定义权限时，不能直观的看出用户和对象间的关系</li><li>规则如果稍微复杂一点，或者设计混乱，就会给管理者维护和追查带来麻烦</li><li>权限判断需要实时执行，规则过多会导致性能问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACL与RBAC访问权限模型</title>
      <link href="2019/08/28/acl-yu-rbac/"/>
      <url>2019/08/28/acl-yu-rbac/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是ACL"><a href="#什么是ACL" class="headerlink" title="什么是ACL"></a>什么是<code>ACL</code></h4><blockquote><p>以前非常盛行的一种权限设计，它的核心主要在于用户和权限直接挂钩。</p><p>它的原理非常的简单，每一项资源，都配有一个列表，这个列表记录的就是哪些用户可以对这项资源执行CRUD中的那些操作。当系统试图访问这项资源时，会首先检查这个列表中是否有关于当前用户的访问权限，从而确定当前用户可否执行相应的操作。总得来说，<code>ACL</code>是一种面向资源的访问控制模型，它的机制是围绕<strong>“资源”</strong>展开的。</p></blockquote><p>它的优点是：简单易用，开发便捷</p><p>但同样，它的缺点也很明显，用户和权限直接挂钩，导致在授予权限时的复杂性，比较分散，不便于管理</p><p>使用场景：</p><ul><li> 比较小的用户管理系统</li><li> 常见的文件系统权限设计，直接给用户加权限</li></ul><h4 id="什么是RBAC"><a href="#什么是RBAC" class="headerlink" title="什么是RBAC"></a>什么是<code>RBAC</code></h4><blockquote><p><code>RBAC</code>是基于角色的访问控制系统，权限和角色相联系，用户通过成为某个角色而获取该角色拥有的权限</p><p>它的原理就是将用户按照角色进行归类，通过用户的角色来确定用户有没有对某项资源访问的权限</p></blockquote><p>这样做的好处是，简化了用户与权限的管理，在一定程度上简化了授予时的复杂度，易扩展 易于维护</p><p>缺点：开发对比于<code>ACL</code>相对复杂，而且，比较僵硬，如果要修改某个用户所拥有的权限，只能修改它的角色，这样，如果有不想让他拥有的权限，<code>RBAC</code>就显得很僵硬。</p><p>使用场景：</p><ul><li>数据量比较庞大时授予权限</li><li>比较明确的角色分明时</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>如果要写一个用户管理系统，数据表之间的关联关系适当的添加关联关系甚至可以不添加那些看起来关联住的表，这样，查询时，完全可以通过多表联查来实现某些目的，不仅会使维护变得简单许多，还会将这个框给划开，而不是牵一发而动全身。</p><p><img src="/2019/08/28/acl-yu-rbac/20201102201153.png" loading="lazy"></p><p><strong>左：<code>ACL</code>  右：<code>RBAC</code></strong></p><blockquote><p>无论是<code>ACL</code>还是<code>RBAC</code>，都不能过于复杂，规则过多，否则，维护性和性能会下降</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊天机器人</title>
      <link href="2019/08/16/liao-tian-ji-qi-ren/"/>
      <url>2019/08/16/liao-tian-ji-qi-ren/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是聊天机器人"><a href="#什么是聊天机器人" class="headerlink" title="什么是聊天机器人"></a>什么是聊天机器人</h2><blockquote><p>好吧其实没什么好解释的，就是能够一天二十四小时陪伴你到老的机器人，具有一定的学习能力，越来越像人，让你在没人陪的时候也能有人聊聊天解解闷</p></blockquote><p>由于我还不太熟悉花里胡哨的机器学习，虽然对这方面有着很大的兴趣，但是奈何需要一定的门槛，不过没关系，我们可以先做一个调包侠</p><p>这篇教程，让我们一起用python来实现三款免费而且好用的机器人</p><p>从最简单的青云客开始吧</p><h2 id="青云客"><a href="#青云客" class="headerlink" title="青云客"></a>青云客</h2><p>首先呢，青云客可谓是相当的简单了，也不需要注册，不需要登录，直接上代码吧</p><pre class="language-python" data-language="python"><code class="language-python">url = 'http://api.qingyunke.com/api.php?key=free&amp;appid=0&amp;msg=%s'%(urllib.parse.quote('你好呀'))html = requests.get(url)print(html.json()['content'])</code></pre><blockquote><p>唯一需要注意的一点是，中文在url里，必须得转码，避免报错的可能，使用urllib</p></blockquote><h2 id="微软小冰"><a href="#微软小冰" class="headerlink" title="微软小冰"></a>微软小冰</h2><blockquote><p>微软小冰是领先的跨平台人工智能机器人。微软小冰注重人工智能在拟合人类情商维度的发展，强调人工智能情商，而非任务完成在人机交互中的基础价值。</p></blockquote><p>首先需要先领养小冰，通过微博关注小冰，然后给她发个消息</p><p><img src="/2019/08/16/liao-tian-ji-qi-ren/image-20201116200835343.png" loading="lazy"></p><p>领养完成之后，按F12打开调试窗口，通过<code>chat/</code>里的Cookie，找到SUB值，注意不要手动退出，手动退出会刷新SUB的</p><p><img src="/2019/08/16/liao-tian-ji-qi-ren/image-20201116200959106.png" loading="lazy"></p><p>之后，随便再发一条消息，找到<code>new.json</code>数据包，找到uid和source</p><p><img src="/2019/08/16/liao-tian-ji-qi-ren/image-20201116201243607.png" loading="lazy"></p><p>最后构造参数</p><pre class="language-python" data-language="python"><code class="language-python">def xiaobing():    uid = '你的uid'    source = '你的source'    SUB = '你的SUB'    url_send = 'https://api.weibo.com/webim/2/direct_messages/new.json'    data = {        'text': 你要说的话,        'uid': uid,        'source': source    }    headers = {        'cookie': 'SUB='+SUB,        'Content-Type': 'application/x-www-form-urlencoded',        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36',        'Referer': 'https://api.weibo.com/chat/'    }    response = requests.post(url_send, data=data, headers=headers).json()    sendMsg = response['text']    time.sleep(1)    while True:        url_get = 'https://api.weibo.com/webim/2/direct_messages/conversation.json?uid={}&amp;source={}'.format(uid, source)        response = requests.get(url=url_get,headers=headers).json()        getMsg = response['direct_messages'][0]['text']        if sendMsg == getMsg:            time.sleep(1)            else:                return getMsg</code></pre><p>也是调包侠的日常，没啥难度</p><h2 id="腾讯闲聊"><a href="#腾讯闲聊" class="headerlink" title="腾讯闲聊"></a>腾讯闲聊</h2><p> 这个也和小冰类似</p><p>先创建应用</p><img src="/2019/08/16/liao-tian-ji-qi-ren/image-20201116201602855.png" alt="" style="zoom:50%;" loading="lazy"><p>拿到ID和KEY</p><img src="/2019/08/16/liao-tian-ji-qi-ren/image-20201116201641496.png" alt="" style="zoom:50%;" loading="lazy"><p>欧克，准备工作完成，上代码</p><pre class="language-python" data-language="python"><code class="language-python">def tencent(msg):    APPID = '123'    APPKEY = '123'    url = 'https://api.ai.qq.com/fcgi-bin/nlp/nlp_textchat'    params = {        'app_id': APPID,        'time_stamp': str(int(time.time())),        'nonce_str': ''.join(random.choice(string.ascii_letters + string.digits) for x in range(16)),        'session': '10000'.encode('utf-8'),        'question': msg.encode('utf-8')    }    sign_before = ''    for key in sorted(params):        # 键值拼接过程value部分需要URL编码，URL编码算法用大写字母，例如%E8。quote默认大写。        sign_before += '{}={}&amp;'.format(key, urllib.parse.quote(params[key], safe=''))        # 将应用密钥以app_key为键名，拼接到字符串sign_before末尾    sign_before += 'app_key={}'.format(APPKEY)    # 对字符串sign_before进行MD5运算，得到接口请求签名    sign = hashlib.md5(sign_before.encode('UTF-8')).hexdigest().upper()    params['sign'] = sign    # print(params)    html = requests.post(url, data=params).json()    return html['data']['answer']msg= '我好看吗'print("原话&gt;&gt;", msg)res = tencent(msg)print("腾讯&gt;&gt;", res)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据结构与算法</title>
      <link href="2019/08/05/python-shu-ju-jie-gou-yu-suan-fa/"/>
      <url>2019/08/05/python-shu-ju-jie-gou-yu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><blockquote><p>又称存储结构</p></blockquote><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p> 集合结构：(同属一个整体，但是每个元素之间没有关系)<br>​ 线性结构：队尾元素没有直接后继，队头元素没有直接前驱,其他元素有唯一的直接前驱和后继（一对一）<br>​ 树形结构：除了根元素，其他元素都有一个前驱和多个后继（一对多）<br>​ 图形结构：每个元素都有多个前驱和后继（多对多）</p><p> 重点:<code>线性结构</code></p><ul><li>如果既是线性结构，又是链式结构，这种结构成为链表</li><li>如果既是线性结构，又是顺序结构，这种结构成为顺序表</li></ul><p>链表又分为：单向链表 双向链表 单向循环链表</p><p>单向链表:当连接表中的每个节点只包含一个指针时，他只能指向下一个节点地址，这种只含有一个指针域的链表，称为<strong>单向链表</strong></p><p>双向链表：它的连接表中，每个节点，都有两个指针，指向了直接前驱和直接后继，从双向链表中的任意一个节点开始访问，都能很方便的访问到它的前驱节点和后继节点，这种结构，称为<strong>双向链表</strong></p><p>单向循环链表：普通的单向链表，末尾节点(也叫叶子节点)的指针，不再指向NULL，而是指向第一个节点，即开始节点</p><blockquote><p>为什么要用单向循环链表，打个比方，我们要对单向链表中的某个节点进行访问，只能从头开始访问，而单向循环链表，可以从任意一个节点开始，因为它末尾的的指针指向了第一个节点，极大的增加了其灵活性</p></blockquote><p>接下来，我们用代码来展示一下</p><pre class="language-python" data-language="python"><code class="language-python">'''单向链表：指向空的节点为尾结点单向循环链表：指向头结点的节点为尾结点'''# 创建节点类class Node:    def __init__(self, data):        """节点类"""        self.data = data        self.pointer = None        # 创建链表类       class SCLL:    def __init__(self):        """ 初始化函数"""        self.head = Node(None)        self.head.pointer = self.head        # 判断是否位空    '''需要判断头结点是否指向自身，从而确定是否为空'''def is_empty(self):        if self.head.pointer == self.head:        return True        # 针对空链表可返回None；针对非空链表即采用循环操作，结束条件当前位置是尾结点    def traversal(self):    """ 遍历链表"""    if self.is_empty():        return False    else:        counter = 1        current =self.head.pointer        # 当前指针不指向头结点时进行循环        while(current != self.head):            print(" Element {{ is {{ ".format(counter, current.data))            counter += 1            current = current.pointer        return True </code></pre><p>链表和顺序表的区别：<br>链表插入删除方便，修改查找不方便<br>顺序表修改和查找方便，插入删除不方便</p><blockquote><p>顺序结构：逻辑结构相邻，物理结构也相邻<br>​链式结构：逻辑相邻，物理不一定相邻</p></blockquote><hr><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>官方说法为：解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制</p><p>通俗的讲：</p><p>算法是特定解决问题的方法步骤</p></blockquote><h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><ul><li>输入：有零个或多个输入</li><li>输出：有一个或多个输出</li><li>有穷性：有限的时间或有限的步骤可以结束算法</li><li>确定性：每个步骤只有唯一的意思，不会产生歧义</li><li>可行性：可用现有的条件可以实现</li></ul><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>时间复杂度:算法运行所需要的时间</li></ul><p>用大O表示法<br><code>list：pop()</code>删除末尾元素：O(1)<br>pop(0)删除第一个元素：O(n)<br>sort()排序：O(<code>nlogn</code>)<br>insert()插入元素 O(n)<br>append()末尾添加元素:O(1)<br>字典：<br>除了循环 复制 O(n)<br>删除、添加、修改、查询元素O(1)</p><ul><li>空间复杂度：算法运行所需要的空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫的相关知识</title>
      <link href="2019/08/01/pa-chong-de-xiang-guan-zhi-shi/"/>
      <url>2019/08/01/pa-chong-de-xiang-guan-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-虚拟环境"><a href="#1-虚拟环境" class="headerlink" title="1.虚拟环境"></a>1.虚拟环境</h2><blockquote><p>虚拟环境就是一个隔离的python环境，不同的项目应该使用不同的虚拟环境(可以使用同一个虚拟环境)</p></blockquote><blockquote><p>虚拟环境不会导致环境之间的污染</p></blockquote><h4 id="1-1-虚拟环境管理模块"><a href="#1-1-虚拟环境管理模块" class="headerlink" title="1.1  虚拟环境管理模块"></a>1.1  虚拟环境管理模块</h4><p><code>virtualenvwrapper</code></p><p>安装</p><p><code>pip install virtualenvwrapper-win</code></p><p><code>virtualenvwrapper</code>的使用</p><p>查看所有虚拟环境：<code>lsvirtualenv</code></p><p>创建虚拟环境：<code>mkvirtualenv 环境名</code></p><p>激活虚拟环境：<code>workon 环境名</code></p><p>查看当前虚拟环境下的模块：</p><ol><li>进入当前虚拟环境</li><li>pip list</li></ol><p>退出虚拟环境:<code>deactivate</code></p><p>虚拟环境中安装模块:<code>pycharm</code>中,选中虚拟环境，然后添加模块,也可以通过<code>pip install</code>安装</p><p>删除虚拟环境：<code>rmvirtualenv 环境名</code></p><blockquote><p><code>pycharm</code>如果没有直接显示虚拟环境，则<br> settings中选解释器处<code>show all</code> ,加号添加，创建的虚拟环境在<br> <code>C:\Users\22742\Envs\</code>目录下，选中Scripts下的<code>python.exe</code></p></blockquote><h4 id="1-2-环境一致性"><a href="#1-2-环境一致性" class="headerlink" title="1.2  环境一致性"></a>1.2  环境一致性</h4><blockquote><p>保证开发与生产环境一致，需要将模块等同一致</p></blockquote><blockquote><p>在开发机的虚拟环境中，运行命令:<br>生成模块和其版本<code>pip freeze &gt; requirements.txt</code></p><p>将<code>requirements</code>中生成的模块版本进行安装<br><code>pip listall -r ./requirements.txt</code></p></blockquote><h4 id="1-3-查看包的详细信息"><a href="#1-3-查看包的详细信息" class="headerlink" title="1.3  查看包的详细信息"></a>1.3  查看包的详细信息</h4><p><code>pip show 包名</code></p><h4 id="1-4-打包"><a href="#1-4-打包" class="headerlink" title="1.4  打包"></a>1.4  打包</h4><p><code>pyinstall -F XXX.py</code></p><hr><h2 id="2-爬虫"><a href="#2-爬虫" class="headerlink" title="2.爬虫"></a>2.爬虫</h2><h4 id="2-1-爬虫的概念"><a href="#2-1-爬虫的概念" class="headerlink" title="2.1  爬虫的概念"></a>2.1  爬虫的概念</h4><blockquote><p>爬虫又称网页蜘蛛或者网页机器人</p><p>模拟人操作客户端，向服务器发起网络请求，抓取数据的自动化程序和脚本</p></blockquote><blockquote><p>通用爬虫是通过抓取数据实现检索服务</p></blockquote><blockquote><p>爬虫分为聚焦爬虫和通用爬虫</p><p>自动化，数据量较小时可以人工获取数据，但往往在公司中爬取的量都在百万级千万级，所以要程序自动化获取数据</p></blockquote><blockquote><p>B/S架构：<code>Browser</code>/<code>Server</code>，类似淘宝，没有第三方中转，客户端和服务器直接交互</p><p>C/S：<code>Client</code>/<code>server</code>，类似微信，将微信后端作为中转站，和其他人对话时，需要在中转站传话</p></blockquote><h5 id="2-1-1-pyinstaller"><a href="#2-1-1-pyinstaller" class="headerlink" title="2.1.1  pyinstaller"></a>2.1.1  <code>pyinstaller</code></h5><p><code>pyinstaller</code>可以将python文件编译成一个程序，类似go语言的编译</p><h4 id="2-2-通用爬虫"><a href="#2-2-通用爬虫" class="headerlink" title="2.2  通用爬虫"></a>2.2  通用爬虫</h4><p>百度，360，搜狐等搜索引擎</p><p>原理：</p><ol><li>抓取网页</li><li>采集数据</li><li>数据处理</li><li>提供检索服务</li></ol><p>通用爬虫抓取新网站的方式</p><ol><li>主动提交<code>url</code></li><li>设置友情连接</li><li>百度会和<code>DNS</code>服务商合作，抓取新网站</li></ol><p>检索排名:</p><ol><li>竞价排名</li><li>根据<code>PageRank</code>值，访问量、点击量   (<code>SEO</code>)</li></ol><h4 id="2-3-robots协议"><a href="#2-3-robots协议" class="headerlink" title="2.3  robots协议"></a>2.3  robots协议</h4><p><code>robots.txt</code>:如果不想让百度爬取，可以编写<code>robots.txt</code>,这个协议只是口头上的协议，自己写的爬虫程序<strong>不需要遵从</strong></p><h4 id="2-4-聚焦爬虫"><a href="#2-4-聚焦爬虫" class="headerlink" title="2.4  聚焦爬虫"></a>2.4  聚焦爬虫</h4><blockquote><p>根据特定的需求，抓取指定的数据</p></blockquote><p>思路：</p><blockquote><p>代替浏览器上网</p><ol><li><code>url</code>，发起请求，获取响应</li><li>解析内容，提取数据</li><li>将数据存储到本地，数据持久化</li></ol></blockquote><h2 id="2-5-requests模块"><a href="#2-5-requests模块" class="headerlink" title="2.5  requests模块"></a>2.5  requests模块</h2><pre class="language-python" data-language="python"><code class="language-python">#导包import requestsurl = '*****'#res是获取的响应数据res = requests.get(url)</code></pre><pre class="language-python" data-language="python"><code class="language-python">#响应数据的获取方式1.文本形式：res.text2.json形式：res.json()3.流形式：res.content</code></pre><pre class="language-python" data-language="python"><code class="language-python">#数据持久化(mysql入库)#1.导包import pymysql#2.创建链接conn = pymysql.connect(host='127.0.0.1',port=3306,user='root',password='root',charset='utf8',database='***')#3.创建游标cursor = conn.cursor()#4.构造sql语句sql  = 'insert into *** values(数据)'#5.执行sql语句try:    cursor.execute(sql)    #提交事务    conn.commit()except Exception as e:    print(e)    #回滚    conn.rollback()</code></pre><p><code>params</code>参数</p><blockquote><p>get方式传参的拼接，将参数拼接到目标<code>url</code>中</p></blockquote><h4 id="2-6-OSI七层模型"><a href="#2-6-OSI七层模型" class="headerlink" title="2.6  OSI七层模型"></a>2.6  <code>OSI</code>七层模型</h4><p>应用层：</p><pre class="language-none"><code class="language-none">https/http/ftphttp协议：明文传输，端口80https协议：加密传输，端口443</code></pre><p>表示层</p><p>会话层</p><p>传输层：<code>UDP/TCP</code></p><p>网络层：<code>IP</code></p><p>数据链路层：<code>ARP</code></p><p>物理层：<strong>以太网协议</strong></p><h4 id="2-7-TCP-IP五层模型"><a href="#2-7-TCP-IP五层模型" class="headerlink" title="2.7  TCP/IP五层模型"></a>2.7  <code>TCP/IP</code>五层模型</h4><p>应用层：<code>https/http/ftp/ssh/Sftp/</code></p><p>传输层：<code>UDP/TCP</code></p><p>网络层：<code>IP</code></p><p>数据链路层：<code>ARP</code></p><p>物理层：<strong>以太网协议</strong></p><h4 id="2-8-TCP和UDP"><a href="#2-8-TCP和UDP" class="headerlink" title="2.8 TCP和UDP"></a>2.8 <code>TCP</code>和<code>UDP</code></h4><p>TCP协议是一种面向连接的，可靠的，基于字节流的传输通信协议</p><ol><li>有序性：数据包编号，判断数据包的正确次序</li><li>正确性：使用checksum函数检查数据包是否损坏，发送和接收时都会计算<strong>校验和</strong></li><li>可靠性：发送端由超时重发，并有确认机制识别错误和数据的丢失</li><li>可控性：<strong>滑动窗口协议</strong>与<strong>拥塞控制算法</strong>控制数据包的发送速度</li></ol><p><code>UDP</code>协议是用户数据报协议，面向无连接的传输层协议，传输<code>相对于TCP</code>来说，不可靠</p><ol><li>无连接：数据可能丢失或损坏</li><li>报文小，传输速度快</li><li>吞吐量大的网络传输，可以在一定成都上承受数据丢失</li></ol><h4 id="2-9-ARP协议"><a href="#2-9-ARP协议" class="headerlink" title="2.9  ARP协议"></a>2.9  <code>ARP</code>协议</h4><p>通过<code>IP</code>获取目标计算机的mac地址的协议</p><blockquote><p>交换机不能识别<code>IP</code>地址</p></blockquote><h5 id="2-9-1-ssh"><a href="#2-9-1-ssh" class="headerlink" title="2.9.1  ssh"></a>2.9.1  ssh</h5><blockquote><p>远程登录会话</p></blockquote><h5 id="2-9-2-服务器创建的默认端口"><a href="#2-9-2-服务器创建的默认端口" class="headerlink" title="2.9.2  服务器创建的默认端口"></a>2.9.2  服务器创建的默认端口</h5><pre class="language-none"><code class="language-none">ftp:21ssh:22mySQL:3306MongoDB:27017Redis:6379</code></pre><h5 id="2-9-3-http与HTTPS协议的区别"><a href="#2-9-3-http与HTTPS协议的区别" class="headerlink" title="2.9.3  http与HTTPS协议的区别"></a>2.9.3  <code>http</code>与<code>HTTPS</code>协议的区别</h5><ol><li><code>https</code>协议需要到ca申请证书，因而需要一定费用，现阶段国内各大厂商也提供免费的证书</li><li><code>http</code>是超文本传输协议，信息是铭文传输，<code>https</code>则是具有安全性的<code>ssl</code>加密传输协议</li><li><code>http</code>和<code>https</code>使用的是完全不同的连接方式，端口号也不一样,前者是80，后者是443</li><li><code>http</code>的连接很简单，是无状态的，<code>https</code>协议是由<code>ssl+http</code>协议构建的可进行加密传输，身份认证的网络协议，比<code>http</code>协议安全(尽管<code>HTTPS</code>安全，但是传输的效率没有<code>http</code>高)</li></ol><hr><h2 id="3-请求"><a href="#3-请求" class="headerlink" title="3.请求"></a>3.请求</h2><p>url:请求的网址，即<strong>统一资源定位符</strong>，它可以唯一确定我门向请求的资源</p><h4 id="3-1-请求过程"><a href="#3-1-请求过程" class="headerlink" title="3.1  请求过程"></a>3.1  请求过程</h4><blockquote><p>客户端，通常指(web浏览器或<code>APP</code>)向服务器发起请求，服务器接收到的请求进行处理，并向客户端发起响应</p></blockquote><blockquote><p>请求由客户端向服务器发出的，可以分为四部分：请求方法(<code>Request Method</code>),请求网址(<code>Request.URL</code>),请求头(<code>Request Headers</code>) 请求体(<code>Request Body</code>)</p></blockquote><h4 id="3-2-请求方法"><a href="#3-2-请求方法" class="headerlink" title="3.2  请求方法"></a>3.2  请求方法</h4><p>常见的有八种</p><pre class="language-none"><code class="language-none">GET：请求页面，并返回内容POST：用于提交表单数据或者文件等，数据包含在请求体中PUT：从客户端向服务器传送的数据取代指定文档中的内容DELETE：请求服务器删除指定的页面HEAD：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取头CONNECT：把服务器当跳板，让服务器代替客户端访问其他网页OPTIONS：允许客户端查看服务器的性能TRACE：会回显服务器收到的请求，主要用于测试或诊断</code></pre><blockquote><p>GET和POST请求的区别</p><ol><li>GET请求中的参数包含在URL里，数据可以在URL中看到，而POST请求的URL一般不会包含这些数据</li><li>GET请求提交的数据最多只有1024字节，而POST方法没有限制</li><li>POST比 GET<strong>相对安全</strong></li></ol></blockquote><h4 id="3-3-请求头和请求体"><a href="#3-3-请求头和请求体" class="headerlink" title="3.3  请求头和请求体"></a>3.3  请求头和请求体</h4><p>Accept：请求报头域，用于指定客户端可接收哪些类型的信息</p><p>Cookie：页常用复数形式<code>Cookies</code>，这是网站为了辨别用户进行会话跟踪而存在用户本地的数据，它的主要功能时维持当前访问会话，cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上cookies并将其发送给服务器，服务器通过cookies识别出是我们自己，并且查出当前是登录状态，所以返回的数据是登录之后网页内容</p><p><code>Referer</code>:此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如来源统计，防盗链处理等</p><p>User-Agent：简称UA，它是一个页数的字段串头，可以使服务器识别客户使用的操作系统及版本，浏览器及版本等信息，做爬虫时加上此信息，可以伪装浏览器</p><p>x-requested-with：<code>XMHttpRequest</code>  代表ajax请求</p><p>Accept-Language：指定客户端可接受的语言类型</p><p>Accept-Encoding：指定客户端可接受的内容编码</p><p>Content-type：也叫互联网媒体类型(Internet Media Type)或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息,例：text/html代表HTML格式，image/<code>gif</code>代表<code>GIF</code>图片，<code>application/json</code>代表JSON类型</p><blockquote><p>请求体一般承载的内容时POST请求中的表单数据，GET请求没有请求体，为空</p></blockquote><h4 id="3-4-反爬机制与反反爬策略"><a href="#3-4-反爬机制与反反爬策略" class="headerlink" title="3.4  反爬机制与反反爬策略"></a>3.4  反爬机制与反反爬策略</h4><pre class="language-python" data-language="python"><code class="language-python">#反爬机制：为了不让数据泄露，设置了各种阻碍，这就是反爬机制#反反爬策略针对网站的反爬机制，采取不同策略1.脚本：直接忽略2.scrapy框架：修改配置文件，让爬虫不遵守robots协议</code></pre><hr><h2 id="4-响应"><a href="#4-响应" class="headerlink" title="4.响应"></a>4.响应</h2><blockquote><p>响应是由服务端返回给客户端的，可 以分为三部分：响应状态码，响应头，响应体</p></blockquote><blockquote><p>响应体，响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的HTML代码，我们要爬虫请求网页后，要解析的内容就是响应体</p></blockquote><h4 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h4><pre class="language-none"><code class="language-none">200：成功301：永久重定向302：临时重定向400：错误的请求401：未授权403：服务器拒绝此请求404：未找到500：服务器内部错误501：服务器不具备完成请求的功能502：错误的网关，服务器走位网关或代理，从上游服务器收到无效响应504：网关超时，服务器作为网关或代理，但是没有及时从上游服务器收到请求505：HTTP版本不支持</code></pre><blockquote><p>状态码不能完全代表相应状态，部分网站的状态码是自定义的，一切以响应数据为准</p></blockquote><h4 id="4-1-响应数据的几种形式"><a href="#4-1-响应数据的几种形式" class="headerlink" title="4.1  响应数据的几种形式"></a>4.1  响应数据的几种形式</h4><pre class="language-python" data-language="python"><code class="language-python">res = requests.get(url='https://www.guidaye.com/cp/')res.text &gt;&gt;&gt;将响应对象转化为str类型res.json()  &gt;&gt;&gt; 将响应对象转化为python中的dict类型，形式(类json)res.content  &gt;&gt;&gt;流形式(数据流，图片就是流形式)</code></pre><blockquote><p>如果响应数据中文乱码，可以用<code>content.decode('utf-8')</code>来解决</p></blockquote><h4 id="4-2-uuid"><a href="#4-2-uuid" class="headerlink" title="4.2  uuid"></a>4.2  uuid</h4><blockquote><p>通用唯一标识符，时间戳，命名空间，随机数，伪随机数来保证生成ID的唯一性</p><p>python的<code>uuid</code>模块提供<code>UUID</code>类和函数<code>uuid1()</code>, <code>uuid3()</code>,<code> uuid4()</code>,<code> uuid5()</code> 来生成1, 3, 4, 5各个版本的<code>UUID</code><br>( 需要注意的是: python中没有**<code>uuid2()</code>**这个函数)</p></blockquote><pre class="language-none"><code class="language-none">uuid1：基于时间戳uuid3：基于名字的MD5散列值uuid4：基于随机数，有一定重复概率uuid5：基于名字的SHA=1散列值</code></pre><hr><h2 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5.正则表达式"></a>5.正则表达式</h2><h4 id="5-1-元字符"><a href="#5-1-元字符" class="headerlink" title="5.1  元字符"></a>5.1  元字符</h4><pre class="language-python" data-language="python"><code class="language-python">.:任意字符，换行符除外\d:任意数字\w:任意数字字母下划线\s:空白符#如果是大写的s，w，d，代表'非'</code></pre><h4 id="5-2-字符组"><a href="#5-2-字符组" class="headerlink" title="5.2  字符组"></a>5.2  字符组</h4><pre class="language-python" data-language="python"><code class="language-python">[a-z]:[A-Z]:[0-9]:[^...]#匹配非其中元素，举例：[^abc]---&gt;匹配除了abc之外的字符</code></pre><h4 id="5-3-量词"><a href="#5-3-量词" class="headerlink" title="5.3  量词"></a>5.3  量词</h4><pre class="language-python" data-language="python"><code class="language-python">*:匹配0次或多次+:匹配1次或多次?:匹配0次或1次  #非贪婪匹配{m}:m次{m,}:至少m次{m,n}:m-n次{,n}:最多n次</code></pre><h4 id="5-4-边界修饰"><a href="#5-4-边界修饰" class="headerlink" title="5.4   边界修饰"></a>5.4   边界修饰</h4><blockquote><p>^匹配开始</p><p>$匹配结尾</p></blockquote><h4 id="5-5-分组"><a href="#5-5-分组" class="headerlink" title="5.5   分组"></a>5.5   分组</h4><pre class="language-python" data-language="python"><code class="language-python">import res = "&lt;a href='asdsdjfiohssdbfkjsdbkjsd'&gt;"res = re.findall(r"href='(.*?)'&gt;",s)</code></pre><h4 id="5-6-贪婪与非贪婪"><a href="#5-6-贪婪与非贪婪" class="headerlink" title="5.6  贪婪与非贪婪"></a>5.6  贪婪与非贪婪</h4><blockquote><p>贪婪，尽可能多的匹配</p><p>非贪婪，尽可能往少了匹配</p></blockquote><h4 id="5-7-re"><a href="#5-7-re" class="headerlink" title="5.7  re"></a>5.7  re</h4><p><code>re.findall(r'正则表达式','str')</code>,结果是一个列表，匹配整个字符串</p><p><code>re.search(r'正则表达式','str')</code>匹配到第一个结果就返回，返回的是一个对象，使用<code>group</code>取值</p><p><code>re.match(r'正则表达式','str')</code>从字符串开始进行匹配，返回一个对象，使用<code>group</code>取值，如果未匹配到，返回None </p><p><code>re.complie</code>将正则表达式编译为<strong>对象</strong>，在需要按正则表达式匹配是可以在直接使用该对象调用以上方法</p><hr><h2 id="6-requests高阶应用"><a href="#6-requests高阶应用" class="headerlink" title="6. requests高阶应用"></a>6. requests高阶应用</h2><h4 id="6-1-文件处理"><a href="#6-1-文件处理" class="headerlink" title="6.1  文件处理"></a>6.1  文件处理</h4><pre class="language-python" data-language="python"><code class="language-python">import requests#打开文件，注意要以rb形式打开f = open('chn.jpg','rb')files = {    'file':f}res = requests.post(url='***',files = files)</code></pre><blockquote><p>文件也是一种数据，所以，可以通过<code>files</code>参数来进行文件的上传</p></blockquote><h4 id="6-2-会话维持"><a href="#6-2-会话维持" class="headerlink" title="6.2  会话维持"></a>6.2  会话维持</h4><pre class="language-python" data-language="python"><code class="language-python">from requests import Session#1.实例化一个对象session = Session()#2.urlurl = '*****'#3.session.get()或者session.post(url=url.headers=headers)res = session.post(url=url.headers=headers)</code></pre><h4 id="6-3-ssl证书验证"><a href="#6-3-ssl证书验证" class="headerlink" title="6.3  ssl证书验证"></a>6.3  <code>ssl</code>证书验证</h4><p><code>https</code>是<code>http</code>的安全版本，<code>HTTPS</code>在<code>http</code>的基础上多了一个<code>ssl</code>安全套接层</p><blockquote><p>requests提供了证书验证的功能，当发起HTTP请求时，模块会检查<code>SSL</code>证书，但检查的行为可以用verify参数来控制</p></blockquote><p>添加了一个参数<code>verify=false   ---&gt;不检查ssl证书</code>,如果等于<code>True</code>，则检查<code>SSL</code>证书</p><pre class="language-python" data-language="python"><code class="language-python">#ssl证书验证#添加一个verify=false参数，禁止证书验证import requestsurl = '******'#阻止抛出警告requests.packages.urllib3.disable_warinings()res = requests.get(url=url,verify=false)</code></pre><blockquote><p>简单来说，在爬取网站时，有可能网站的证书是有问题的，这时如果使用<code>requests</code>模块去请求时，会报错，所以需要<code>ssl</code>证书验证</p></blockquote><h4 id="6-4-代理设置"><a href="#6-4-代理设置" class="headerlink" title="6.4  代理设置"></a>6.4  代理设置</h4><blockquote><p>代理<code>IP</code>是指在请求的过程中使用非本机<code>ip</code>进行请求，避免大数据量频繁请求的过程中出现<code>IP</code>封禁，限制数据的爬取</p></blockquote><p>透明代理<code>ip</code>：服务器知道你使用了代理，服务器能够获取爬虫真实的<code>ip</code></p><p>匿名代理<code>ip</code>：服务器知道你使用了代理，服务器不能获取爬虫真实的<code>ip</code></p><p>高匿代理<code>ip</code>：服务器不知道使用了代理，服务器不能获取爬虫真实<code>ip</code></p><blockquote><p>代理类别：基于接口的，基于隧道的</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">反爬：ip封禁---&gt;使用代理ipimport requestsurl = '*********'proxies = {    #或者是https    'http':'http://ip地址:端口号',    #无论是http还是https，后面一定是http    'https':'http://ip地址:端口号'}res = requests.get(url=url,proxies = proxies)</code></pre><h4 id="6-5-超时设置"><a href="#6-5-超时设置" class="headerlink" title="6.5  超时设置"></a>6.5  超时设置</h4><p>添加了一个参数，以<strong>秒</strong>计量<code>timeout=0.1</code></p><pre class="language-python" data-language="python"><code class="language-python">#添加timeout参数，秒数import requestsres=requests.get(url=url,timeout=0.1)</code></pre><blockquote><p>给予爬虫与服务器连接的时间限定，设置一个时间，在指定的时间内完成了正常的连接，不报错，如果没有完成，就会报错</p><p>requests模块发送请求可以设置超时时间，在超时时间内未得到响应，便会抛出异常</p><p>好处：一方面减少了请求的阻塞时间，一方面，可以进行异常处理，执行相应的操作</p></blockquote><blockquote><p>如果规定时间完成了和服务器连接，之后爬取数据的时间并不算在超时设置的时间内</p></blockquote><h4 id="6-6-UA检测"><a href="#6-6-UA检测" class="headerlink" title="6.6  UA检测"></a>6.6  <code>UA</code>检测</h4><p><code>UA</code>是用户的身份表示，可以表示用户的系统及浏览器信息</p><blockquote><p>在请求过程中，添加headers参数</p></blockquote><h4 id="6-7-cookie的处理-session"><a href="#6-7-cookie的处理-session" class="headerlink" title="6.7  cookie的处理(session)"></a>6.7  cookie的处理(session)</h4><blockquote><p>在同一个关联网页中，为了保存登录状态和各种信息，可以通过cookie来保持</p></blockquote><blockquote><p>三种方法</p><ol><li>手动在headers中添加cookie的键值对</li><li><code>cookiejar</code>对象</li><li>自动封装cookie的类：<code>Session</code></li></ol></blockquote><pre class="language-python" data-language="python"><code class="language-python">#cookie的处理#1.url = 'https://www.baidu.com/'        headers = {            'Cookie':'BIDUPSID=B63BDB40304991E9FF3159864CC9C302; PSTM=1586308511; BAIDUID=B63BDB40304991E9CC4E4ECFFCFFB23D:FG=1; BD_UPN=12314753; BDUSS=VWNmZu',            'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36'        }        res = requests.get(url=url,headers=headers)            #2.cookiejar对象    from requests.cookies import RequestCookieJar   1.首先需要获取Cookies    Cookie = ***********    2.实例化一个jar对象    jar = RequestsCookieJar()    3.处理Cookies，封装进jar对象中    for i in Cookie.split(','):        #再次分割，分成dict的键值，每分割一次添加一次        k,v = i.split('=',1)        jar.set(k,v)        #3.Session类，会话维持    from requests import Session    1.实例化一个对象    session = Session()    2.url    url = '*****'    3.session.get()或者session.post(url=url.headers=headers)    res = session.post(url=url.headers=headers)</code></pre><pre class="language-python" data-language="python"><code class="language-python">from requests import Sessionsession = Session()data = {    'username':"天听",    'password':'123456'}res = session.post(url=url,headers=headers,data=data)</code></pre><hr><h2 id="7-lxm库"><a href="#7-lxm库" class="headerlink" title="7.lxm库"></a>7.<code>lxm</code>库</h2><blockquote><p>从响应数据中抽取出目标数据的过程，就叫做数据解析<br>数据解析：<br><code>re</code>,<code>xpath</code>,<code>BS4</code>,<code>Pyquery</code></p></blockquote><blockquote><p>DOM树与<code>xpath</code>解析原理</p><p>HTML页面标签存在层级关系，即DOM树，在获取目标数据时可以根据网页层级关系定位标签，再获取标签的文本或属性</p><p><code>xpath</code>解析原理：根据DOM节点的结构关系，进行定位</p></blockquote><h4 id="7-1-xpath基本语法"><a href="#7-1-xpath基本语法" class="headerlink" title="7.1  xpath基本语法"></a>7.1  <code>xpath</code>基本语法</h4><p><code>.</code>:当前节点</p><p><code>/</code>:根节点</p><p><code>//</code>:代表任意位置</p><p><code>.//</code>:从当前节点向下的任意位置匹配</p><p><code>nodename</code>:<strong>节点名</strong>定位</p><p><code>nodename[@attribute='value']</code>:根据节点的属性进行定位</p><p><code>@attribue</code>：获取节点的属性值，比如获取a标签的<code>href</code>属性，直接可以<code>/a/@href</code></p><p><code>text()</code>:获取节点的文本<br><code>//div[@class='asdds']/p/text()</code></p><h4 id="7-2-属性匹配"><a href="#7-2-属性匹配" class="headerlink" title="7.2  属性匹配"></a>7.2  属性匹配</h4><ul><li><p>单属性多值匹配：当节点的一个属性有多个值时，根据其中一个进行定位，使用<code>contai ns</code>函数</p><pre class="language-python" data-language="python"><code class="language-python">'//div[contains(@class,"属性值")]'</code></pre></li><li><p>多属性匹配：用节点的多个属性共同定位节点<code>and</code></p><pre class="language-python" data-language="python"><code class="language-python">'//div[@class="asds" and @name="adsadasd"]'</code></pre><h4 id="7-3-按序选择"><a href="#7-3-按序选择" class="headerlink" title="7.3  按序选择"></a>7.3  按序选择</h4></li><li><p>索引定位：[6] </p><blockquote><p><strong>注意，索引从1开始，跟python有区别</strong></p></blockquote></li><li><p>位置函数：<code>position</code><br>例：<code>/li[position()&gt;2]</code></p></li><li><p><code>last()</code>函数：定位最后一个，<code>last()-1</code>代表倒数第二个</p></li></ul><h4 id="7-4-流程"><a href="#7-4-流程" class="headerlink" title="7.4  流程"></a>7.4  流程</h4><p>加载本地<code>html</code>，需要有<code>etree.HTMLParser</code>参数，注意要加括号<br>例：<code>tree = etree.parser('./xpath.html',etree.HTMLParser())</code></p><p>加载网页<code>html</code>,直接使用HTML<br>例：<code>tree = etree.HTML()</code></p><p>然后些<code>xpath</code>语法<br><code>tree.xpath('//ul[@class="pli"]/li/div/a/img/@src')</code></p><p><code>xpath</code>获得的结果是一个列表2  </p><pre class="language-python" data-language="python"><code class="language-python">#编码流程from lxml import etreeres = requests.get(...)tree = etree.HTML(res.text) #etree加载的是响应数据的文本形式tree.xpath('xpath表达式')</code></pre><h4 id="7-5-补充"><a href="#7-5-补充" class="headerlink" title="7.5  补充"></a>7.5  补充</h4><pre class="language-python" data-language="python"><code class="language-python">res1 = tree.xpath("//div[@id='007']/text()")res2 = tree.xpath("//div[@id='007']//text()")'''res1展示的是以divid007为根节点的结果，其div下的其他标签不显示res2展示的是以divid007任意位置的结果，其div下的其他标签内容也一同显示'''</code></pre><hr><h2 id="8-动态数据加载"><a href="#8-动态数据加载" class="headerlink" title="8.动态数据加载"></a>8.动态数据加载</h2><blockquote><p>网页HTML上，有些数据是通过<code>js</code>代码填充，所以如果直接使用爬虫，只会爬取到一个标签，并没有其中的元素</p><p>requests模块和<code>scrapy</code>框架在发起请求爬取数据的过程中，不能执行<code>js</code>代码</p></blockquote><h4 id="8-1-selenium"><a href="#8-1-selenium" class="headerlink" title="8.1  selenium"></a>8.1  selenium</h4><blockquote><p>selenium是一个web端自动化测试框架，可以通过代码来控制浏览器，比如打开关闭，点击等行为</p><p>作用：帮助抓取动态加载的数据，避免反爬</p></blockquote><h4 id="8-2-selenium安装与配置与操作"><a href="#8-2-selenium安装与配置与操作" class="headerlink" title="8.2  selenium安装与配置与操作"></a>8.2  selenium安装与配置与操作</h4><blockquote><ol><li><code>Chrome</code>浏览器</li><li><code>selenium</code>框架：<code>pip install selenium</code></li></ol><p>3.驱动程序：下载<br>   <code>http://npm.taobao.org/mirrors/chromedriver/</code><br>   查看浏览器版本<br>   选择对应的版本</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">编码流程：#首先需要将下载的chromedriver.exe放到代码文件夹下    #导包    from seleniumi import webdriver            #调用chromedriver.exe    bro = webdriver.Chrome('./chromedriver.exe')        #访问    bro.get('https://www.iqiyi.com/')        #获取网页源代码(对象)bro.page_source   ---&gt;字符串</code></pre><pre class="language-python" data-language="python"><code class="language-python">#如何获取网页的元素#根据标签内属性定位，一般用id定位find_element_by_id('id')find_element_by_name('name')find_element_by_class_name('class')#根据class属性定位find_element_by_xpath()#根据xpath定位节点find_element_by_css_selector()#css选择器find_element_by_link_text()#根据超链接文本定位find_element_by_partial_link_text()#根据超链接文本的一部分定位#执行js脚本execute_script(js)#节点交互操作：1.输入内容：对象.send_keys()2.清空内容：对象.clear()3.点击操作：对象.click()4.退出浏览器：对象.quit()#获取网页的数据获取元素属性：get_attribute()获取元素文本：get_text()获取元素位置：element.location获取元素尺寸：element.size获取网页源码：browser.page_source(*****)#执行js脚本js = 'window.scrollTo(0,300)'#向下滚动300距离js = 'window.scrollTo(0,document.body.scrollHeight)'#滚动到底部对象.execute_script(js)</code></pre><h4 id="iframe标签跳转"><a href="#iframe标签跳转" class="headerlink" title="iframe标签跳转"></a><code>iframe</code>标签跳转</h4><p><code>switch_to.frname('frameid')</code></p><p><code>switch_to.default_content()</code></p><p>实例：</p><pre class="language-python" data-language="python"><code class="language-python">from selenium import webdriverfrom time import sleepfrom selenium.webdriver.chrome.options import Optionsoptions = Options()options.add_experimental_option('excludeSwitches',['enable-automation'])#调用chromedriver.exebro = webdriver.Chrome('./chromedriver.exe',options=options)bro.get('https://www.baidu.com/')#根据id--&gt;kw获取input输入框input_tag = bro.find_element_by_id('kw')#根据id--&gt;su获取百度一下点击按钮button_baidu = bro.find_element_by_id('su')#输入框输入input_tag.send_keys('黑洞')#点击button_baidu.click()#睡眠两秒之后清空输入框sleep(2)input_tag.clear()input_tag.send_keys('抖动')button_baidu.click()sleep(3)input_tag.clear()input_tag.send_keys('翻转')button_baidu.click()sleep(3)input_tag.clear()bro.quit()</code></pre><h4 id="8-3-子级页面和父级页面"><a href="#8-3-子级页面和父级页面" class="headerlink" title="8.3  子级页面和父级页面"></a>8.3  子级页面和父级页面</h4><blockquote><p>HTML页面嵌套另一个HTML页面</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">#子页面的跳转switch_to.frame('id')#跳转到父级页面switch_to_default.conent()</code></pre><blockquote><p>注意，selenium默认操作父级页面</p></blockquote><h4 id="8-4-防检测"><a href="#8-4-防检测" class="headerlink" title="8.4  防检测"></a>8.4  防检测</h4><pre class="language-python" data-language="python"><code class="language-python">from selenium.webdriver.chrome.options import Optionsoptions = Options()options.add_experimental_option('excludeSwitches',['enable-automation'])bro = webdriver.Chrome('./chromedriver.exe',options=options)</code></pre><hr><h2 id="9-多线程爬虫"><a href="#9-多线程爬虫" class="headerlink" title="9.多线程爬虫"></a>9.多线程爬虫</h2><blockquote><p>在爬取数据量大的数据时，耗费时间较长，为了提高效率，可采用多线程爬虫，提高效率，但是，多线程不是原子性，操纵数据可能会导致数据紊乱，不安全</p></blockquote><h4 id="9-1-并发与并行"><a href="#9-1-并发与并行" class="headerlink" title="9.1  并发与并行"></a>9.1  并发与并行</h4><blockquote><p>并行：在同一时刻，多个任务同时执行</p><p>并发：在同一时间段内，多个任务同时执行<br>并发时，一般采用了时间片轮转法，即在一个时间段内，给每个程序添加一个时间片，也可以叫做进度条，进度条走完，下一个程序再继续运行，不过时间片轮转时，停顿时间非常的短，所以会造成多个任务同时运行的错误</p></blockquote><h4 id="9-2-示例"><a href="#9-2-示例" class="headerlink" title="9.2  示例"></a>9.2  示例</h4><pre class="language-python" data-language="python"><code class="language-python">from threading import Threadfrom queue import Queueimport requestsfrom lxml import etreeimport pymongofrom threading import Lock#负责爬取的类class SpiderThread(Thread):    def __init__(self, name, url_queue, data_queue):        super().__init__()        self.name = name        self.url_queue = url_queue        self.headers = {            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36'        }        self.data_queue = data_queue    def run(self):        base_url = 'http://xiaohua.zol.com.cn/lengxiaohua/%s.html'        while 1:            try:                page = self.url_queue.get(block=False)                print('%s正在爬取数据' % self.name )                res = requests.get(url=base_url % page, headers=self.headers)                self.data_queue.put(res.text)            except:                break#负责解析的类class ParseThread(Thread):    def __init__(self, name, data_queue, lock):        super().__init__()        self.name = name        self.data_queue = data_queue        self.lock = lock    def run(self):        # 调用解析方法        while 1:            try:                html = self.data_queue.get(block=False)                print('%s 正在解析数据' % self.name)                self.parse(html)            except:                break    def parse(self, html):        tree = etree.HTML(html)        li_list = tree.xpath('//li[@class="article-summary"]')        for li in li_list:            title = li.xpath('.//span[@class="article-title"]/a/text()')            content = ''.join(li.xpath('.//div[@class="summary-text"]//text()'))            if title and content:                data = {                    'title': title[0],                    'content': content                }                with self.lock:                    self.save(data)    def save(self, data):        # 简历连接        conn = pymongo.MongoClient()        db = conn.lilong        table = db.liuyueyang        table.insert_one(data)</code></pre><hr><h2 id="10-无头浏览器与BS4"><a href="#10-无头浏览器与BS4" class="headerlink" title="10.无头浏览器与BS4"></a>10.无头浏览器与<code>BS4</code></h2><h4 id="10-1-无头浏览器"><a href="#10-1-无头浏览器" class="headerlink" title="10.1  无头浏览器"></a>10.1  无头浏览器</h4><blockquote><p>什么是无头浏览器（headless browser），简单来说是一种<strong>没有界面</strong>的浏览器。既然是浏览器那么浏览器该有的东西它都应该有，只是看不到界面而已。我们日常使用浏览器的步骤为：启动浏览器、打开一个网页、进行交互。而无头浏览器指的是我们使用脚本来执行以上过程的浏览器，能模拟真实的浏览器使用场景。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from selenium import webdriverfrom selenium .webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument('--headless')chrome_options.add_argument('--dissble-gpu')bro = webdriver.Chrome(chrome_options = chrome_options)bro.get(******)print(bro.page_source)</code></pre><h4 id="10-2-BS4语法"><a href="#10-2-BS4语法" class="headerlink" title="10.2  BS4语法"></a>10.2  <code>BS4</code>语法</h4><blockquote><p>编码流程：</p><ol><li>导包<code>from bs4 import BeautifulSoup</code></li><li>实例化对象，传两个参数，一个文本，一个解析器，一般为<code>lxml</code><br><code>suop = BeautifulSoup(res.text,'lxml')</code></li><li>选择器解析</li></ol></blockquote><pre class="language-python" data-language="python"><code class="language-python">#bs4编码流程from bs4 import BeautifulSoupsuop = BeautifulSoup(res.text,'lxml')tag = soup.select('css选择器表达式')tag = soup.节点() #节点选择器tag = soup.findall() # 方法选择器</code></pre><pre class="language-python" data-language="python"><code class="language-python">#节点选择器from bs4 import BeautifulSoupsoup = BeautifulSoup(res.text,'lxml')tag = soup.a  #取a标签，只取一个</code></pre><pre class="language-python" data-language="python"><code class="language-python">#方法选择器find_all(name,attrs,text,limit):    soup.findall(name='***')  #根据节点名字定位    soup.findall(attrs={'属性名(scr,class等)':'值'})#根据属性定位，多个属性时，一个即可定位    soup.findall(text=res.compile(r'***'))#根据节点文本定位，返回文本    soup.findall(name='***',limit=2)#只返回两个结果    find(name,attrs,text,limit):区别于find_all，find返回的是一个对象结果    find_all(name=节点名,{attrs:属性值})返回的是一个列表</code></pre><pre class="language-python" data-language="python"><code class="language-python">#css选择器属性选择器：1.根据节点名定位标签：标签选择器soup.select('***(title,a,p等)')2.根据节点的class属性定位：css选择器soup.select('.***')3.根据id定位soup.select('#***')4.嵌套选择：ss = soup.select('ul')#得到的是一个列表for i in ss:    print(i.select("li"))5.层级选择器soup.select('div &gt; ul &gt; li') #单层级选择器，按照顺序找到直属lisoup.select('div li') #多层级选择器，包含了div下的所有li#获取节点的文本或属性obj.string:获取直接子文本，如果节点内有平行的节点，则结果是Noneobj.get_text()：获取子孙节点的所有文本obj['***(属性)']：获取节点属性</code></pre><hr><h2 id="11-快代理网站的模拟登录"><a href="#11-快代理网站的模拟登录" class="headerlink" title="11.快代理网站的模拟登录"></a>11.快代理网站的模拟登录</h2><pre class="language-python" data-language="python"><code class="language-python">from requests import Session#实例化session对象session = Session()#登录的urlurl = 'https://www.kuaidaili.com/login/'#构造数据data = {    'next': '',    'kf5_return_to': '',    'username': '2274201339@qq.com',    'passwd': 'o66.'}#浏览器头headers = {    "User-Agent":'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36'}#用post请求将数据传进去，此时，已经模拟了登录，访问这个网站的其他网页时，会保存登录状态res = session.post(url=url,headers=headers,data=data)#访问时，可以获得到返回的数据，用户名在其中，模拟登录完成ret = session.get(url='https://www.kuaidaili.com/api/checkuser/',headers=headers)print(ret.json())</code></pre><h4 id="11-1-第三方打码平台"><a href="#11-1-第三方打码平台" class="headerlink" title="11.1  第三方打码平台"></a>11.1  第三方打码平台</h4><blockquote><p>我们在模拟登录时，时常会遇到一些验证码代码无法准确的识别不同的验证码，这时，就用到了打码平台，它会将图片上的字符或者数字转成字符串返回给你</p></blockquote><blockquote><p>流程：</p><ol><li>下载验证码图片</li><li>传给第三方打码平台</li><li>进行识别，识别完成之后，传回<code>ret</code></li><li>把<code>ret</code>拿回，构造数据</li></ol></blockquote><blockquote><p>超级鹰平台</p></blockquote><h2 id="12-Scrapy框架"><a href="#12-Scrapy框架" class="headerlink" title="12.Scrapy框架"></a>12.<code>Scrapy</code>框架</h2><blockquote><p><code>scrapy</code>是基于<code>twisted</code>的异步框架</p></blockquote><h4 id="12-1-安装"><a href="#12-1-安装" class="headerlink" title="12.1  安装"></a>12.1  安装</h4><blockquote><p>首先需要安装相应的依赖库</p><p><code>lxml</code>、<code>wheel</code>、<code>pywin32</code></p><p><code>twisted</code>此依赖安装时，需要从<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted">地址</a>下载相应的版本,然后通过<code>pip</code>来安装</p></blockquote><blockquote><p>最后安装<code>scrapy</code>框架</p></blockquote><h4 id="12-2-创建项目"><a href="#12-2-创建项目" class="headerlink" title="12.2  创建项目"></a>12.2  创建项目</h4><blockquote><p>创建项目<br><code>scrapy startproject 项目名</code></p></blockquote><blockquote><p>创建爬虫文件<br><code>scrapy genspider 爬虫名 域名</code></p></blockquote><h4 id="12-3-运行项目"><a href="#12-3-运行项目" class="headerlink" title="12.3  运行项目"></a>12.3  运行项目</h4><p><code>scrapy  crawl 爬虫名</code></p><h4 id="12-4-项目基本架构"><a href="#12-4-项目基本架构" class="headerlink" title="12.4  项目基本架构"></a>12.4  项目基本架构</h4><p>└── <code>day01(A)</code>  外层项目目录<br>        └── <code>day01(A)</code>  内层项目目录<br>            └── <code>spiders</code>  放置爬虫的包<br>                └── <code>__init__.py</code><br>                └── <code>tianting.py</code>  爬虫文件   </p><p>​            └── <code>items.py</code>   定义要爬取的数据字段<br>​            └── <code>middlewares.py</code>  中间件<br>​            └── <code>piplines.py</code>  管道<br>​            └── <code>settings.py</code>  配置文件(爬虫配置)<br>​        └── <code>scrapy.cfg</code>  配置文件,跟部署相关</p><h4 id="12-5-核心组件与数据流向"><a href="#12-5-核心组件与数据流向" class="headerlink" title="12.5  核心组件与数据流向"></a>12.5  核心组件与数据流向</h4><h5 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h5><blockquote><p>五大核心组件</p><p>1.引擎(<code>Scrapy Engine</code>)：<br>整个框架的调度，负责各个组件之间的通信与数据的传递</p><p>2.爬虫(<code>Spiders</code>)：<br>定义爬取行为和解析规则</p><p>3.调度器(<code>Scheduler</code>)：<br>负责调度所有请求</p><p>4.下载器(<code>Downloader</code>)：<br>负责爬取页面(与互联网交互，爬取页面的)</p><p>5.管道(<code>Item Pipeline</code>)：<br>负责数据持久化</p></blockquote><blockquote><p>由于引擎负责各个组件之间的调度，所以，所有的组件在相互传递时，都需要经过引擎，比如，爬虫解析后需要将<code>req</code>给引擎，然后引擎再给调度器，<strong>注意</strong>，此时，调度器<strong>无法</strong>越过引擎去直接调用下载器，所以，需要将<code>req</code>再次返回给引擎，由引擎来调度下载器和互联网交互</p></blockquote><h5 id="数据流向"><a href="#数据流向" class="headerlink" title="数据流向"></a>数据流向</h5><blockquote><p>依据请求的生命周期</p></blockquote><p>​                【调度器】</p><p>​                    ↑        ↓<br>​                <code>2.req  3.req  4.req</code></p><p>【管道】    【引擎】        →    【下载器】 <code>5.req</code>    → <code>internet</code><br>                                ←<code>7.res</code>            ←<code>6.res</code>    </p><p>​                        ↑      ↓<br>​                    <code>1.req  8.res</code></p><p>​                【爬虫】</p><blockquote><p>9.爬虫经过引擎到达管道 </p></blockquote><h4 id="12-6-组件分析"><a href="#12-6-组件分析" class="headerlink" title="12.6   组件分析"></a>12.6   组件分析</h4><ul><li><p>爬虫组件</p></li><li><blockquote><p><code>xpath</code>选择器，<code>extract_first</code>返回第一个数据，如果不加<code>first</code>，则是返回所有数据</p></blockquote></li></ul><blockquote><p><code>scrapy.Spider</code>:Spider爬虫类，自建的爬虫类必须继承这个</p><p>将数据item在组件中传递，<strong>注意</strong>不是return，而是<code>yield</code></p></blockquote><blockquote><p>实例化item,两种方法，一种是实例化对象，另一种是直接<code>yield 类名(字段名=值)</code></p></blockquote><pre class="language-python" data-language="python"><code class="language-python">class BlogSpider(scrapy.Spider):    #爬虫名，爬虫唯一的身份标识，不可重复    name = 'blog'    #域名的限定，限制了爬虫的范围，可以注释    # allowed_domains = ['baidu.com']    #起始url，当项目启动，自动对这个url发起请求    start_urls = ['http://baidu.com/']    #parse是默认的解析回调方法，如果发送一个请求，未指定回调解析，默认调用parse    def parse(self,response):        li_list = response.xpath('//ul[@id="menu-list"]/li')        for li in li_list:            item = Test01Item()            #名字            item['title'] = li.xpath('.//h2/a/@title').extract_first()            #简介            item['brief'] = ''.join(li.xpath('./text()').extract()).replace('\n','')            #时间            item['date'] = re.findall(r'\d+-\d+-\d+', li.xpath('.//p/text()').extract_first())[0]            #链接            item['link'] = li.xpath('.//h2/a/@href').extract_first()            yield item                        #第二种实例化方法            yield Test01Item(title=title)</code></pre><ul><li>item</li></ul><blockquote><p>Item 是保存爬取数据的容器，它的使用方法和字典类似,Item 多了额外的保护机制，可以避免拼写错误或者定义字段错误。<br>建 <code>Item</code>需要继承<code> scrapy.Item</code>类，并且定义类型为<code> scrapy.Field</code>字段 </p></blockquote><blockquote><p>注意！！items只能够通过字典的方式进行访问和添加</p></blockquote><p>在爬虫组件中使用item容器，需要以下4步：</p><ol><li>导包，将items导入</li><li>实例化items中的类对象</li><li>通过键值对的字典形式将数据添加进items</li><li>通过yield将items返回</li></ol><pre class="language-python" data-language="python"><code class="language-python">class Test01Item(scrapy.Item):    title = scrapy.Field()    jianjie = scrapy.Field()    #爬虫组件中：item = Test01Item()            #名字item['title'] = li.xpath('.//h2/a/@title').extract_first()    #简介item['brief'] = ''.join(li.xpath('./text()').extract()).replace('\n','')    #时间item['date'] = re.findall(r'\d+-\d+-\d+', li.xpath('.//p/text()').extract_first())[0]    #链接item['link'] = li.xpath('.//h2/a/@href').extract_first()    yield item</code></pre><ul><li>管道(<code>pipelines</code>)</li></ul><blockquote><p>在管道中，主要实现数据的保存，在自定义类中，实现process_item方法，参数有item，spider</p></blockquote><blockquote><p>如果爬虫组件中，传出了item，那么就需要将item走过这个process_item方法</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">#数据库的连接conn = pymongo.MongoClient('localhost',27017)db = conn.Longtantable = db.ss#自定义类class TextPipline:#实现process_item方法,item就是爬虫组件中传来的item    def process_item(self,item,spider):        table.insert_one(dict(item))        return item</code></pre><ul><li>settings</li></ul><blockquote><p>需要修改的是<code>ROBOTSTXT_OBEY</code>,<code>UA</code>,</p><pre class="language-python" data-language="python"><code class="language-python">ITEM_PIPELINES = {   'test01.pipelines.TextPipline': 300,}</code></pre></blockquote><h4 id="12-7-保存数据"><a href="#12-7-保存数据" class="headerlink" title="12.7  保存数据"></a>12.7  保存数据</h4><p>保存到<code>json</code>中</p><pre class="language-python" data-language="python"><code class="language-python">scrapy crawl 爬虫名 -o blog_data.json</code></pre><blockquote><p>另外，也可以每一个Item输出一行<code>JSON</code>,输出后缀改为<code>jl</code>，命令:<code>scrapy crawl 爬虫名 -o blog_data.jl</code></p></blockquote><p>此外，输出还支持<code>csv、xml、pickle、marshal</code>，还支持了远程<code>ftp、s3</code>等输出</p><blockquote><p>注意，<code>ftp</code>输出需要正确配置用户名、密码、地址、输出路径，否则会报错</p></blockquote><h4 id="12-8-管道-Item-Pipline-的使用"><a href="#12-8-管道-Item-Pipline-的使用" class="headerlink" title="12.8  管道(Item Pipline)的使用"></a>12.8  管道(<code>Item Pipline</code>)的使用</h4><blockquote><p>注意，<code>pipline</code>是需要被注册的</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">1. 在settings中，解封或者重新在底下写上ITEM_PIPELINES = {   'test01.pipelines.TextPipline': 300,#项目名.pipelines.自定义的管道名:}# 300：代表着优先级，数字越小，代表着优先级越高</code></pre><blockquote><p>当<code>Item</code>生成后，它会自动被送到管道进行处理，我们常用管道来实现以下:</p><ul><li>清理HTML数据</li><li>验证爬取数据，检查爬取字段</li><li>查重并丢弃重复内容</li><li>将爬取结果保存到数据库中</li></ul></blockquote><pre class="language-python" data-language="python"><code class="language-python">class Test01Pipeline:    def process_item(self, item, spider):        return item</code></pre><h4 id="12-9-整体流程"><a href="#12-9-整体流程" class="headerlink" title="12.9  整体流程"></a>12.9  整体流程</h4><blockquote><ol><li>需要在items中，定义要爬取的字段</li><li>在爬虫组件中，定义要爬取的<code>url</code>和解析规则</li><li>在<code>settings</code>中，配置相关的参数</li><li>在<code>pipeline</code>中，自定义类,实现<code>process_item</code>方法<br>在爬虫组件生成的item，通过了<code>yield</code>传递到<code>process_item</code>方法中</li><li>将数据保存在<code>MongoDB、mysql</code>等数据库中,也可以将数据保存到<code>json</code>等文件里</li></ol></blockquote><h4 id="12-91-手动发送请求"><a href="#12-91-手动发送请求" class="headerlink" title="12.91  手动发送请求"></a>12.91  手动发送请求</h4><blockquote><p><code>srcapy</code>框架在启动时，会自动对起始<code>url</code>发起请求，是因为爬虫组件继承的<code>scrapy.Spider</code>实现了一个<code>start_requests</code>方法，所以，想要手动发送请求，需要自己在类中实现此方法，这样，便不会再自动继承父类的方法，而是从自己类中实现方法</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">#手动发送get请求#callback参数，是指定回调，如果不指定此参数，就会默认回调到parseyield scrapy.Request(url=url,callback=self.parse)#手动发送post请求yield scrapy.FormRequest(url=next_page,formdata=data)</code></pre><h4 id="12-92-中间件"><a href="#12-92-中间件" class="headerlink" title="12.92  中间件"></a>12.92  中间件</h4><h5 id="篡改UA"><a href="#篡改UA" class="headerlink" title="篡改UA"></a>篡改<code>UA</code></h5><blockquote><p>需要用到的模块<code>fake-useragent</code>，用<code>pip</code>安装</p></blockquote> <pre class="language-python" data-language="python"><code class="language-python">#在middlewares中，TestIpUaDownloaderMiddleware下载器中间件中，#导包from fake_useragent import UserAgent#实例化对象ua = UserAgent()def process_request(self, request, spider):    request.headers['User-Agent'] = ua.random    return Noneua.random#生成的ua是随机的</code></pre><blockquote><p>注意，需要把<code>settings</code>中的<code>DOWNLOADER_MIDDLEWARES</code>打开</p></blockquote><h5 id="篡改ip"><a href="#篡改ip" class="headerlink" title="篡改ip"></a>篡改<code>ip</code></h5><pre class="language-python" data-language="python"><code class="language-python">def process_request(self, request, spider):    #篡改ip    request.meta['proxy'] = 'http://ip:port'    return None</code></pre><h5 id="selenium的使用"><a href="#selenium的使用" class="headerlink" title="selenium的使用"></a><code>selenium</code>的使用</h5><blockquote><ol><li>拦截res响应，在<code>process_response</code>方法中</li><li>使用<code>selenium</code>抓取数据</li><li>构建一个响应对象</li><li>替换原有的响应对象</li></ol></blockquote><blockquote><p>注意！如果在中间件中实例化对象，那么，每次请求都会实例化对象，比较耗费资源，所以，最好在爬虫组件中实例化</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">#爬虫组件中from selenium import webdriver#构建响应对象from scrapy.http import HttpResponsebro = webdriver.Chrome(executable_path='设置绝对路径')#中间件中，使用方法process_response自带的spider参数，从爬虫组件可以直接传过去bro = spider.brobro.get(url=response.url)#设置滚动一屏脚本js = 'window.scrollTo(0,document.body.scrollHeight)'#执行js脚本bro.execute_script(js)#网页源码html = bro.page_source#自己构建响应对象myres = HttpResponse(url=response.url,body=html,encoding='utf-8',request=request)#替换原来的响应对象return myres</code></pre><blockquote><p>根据需要添加判断是否使用<code>selenium</code></p></blockquote><h4 id="12-93-meta传值"><a href="#12-93-meta传值" class="headerlink" title="12.93  meta传值"></a>12.93  <code>meta</code>传值</h4><blockquote><p>在爬虫组件中，如果回调解析方法之间相互传值，可以使用<code>meta</code></p></blockquote><pre class="language-python" data-language="python"><code class="language-python">def parse(self,response):    ...    yield scrapy.Request(url=url,callback=self.da_parse,meta={'title':title})    def da_parse(self,response):    title = response.meta['title']</code></pre><h4 id="12-94-全站数据爬取"><a href="#12-94-全站数据爬取" class="headerlink" title="12.94   全站数据爬取"></a>12.94   全站数据爬取</h4><blockquote><p>全站数据爬取就是爬取多页时自动帮助翻页，省去了写代码的时间</p></blockquote><blockquote><p>创建爬虫文件时，在<code>genspider</code>后，添加<code>-t crawl</code>再添加爬虫名和域名，这样，爬虫会成为一个全站爬虫</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">#链接提取器，根据给定的规则进行链接的提起link = LinkExtractor(allow=r'Items/')    rules = (        #规则解析器，根据给定的规则解析数据，follow是递归提取页码，就是逐级访问url，对各个url来追踪访问        Rule(link,callback='parse_item', follow=True),    )</code></pre><h4 id="12-95-增量式爬虫"><a href="#12-95-增量式爬虫" class="headerlink" title="12.95  增量式爬虫"></a>12.95  增量式爬虫</h4><blockquote><p>增量式就是自写爬虫监控目标网站，如果目标有更新的数据，则将更新的数据爬取下来，已经爬取的数据，则通过去重的方式来忽略</p></blockquote><blockquote><p>而这其中，又分为两种去重方式，分别是根据<code>url</code>去重和数据指纹去重</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from redis import Redisconn = Redis('127.0.0.1',6379)def detail_parse(self,response):    name = li.xpath('//text()')    content = li.xpath('//text()')    #连起来生成指纹    data = name+content    fp = md5(data.encode('utf-8')).hexdigest()    #添加进redis的集合中    conn.sadd('ggsfp',fp)    #如果返回结果为0，则证明已经添加过，如果为1，则没有添加过</code></pre><p>对应<code>day14</code>视频</p><hr><h2 id="13-MongoDB数据库"><a href="#13-MongoDB数据库" class="headerlink" title="13.MongoDB数据库"></a>13.<code>MongoDB</code>数据库</h2><h4 id="13-1-数据库操作"><a href="#13-1-数据库操作" class="headerlink" title="13.1  数据库操作"></a>13.1  数据库操作</h4><blockquote><ol><li>创建数据库并切换至该数据库下<br><code>use 库名</code></li><li>查看当前数据库<br><code>db</code></li><li>查看所有数据库，只能显示<strong>非空</strong>的数据库<br><code>show dbs</code></li><li>创建表<br><code>db.creaeteCollection('表名')</code></li><li>插入数据,如果没有这个表，会自动创建<br><code>db.表名.insert({'字段':'值})</code></li><li>查询所有数据<br><code>db.表名.find()</code></li><li>查看所有表<br><code>show tables</code></li><li>删除表<br><code>db.表名.drop()</code></li><li>删除库<br><code>db.表名.dropDatabase()</code></li></ol></blockquote><h4 id="13-2-增加数据"><a href="#13-2-增加数据" class="headerlink" title="13.2  增加数据"></a>13.2  增加数据</h4><blockquote><p>字段多少是单独的那条数据，不一致也没有关系</p><p>例如：</p><p>{‘name’:’玛卡巴卡’}—{‘name’:’海绵宝宝’,’age’:200}</p></blockquote><ol><li><code>db.表名.insertOne({'字段名':'值})</code></li><li><code>db.表名.insert({'字段':'值})</code></li><li><code>db.表名.insertMany([{'字段':'值},{'字段':'值}])</code></li></ol><h4 id="13-3-查询数据"><a href="#13-3-查询数据" class="headerlink" title="13.3  查询数据"></a>13.3  查询数据</h4><ul><li>简单查询<br><code>db.表名.find()</code></li><li>分页，返回2条查询数据<br><code>db.表名.find({}).limit(2)</code></li><li>排序，*<strong>1**<em>是升序，</em></strong>-1***是降序<br><code>db.表名.find().sort({'price':1})</code></li></ul><blockquote><p>等值查询</p></blockquote><ul><li><p>等值查询（按照条件查询）<br><code>db.表名.find({'price':4.5})</code></p></li><li><p>非等值查询（范围查询）</p></li><li><p><code>({'price':{'$lt':500,'$gt':100}})#小于500，大于100</code></p></li><li><p><strong><em>或</em></strong>查询<br><code>db.表名.find({$or:[{'price':{'$lt':5.5}},{'price':{$gt:500}} ]})</code></p></li><li><pre class=" language-python"><code class="language-python"><span class="token operator">></span>   <span class="token operator">==</span> $gt  <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'price'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>$gt<span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#价格大于100的</span><span class="token operator">&lt;</span>   <span class="token operator">==</span> $lt  <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'price'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>$lt<span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#价格小于100的</span><span class="token operator">&lt;=</span>  <span class="token operator">==</span> $lte <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">>=</span>  <span class="token operator">==</span> $gte <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">!=</span>  <span class="token operator">==</span> $ne  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre></li></ul><blockquote><p>模糊查询</p></blockquote><ul><li><code>db.表名.find({'字段名':{$regex:'正则表达式'}})</code></li></ul><h4 id="13-4-修改数据"><a href="#13-4-修改数据" class="headerlink" title="13.4  修改数据"></a>13.4  修改数据</h4><p><code>db.表名.update({'price':2.5},{$set:{'price':500}})</code></p><h4 id="13-5-删除数据"><a href="#13-5-删除数据" class="headerlink" title="13.5  删除数据"></a>13.5  删除数据</h4><p><code>db.表名.remove({'name':'玛卡巴卡'})</code></p>]]></content>
      
      
      <categories>
          
          <category> spider </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PayPal跨境支付</title>
      <link href="2019/04/17/paypal-kua-jing-zhi-fu/"/>
      <url>2019/04/17/paypal-kua-jing-zhi-fu/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是PayPal"><a href="#什么是PayPal" class="headerlink" title="什么是PayPal"></a>什么是PayPal</h2><blockquote><p>PayPal又称为贝宝，是一种外贸支付方式，目前在国际的贸易支付中有着极高的地位，它就好像中国的支付宝，都是第三方支付平台。</p><p>PayPal的优势是，其业务网络遍布全球。目前PayPal的庞大网络覆盖了全球200多个国家，可提供20多种语言服务，并接受100多种货币付款和56种货币提现。</p></blockquote><ul><li>需要注意的一点是，也是我个人感觉非常好的一个地方，PayPal的支付逻辑，是一个事务性的操作，一旦开始，除非获取到支付成功的返回凭证，否则一致就认为没有成功，支付宝就不是这样，它是支付时生成订单，无论是否付款，订单都已经生成了，这样的话，在付款的一瞬间，啪，网断了，支付宝有可能会出现错误，可能是支付状态未修改啊，或者三方卖家没有收到支付成功请求啊一类的。</li><li>但是，支付宝也有避免错误的方法，就是对所有唤起收银台交易的状态码<code>10003</code>发起轮询，轮询间隔未3秒，在让用户再次支付前，必须通过查询确认当前订单的 状态</li></ul><h2 id="注册PayPal和开发者平台"><a href="#注册PayPal和开发者平台" class="headerlink" title="注册PayPal和开发者平台"></a>注册PayPal和开发者平台</h2><p><a href="https://www.paypal.com/">官网地址</a></p><p><a href="https://developer.paypal.com/developer/accounts/">开发者平台</a></p><hr><p>注册成功后，会默认创建两个账号，一个是个人的，一个商户的，如果不想用默认的，可以自己创建</p><img src="/2019/04/17/paypal-kua-jing-zhi-fu/image-20201129103836488.png" alt="" style="zoom:67%;" loading="lazy"><p> 进入应用管理，可以看到，它也给创建了默认的应用</p><img src="/2019/04/17/paypal-kua-jing-zhi-fu/image-20201129104223976.png" alt="" style="zoom:50%;" loading="lazy"><p>然后获取Client ID和Secret</p><img src="/2019/04/17/paypal-kua-jing-zhi-fu/image-20201129104436414.png" alt="" style="zoom:50%;" loading="lazy"><p>然后回来修改一下个人账户的余额和密码</p><img src="/2019/04/17/paypal-kua-jing-zhi-fu/image-20201129105355410.png" alt="" style="zoom:50%;" loading="lazy"><p><img src="/2019/04/17/paypal-kua-jing-zhi-fu/image-20201129105446465.png" alt="" style="zoom:50%;" loading="lazy"><img src="/2019/04/17/paypal-kua-jing-zhi-fu/image-20201129105524864.png" alt="" loading="lazy"></p><img src="/2019/04/17/paypal-kua-jing-zhi-fu/image-20201129105524864.png" alt="" style="zoom:50%" loading="lazy"><hr><h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><pre class="language-python" data-language="python"><code class="language-python">pip install paypalrestsdk</code></pre><p>先安装paypal的sdk</p><p>然后新建app，注册好路由和应用，然后view中的代码</p><pre class="language-python" data-language="python"><code class="language-python">import paypalrestsdkfrom django.http import HttpResponsefrom django.shortcuts import redirectClient_id = '你的Client_id'Secret = '你的Secret'def payment(request):    paypalrestsdk.configure({      "mode": "sandbox", # sandbox代表沙盒      "client_id": Client_id,      "client_secret": Secret,    })    payment = paypalrestsdk.Payment({        "intent": "sale",        "payer": {            "payment_method": "paypal"},        "redirect_urls": {            "return_url": "http://192.168.1.157:8000/palpay/pay/", # 支付成功跳转页面            "cancel_url": "http://192.168.1.157:3000/paypal/cancel/"}, # 取消支付页面        "transactions": [{            "amount": {                "total": "5.00", # 付款金额                "currency": "USD"}, # 货币类型            "description": "这是一个订单测试"}]})    if payment.create():        print("Payment created successfully")        for link in payment.links:            if link.rel == "approval_url":                approval_url = str(link.href)                print("Redirect for approval: %s" % (approval_url))                return redirect(approval_url)    else:        print(payment.error)        return HttpResponse("支付失败")</code></pre><p>启动项目，网页访问该视图，即可看到这样</p><img src="/2019/04/17/paypal-kua-jing-zhi-fu/image-20201129112525018.png" alt="image-20201129112525018" style="zoom:50%;" loading="lazy"><p>点击继续，可以看到，回调的地址传来了三个参数</p><pre class="language-none"><code class="language-none">http://192.168.1.157:8000/palpay/pay/?paymentId=PAYID-L7BRGHA28162157FN083293V&amp;token=EC-1S659222KF8901217&amp;PayerID=QFV2E28KASNQS</code></pre><p>支付id,token和支付者id</p><hr><p>然后，我们写一个回调方法，需要通过支付者id进行确认验证支付</p><pre class="language-python" data-language="python"><code class="language-python">def payment_execute(request):    paymentid = request.GET.get("paymentId") #订单id    payerid = request.GET.get("PayerID")  #支付者id    payment = paypalrestsdk.Payment.find(paymentid)print(payment)    if payment.execute({"payer_id": payerid}):        print("Payment execute successfully")        return HttpResponse("支付成功")    else:        print(payment.error) # Error Hash        return HttpResponse("支付失败")</code></pre><p>然后点击支付即可看到，少了五块钱</p><img src="/2019/04/17/paypal-kua-jing-zhi-fu/image-20201129114412124.png" alt="" style="zoom:50%;" loading="lazy"><p>然后有些时候需要对交易进行一些核对，也可以通过接口查看交易明细，也就是上面的<code>payment</code></p>]]></content>
      
      
      <categories>
          
          <category> PayPal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> PayPal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Docker配置Elasticsearch全文检索</title>
      <link href="2019/03/24/ji-yu-docker-pei-zhi-elasticsearch-quan-wen-jian-suo/"/>
      <url>2019/03/24/ji-yu-docker-pei-zhi-elasticsearch-quan-wen-jian-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>什么是搜索，这是一个相当简单的问题了，就是根据一个搜索词来检索出所有包含该词的数据。我们一般使用<code>mysql</code>数据搜索都是通过模糊搜索来查询，但是这样就会面临一个性能问题，假如数据量超多，这样的搜索无异于自杀。</p><p>基于文档式的全文检索引擎相信大家都不陌生，<code>Elasticsearch</code>诞生的本意是为了解决文本搜索太慢的问题，ES会默认将所有的输入内容当作字符串来理解，对于字段类型是keyword或者text的数据比较友好。</p></blockquote><p>我们已经提到，<code>Elasticsearch</code>专为字符串搜索而生，在建立索引的时候针对字符串进行了非常多的优化，在对字符串进行准确匹配或者前缀匹配等匹配的时候效率是很高的。</p><p>谈论到搜索引擎，就一定会涉及到两个概念，正向索引和反向索引。听上去这是两个完全不同的数据结构。但是实际上，正向索引就好比我们的书籍，每本书都有目录，这就是一种正向索引，能够通过文档去查找关键词。</p><p>而反向索引，和正向索引是完全相反的，它将关键词作为索引， 去查找哪个文档包含了这个关键词，就拿上边的例子，正向索引是通过楼层去找店铺，而反向索引，就是你知道店铺的某一个字，商场导航给你提供了包含这个字的所有店铺，这样就极大的缩小了查找范围。</p><hr><h2 id="Docker配置"><a href="#Docker配置" class="headerlink" title="Docker配置"></a>Docker配置</h2><p>拉取镜像</p><pre class="language-python" data-language="python"><code class="language-python">docker pull elasticsearch:7.2.0</code></pre><p>运行镜像</p><pre class="language-python" data-language="python"><code class="language-python">docker run --name es -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -d elasticsearch:7.2.0</code></pre><blockquote><p>容器别名我们就用缩写es来替代，通过 9200 端口并使用<code>Elasticsearch</code>的原生传输协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群，运行模式先走单节点模式。</p></blockquote><p>此时，我们如果要加一些功能，就得改一些配置，就好像<code>django</code>的Settings配置一样。</p><p>Docker提供了<code>cp</code>命令来拷贝容器内部的文件</p><p>我们只要拷贝<code>elasticsearch.yml</code></p><pre class="language-python" data-language="python"><code class="language-python">docker cp 容器id:/usr/share/elasticsearch/config/elasticsearch.yml ./elasticsearch.yml</code></pre><p>也可以将文件拷贝路径指定为绝对路径</p><p>打开文件，可以加一些自己的配置</p><pre class="language-python" data-language="python"><code class="language-python">cluster.name: "docker-cluster"network.host: 0.0.0.0http.cors.enabled: truehttp.cors.allow-origin: "*"</code></pre><p>然后停止正在运行的容器，并且删除它</p><pre class="language-none"><code class="language-none">docker stop 容器iddocker rm $(docker ps -a -q)</code></pre><p>再次启动，只不过不同的是，这次我们需要通过-v命令把我们刚刚修改的文件配置挂载到容器内部去。</p><pre class="language-none"><code class="language-none">docker run --name es -v E:\elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -d elasticsearch:7.2.0</code></pre><p>这里需要注意一点，就是在Win10宿主机里需要单独设置一下共享文件夹，这里我设置的共享文件夹叫做es，如果是Centos或者Mac os就直接写真实物理路径即可。</p><img src="/2019/03/24/ji-yu-docker-pei-zhi-elasticsearch-quan-wen-jian-suo/image-20201201223246321.png" alt="" style="zoom:80%;" loading="lazy"><p>随后，重启Docker，输入命令进入默认容器：docker-machine ssh default</p><p>在容器根目录能够看到刚刚设置的共享文件夹，就说明设置成功了。</p><p>另外还有一个需要注意的点，就是Elasticsearch存储数据也可以通过-v命令挂载出来，如果不对数据进行挂载，当容器被停止或者删除，数据也会不复存在，所以挂载后存储在宿主机会比较好一点，命令是：</p><pre class="language-python" data-language="python"><code class="language-python">docker run --name es -v /es/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /es/data:/usr/share/elasticsearch/data -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -d elasticsearch:7.2.0</code></pre><h2 id="python配置"><a href="#python配置" class="headerlink" title="python配置"></a>python配置</h2><p>首先安装<code>pip3 install elasticsearch</code></p><p>建立检索实例</p><pre class="language-python" data-language="python"><code class="language-python">from elasticsearch import Elasticsearch es = Elasticsearch(hosts=[{"host":'Docker容器所在的ip', "port": 9200}])</code></pre><p>建立索引</p><pre class="language-python" data-language="python"><code class="language-python"># 建立索引result = es.indices.create(index='godhearing', ignore=400)print(result)</code></pre><p>删除索引</p><pre class="language-python" data-language="python"><code class="language-python">result = es.indices.delete(index='godhearing', ignore=[400, 404])print(result)</code></pre><p>插入数据</p><pre class="language-python" data-language="python"><code class="language-python">data = {'title': '天听', 'url': 'http://123.com','content':"好耶耶耶"}result = es.index(index='godhearing',body=data)print(result)</code></pre><blockquote><p>index()方法会自动生成一个唯一id</p><p>也可以使用create()方法创建数据<br>不同的是create()需要手动指定一个id</p></blockquote><p>修改数据</p><pre class="language-python" data-language="python"><code class="language-python">data = {'content':"啊哈哈哈哈哈哈哈嗝！"}result = es.index(index='godhearing',body=data, id='插入数据时返回的id')print(result)</code></pre><blockquote><p>修改之后，仅剩余此字段</p></blockquote><p>删除数据</p><pre class="language-python" data-language="python"><code class="language-python">result = es.delete(index='godhearing',id='插入数据时的ID')print(result)</code></pre><p>查询数据</p><pre class="language-python" data-language="python"><code class="language-python">result = es.search(index='godhearing')print(result)</code></pre><p>全文检索</p><pre class="language-python" data-language="python"><code class="language-python">mapping = {    'query': {        'match': {            'content': '嗝'        }    }}result = es.search(index='godhearing',body=mapping)print(result)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux终端测试接口</title>
      <link href="2018/11/01/linux-zhong-duan-ce-shi-jie-kou/"/>
      <url>2018/11/01/linux-zhong-duan-ce-shi-jie-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>假如说，你只有一个linux终端来测试你的代码，你是不是瞬间觉得没有了梦想，发送参数，发送不同的请求，甚至查看返回结果，你面对的只有无穷无尽的黑色和白色的代码，是不是很绝望，今日带来一篇攻略，让你仅仅凭借一个终端来测试你的代码</p></blockquote><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><blockquote><p>访问接口，除了写脚本测试之外，还可以直接使用终端来进行测试，具体我们要使用的命令，就是<code>curl</code></p><p>这个命令可以访问网址，但是，他会返回的只有网页的源代码，所以，一般你访问完了，会看到这种情况</p></blockquote><img src="/2018/11/01/linux-zhong-duan-ce-shi-jie-kou/image-20201225134708278.png" alt="" style="zoom:50%;" loading="lazy"><p>虽然可以查看到，但是也很不利于你的查看，所以，我们需要将<code>curl</code>命令后面，加上一个<code>&gt;</code>，紧接着，跟上你保存的文件名字，这样，他就会将访问的网页给你保存下来，像这样</p><pre class="language-none"><code class="language-none">curl http://baidu.com &gt; baidu.html</code></pre><p>随后，你就会看到一个网页就保存下来了</p><p>其次，我们写的接口不只是get，还有其他的请求方法，这样该怎么做呢，只需添加一个<code>X</code>参数即可</p><p><code>curl -X POST http://127.0.0.1:8000/</code> ，这样你就发送了一个post请求，同样你也可以传参，使用<code>d</code>，不同参数之间使用<code>&amp;</code>来进行连接</p><pre class="language-none"><code class="language-none">curl -X POST -d'a=1&amp;b=2&amp;c=3' http://127.0.0.1:8000/</code></pre><p>再做个假如，你访问的是张图片，我们也可以通过 <code>&gt;</code> 来进行保存，然后查看</p><p>还有，如果在终端里发送文件，则需要<code>-F</code>参数，不过要注意的是，@一定不要少哦</p><pre class="language-none"><code class="language-none">curl -X POST -F 'avatar=@./ssss.jpg' http://127.0.0.1:8000/user/avatar/</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>这个场景呢，主要就是使用了windows系统，但是有些功能只能在linux下测试，但是我的linux云服务器又只有一个终端界面，出于无奈之举，只能使用这样的方法来进行。希望能帮到大家。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios的封装</title>
      <link href="2018/10/07/axios-feng-zhuang/"/>
      <url>2018/10/07/axios-feng-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h2><ol><li><p>src文件夹下新建http文件夹，用来放网络请求相关的文件</p></li><li><p><code>src/http</code>文件夹下，创建<code>index.js</code>文件，对axios进行封装</p></li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> axios<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'axios'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//创建axios对象</span>axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>baseURL<span class="token operator">=</span><span class="token string">'http://127.0.0.1:8000/'</span><span class="token punctuation">;</span> <span class="token comment">//vue请求后端地址</span>axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>timeout<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span>                   <span class="token comment">//多久超时</span> axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>withCredentials<span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token comment">//携带cookie需要添加</span><span class="token comment">/** * 设置请求传递数据的格式（看服务器要求的格式） * x-www-form-urlencoded * 默认提交表单 * 把数据对象序列化成 表单数据 */</span><span class="token comment">//axios.default.headers['Content-Type']='application/x-www-form-urlencoded';</span><span class="token comment">//axios.default.transformRequest=data =&gt;qs.stringify(data);</span><span class="token comment">/** *设置默认提交JSON * 把数据对象序列化成json字符串 */</span>axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'Content-Type'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'application/json'</span><span class="token punctuation">;</span>axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span><span class="token function-variable function">transformRequest</span><span class="token operator">=</span><span class="token parameter"> data </span><span class="token operator">=&gt;</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//请求拦截器</span>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token parameter">config</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  <span class="token comment">//从localStorage获取token</span>  <span class="token keyword">let</span> token <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'token'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//如果有token,就把token设置到请求头中Authorization字段中</span>  token <span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>Authorization<span class="token operator">=</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> config<span class="token punctuation">;</span>  <span class="token punctuation">{</span><span class="token punctuation">,</span><span class="token parameter">error</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">{</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//响应拦截器</span>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  <span class="token comment">//当响应码 2xx的情况，进入这里</span>  <span class="token keyword">return</span> response<span class="token punctuation">.</span>data<span class="token punctuation">;</span>  <span class="token punctuation">{</span><span class="token punctuation">,</span><span class="token parameter">error </span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token comment">//当相应码不是2xx的情况，进入这里</span>  <span class="token keyword">return</span> error  <span class="token punctuation">{</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//get方法，对应get请求</span><span class="token comment">//@params{String{ url[请求的url地址]</span><span class="token comment">//@params{Object{ params[请求时携带的参数]</span><span class="token keyword">export</span> <span class="token keyword">function</span><span class="token function"> get</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span>params<span class="token punctuation">,</span>headers</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>    axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token punctuation">{</span>params<span class="token punctuation">,</span>headers<span class="token punctuation">{</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token function">      resolve</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>ResultObj</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token function">      reject</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">.</span>data</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>  <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//post方法，对应post请求</span><span class="token keyword">export</span> <span class="token keyword">function</span><span class="token function"> post</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span>params<span class="token punctuation">,</span>headers</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>      axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span>params<span class="token punctuation">,</span>headers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token function">        resolve</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">.</span>data</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token function">        reject</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">.</span>data</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>  <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">export</span> <span class="token keyword">default</span> axios<span class="token punctuation">;</span></code></pre><ol start="3"><li><p><code>src/http</code>目录下创建apis.js文件，用来写接口地址列表</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//接口信息，生成请求方法</span><span class="token comment">//请求后端django的地址</span><span class="token comment">//引入get方法，post方法</span><span class="token keyword">import</span> <span class="token punctuation">{</span>get<span class="token punctuation">,</span>post<span class="token punctuation">{</span> <span class="token keyword">from</span> <span class="token string">'./index'</span><span class="token comment">//用户登录</span><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">login</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">params<span class="token punctuation">,</span>headers</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">post</span><span class="token punctuation">(</span><span class="token string">"/user/login/"</span><span class="token punctuation">,</span>params<span class="token punctuation">,</span>headers<span class="token punctuation">)</span></code></pre><h2 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h2></li></ol><pre class="language-python" data-language="python"><code class="language-python">#允许所有源来跨域CORS_ORIGIN_ALLOW_ALL =True#或者设置跨域请求白名单# CORS_ORIGIN_WHITELIST = (#     'http://127.0.0.1:8080',#     'http://localhost:8080',# )#允许携带cookieCORS_ALLOW_CREDENTALS = True</code></pre><h2 id="前后端联调思路"><a href="#前后端联调思路" class="headerlink" title="前后端联调思路"></a>前后端联调思路</h2><ol><li>写完视图函数，使用postman进行接口测试，保证后端接口没有问题</li><li>在vue中写页面，向后端发送数据</li></ol><pre class="language-python" data-language="python"><code class="language-python">const { data { = require('autoprefixer');const axios = require('axios');const { error { = require('shelljs');axios.defaults.baseURL = 'http://192.168.56.100:8888' //vue请求后端地址axios.defaults.timeout = 10000; // 超时设置axios.defaults.withCredentials = true; // 跨域访问需要发送cookie时，一定要加上axios.defaults.headers['Content-Type'] = 'application/json'; //设置默认提交jsonaxios.defaults.transformRequest = data =&gt; JSON.stringify(data);//把数据对象序列化成json字符串// 对请求拦截器，和响应拦截器进行封装/*请求拦截器，发送请求前需要调用这个函数当没有登录时，直接跳转到登录页请求发送前把token获取，设置到header中*/axios.interceptors.request.use(config=&gt;{    //从localStorage中获取token    let token = localStorage.getItem('token');    // 如果有token，就把token设置到请求头中Authorization字段中    token &amp;&amp; (config.headers.Authorzation = token);    return config;{,error =&gt; {    return Promise.reject(error){);/*响应拦截器，当后端返回数据给vue时，会调用这个函数每次返回403错误时，跳转到login*/axios.interceptors.response.use(response =&gt;{    //当响应码是2xx的情况时，进入这里    return response.data;{,error =&gt;{    //当响应码不是2xx的情况是，进入这里    return error{);//使用上面的axios对象，对get和post请求进行封装/*get方法，对应get请求@param {String{ url [请求的url地址]@param {Object{ params [请求时携带的参数]*/export function get(url,params,headers){    return new Promise((resolve,reject) =&gt;{        axios.get(url,{params,headers{).then(res=&gt;{            resolve(res.data.ResulObj)        {).catch(err =&gt;{            reject(err.data)        {)    {){/*post方法，对应post请求@param {String{ url [请求的url地址]@param {Object{ params [请求时携带的参数]*/export function post(url,params,headers){    return new Promise((resolve,reject) =&gt;{        axios.post(url,params,headers).then(res=&gt;{            resolve(res.data)        {).catch(err =&gt;{            reject(err.data)        {)    {){//一定要导出函数export default axios;</code></pre><pre class="language-python" data-language="python"><code class="language-python">def login(request):    body_dict = json.loads(request.body)    name = body_dict.get("name")    pwd = body_dict.get("pwd")    if not all([name,pwd]):        resp = {            'code':1001,            'msg':'信息不全'        {        return JsonResponse(resp)    if name == '天听' and pwd == '123456':        res = {            "code":0,            "msg":"登录成功",            "data":{                "id":1,                "name":"tianting",                "age":20            {        {        return JsonResponse(res)    return JsonResponse({        "code":1002,        "msg":'用户名或密码错误'    {)</code></pre>]]></content>
      
      
      <categories>
          
          <category> axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> Vue </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署Django项目</title>
      <link href="2018/07/21/docker-bu-shu-django-xiang-mu/"/>
      <url>2018/07/21/docker-bu-shu-django-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h2><blockquote><p>作为一种新兴的虚拟化方式，Docker跟传统的虚拟化方式相比具有众多的优势</p><p>首先，Docker的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。 其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。</p><p>容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p><p>Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。</p></blockquote><p>简单来说，Docker是一个应用容器引擎，它包括了三个基本的概念，镜像(Image)，容器(Container)，仓库(Repository)，理解了这三个概念，就理解了Docker整个的生命周期</p><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>Docker镜像就是一个只读的模板，就好比于一个桶，桶里可以装任何东西，无论是一个程序，还是一个完整的ubuntu系统环境，里面仅安装了需要的其他应用程序，需要用什么，往桶里扔什么</p><p>镜像可以用来创建Docker容器</p><p>Docker提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用</p><ul><li><code>docker load -i '镜像路径'</code>用来引入镜像</li><li><code>docker pull mysql</code>，拉去<code>mysql</code>镜像，当然不止<code>mysql</code>，几乎所有的工具都能通过pull来拉取镜像来搭建环境，例如<code>mongo</code>，<code>redis</code>等</li></ul><hr><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><blockquote><p>Dockers利用容器来运行应用</p><p>容器时从镜像创建的运行实例，它可以被启动、开始、停止、删除。每个容器都时相互隔离的，保证安全</p></blockquote><p><code>docker run -it -p 80:80 镜像id</code>：运行容器</p><ul><li><code>-it</code>：<strong>i</strong>以交互式模式运行容器,<strong>t</strong>为容器分配一个伪输入终端</li><li><code>-p</code>：端口<ul><li><code>80:80</code>：端口映射<code>宿主机port:容器port</code></li></ul></li><li><code>docker stop 容器id</code>：关闭</li><li><code>docker ps</code>:查看正在运行的容器</li></ul><blockquote><p>注意，启动时，使用的是镜像id，关闭时，使用的是容器id</p></blockquote><hr><h2 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h2><blockquote><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p></blockquote><blockquote><p>最大的公开仓库是 <a href="https://hub.docker.com/">Docker Hub</a>，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括 <a href="http://www.dockerpool.com/">Docker Pool</a> 等，可以提供大陆用户更稳定快速的访问。</p></blockquote><p>当然，用户也可以在本地网络内创建一个私有仓库。</p><p>当用户创建了自己的镜像之后就可以使用 <code>push</code> 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 <code>pull</code> 下来就可以了。</p><p>Docker仓库的概念跟<strong>Git</strong>类似，注册服务器可以理解为<code>Github</code>这样的托管服务</p><hr><h2 id="部署Django"><a href="#部署Django" class="headerlink" title="部署Django"></a>部署Django</h2><ol><li>在安装好Docker之后，在宿主机安装<code>gunicorn</code>，容器内我们用异步的方式来启动Django</li></ol><pre class="language-python" data-language="python"><code class="language-python">pip isntall gunicorn gevent</code></pre><ol start="2"><li><p>Django配置<code>settings.py</code>对应的应用:</p><pre class="language-python" data-language="python"><code class="language-python">INSTALLED_APPS = [    'gunicorn']</code></pre></li><li><p>在<code>Django</code>项目的根目录编写<code>gunicorn</code>的配置文件：<code>gunicorn.conf.py</code></p><pre class="language-python" data-language="python"><code class="language-python">import multiprocessingbind = "0.0.0.0:8000"   #绑定的ip与端口workers = 1                #进程数</code></pre><blockquote><p>这里注意一点，<code>ip</code>必须是0.0.0.0，不要写成127.0.0.1,否则外部环境会访问不到容器内的服务</p></blockquote></li><li><p>导出你的python对应的依赖列表:</p><pre class="language-python" data-language="python"><code class="language-python">pip freeze &gt; requirements.txt</code></pre></li><li><p>在根目录编写<code>Dockerfile</code>文件</p><pre class="language-python" data-language="python"><code class="language-python">FROM python:3.7WORKDIR /Project/mydjangoCOPY requirements.txt ./RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simpleCOPY . .ENV LANG C.UTF-8CMD ["gunicorn", "mydjango.wsgi:application","-c","./gunicorn.conf.py"]</code></pre></li><li><p>打包</p><pre class="language-python" data-language="python"><code class="language-python">docker build -t '你的项目名' .</code></pre></li><li><p>然后查看镜像</p><pre class="language-python" data-language="python"><code class="language-python">docker images</code></pre></li><li><p>启动镜像服务</p><pre class="language-python" data-language="python"><code class="language-python">docker run -it --rm -p 8000:8000 你的项目名</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="2018/07/15/gong-han-mo-shi/"/>
      <url>2018/07/15/gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是工厂模式"><a href="#什么是工厂模式" class="headerlink" title="什么是工厂模式"></a>什么是工厂模式</h2><blockquote><p>所谓的工厂模式，是设计模式中比较常用的，这种类型的设计模式</p><p>在这种模式下，不会暴露创建逻辑，只是通过某个标识来确定实例化哪个工厂实例</p><p>简单的举个例子，如果你要买一辆汽车，不用知道他是怎样做出来的，只需要把参数传递进去，到时候来提车就好了。</p><p>无论是车还是什么，都不用管工厂内部是怎样实现的，只需要将参数传进去就可以</p></blockquote><p>工厂模式从简到难，分为简单工厂模式，工厂方法模式以及抽象工厂模式</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式其实并不算是一种设计模式，更多的时候更像是一种编程习惯</p><blockquote><p>定义一个工厂类，根据传入的参数返回不同的实例，被创建的实例具有共同的父类或接口</p><p>现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。</p></blockquote><p>再举个栗子，假如，你要生产瓶子，客户说要什么样的瓶子，你就拿着这个瓶子的参数，去该瓶子的生产车间去取。</p><pre class="language-python" data-language="python"><code class="language-python"># 定义三个具体的工厂，他们用来生产具体的东西class A:    def __init__(self):        self.name = 'A瓶子'class B:    def __init__(self):        self.name = 'B瓶子'class C:    def __init__(self):        self.name = 'C瓶子'# 工厂类class factory():    def example(self,name):        if name=='A':            s = A()            print(s.name)        elif name == 'B':            s = B()            print(s.name)        elif name == 'C':            s = C()            print(s.name)w = factory()w.example('B')</code></pre><p>可以看到，只需要在工厂<code>factory</code>中，传入你想要什么瓶子，他就可以通过内部方法实例化某个工厂，从而达到你想要的某个东西</p><hr><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote><p>工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。</p><p>以上面的例子为例，假如要再多一个D瓶子，除了要新建一个D类，还要修改工厂类中的代码，这样就违背了软件设计中的开闭原则，即再扩展新的类时，尽量不要修改原有的代码</p></blockquote><p>说的再简单点，就是工厂类被具体的工厂继承</p><pre class="language-python" data-language="python"><code class="language-python"># 工厂类class factory():    @staticmethod    def example(self):        passclass A(factory):    def __init__(self):        self.name = 'A瓶子'    def example(self):        print(self.name)class B(factory):    def __init__(self):        self.name = 'B瓶子'    def example(self):        print(self.name)class C(factory):    def __init__(self):        self.name = 'C瓶子'    def example(self):        print(self.name)class D(factory):    def __init__(self):        self.name = 'D瓶子'    def example(self):        print(self.name)# 无论你加了多少个工厂，只需要实例化对应的那个具体工厂w = D()w.example()</code></pre><p>这样做的好处就是，在工厂类里，无需改动任何代码，只需要在需要的时候实例化某个具体工厂即可，便于维护</p><hr><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p><p>抽象工厂模式中有工厂和产品簇的概念。而一簇的产品都是成套出现的。比如现在要给每个士兵发一套武器，包括枪和子弹。步枪和步枪子弹，手枪和手枪子弹。生产步枪的工厂就是步枪工厂，而生产手枪的工厂就是手枪工厂。步枪工厂和手枪工厂都是工厂，这就是一种抽象工厂的例子</p></blockquote><p>用一个简单的代码来实现:</p><pre class="language-python" data-language="python"><code class="language-python">import abc# 工厂类class factory():    @staticmethod    def Rifle(self):        pass    def Pistol(self):        pass# M4工厂class M4(category):    def Rifle(self):        return M4Rifle()    def Pistol(self):        return M4Pistol()# AK工厂class AK(category):    def Rifle(self):        return AKRifle()    def Pistol(self):        return AKPistol()# M4工厂class M4Rifle():    def __repr__(self):        return 'M4A1步枪'class M4Pistol():    def __repr__(self):        return 'M4A1手枪'class AKRifle():    def __repr__(self):        return 'AK47步枪'class AKPistol():    def __repr__(self):        return 'AK47手枪'w = M4().Rifle()print(w)</code></pre><blockquote><p>进入工厂类，无论是要AK系列的，还是<code>M4</code>系列的，都只实例化那个类就可以了，因为，无论是<code>M4</code>还是AK都能生产该类的手枪和步枪</p><p>虽然我也不知道他们是不是生产手枪</p></blockquote><p>嗯…再画个图吧，low归low，但比较好理解</p><img src="/2018/07/15/gong-han-mo-shi/20201115120419234.png" style="zoom:70%;" loading="lazy">]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布一致性算法(雪花算法)</title>
      <link href="2018/06/24/fen-bu-yi-zhi-xing-suan-fa-xue-hua-suan-fa/"/>
      <url>2018/06/24/fen-bu-yi-zhi-xing-suan-fa-xue-hua-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是分布一致性"><a href="#什么是分布一致性" class="headerlink" title="什么是分布一致性"></a>什么是分布一致性</h2><blockquote><p>这是一个相当灵魂拷问的问题了，在我们应对千万级甚至亿级的资源访问时，一定会用到的一个词，就是分布式</p><p>因为一台服务器的承载力是有限的，而数据库更是有限的，数据表是更更更有限的，我们只能通过横向扩容的方式来进行数据存储量和查询速度的优化</p><p>可这样会造成一个问题，分库分表后，分布式系统中，唯一主键ID的生成问题，当我们使用mysql自增长主键时，他只在本表中是唯一的， 在分布式系统中，两张表都有一张ID为1的数据，那么显然就无法使用这个自增长了</p></blockquote><p>如果我们说使用uuid，也可以凑活用，但是，第一他是无序的，第二，他占用空间巨大，耗费空间。</p><p>uuid只能适用于类似生成token令牌的场景</p><hr><h2 id="SnowFlake"><a href="#SnowFlake" class="headerlink" title="SnowFlake"></a>SnowFlake</h2><blockquote><p>SnowFlake(雪花算法)，是Twitter提出来的一个算法，其目的是生成一个64bit的整数</p></blockquote><p>1位标识符，始终是0</p><p>41位的时间戳</p><p>10位的机器标识码</p><ul><li>前5位代表数据中心，后面5位是某个数据中心的机器ID</li></ul><p>12位的递增序列</p><ul><li>用来对同一个毫秒之内产生不同的ID，12位可以最多记录4095个，也就是在同一个机器同一毫秒最多记录4095个，多余的需要进行等待下毫秒。</li></ul><h2 id="python实操"><a href="#python实操" class="headerlink" title="python实操"></a>python实操</h2><blockquote><p>首先安装<code>pip install pysnowflake</code></p></blockquote><p>然后终端启动snowflake服务</p><pre class="language-python" data-language="python"><code class="language-python">snowflake_start_server --worker=1</code></pre><blockquote><p>这里的worker就是当前节点的标识</p></blockquote><p> 上代码:</p><pre class="language-python" data-language="python"><code class="language-python">import snowflake.clientprint(snowflake.client.get_guid())# 多次输出一下，就会发现，有递增的连续性</code></pre><img src="/2018/06/24/fen-bu-yi-zhi-xing-suan-fa-xue-hua-suan-fa/image-20201130221520785.png" alt="" style="zoom:50%;" loading="lazy"><p>将其转换成二进制码</p><pre class="language-python" data-language="python"><code class="language-python">print(bin(4431128039883018241))</code></pre><img src="/2018/06/24/fen-bu-yi-zhi-xing-suan-fa-xue-hua-suan-fa/image-20201130221746952.png" alt="" style="zoom:50%;" loading="lazy"><p>然后我们通过二进制码反推</p><ul><li>第一位是标识符</li><li>往后41位是时间戳</li></ul><p>从右方数，12位的递增序列，再数5位就是机器标识，这个机器标识就是某个节点的存储标识00001</p><p>但是啊，目前他是二进制，我们再将其转换为10进制</p><pre class="language-python" data-language="python"><code class="language-python">print(int('00001',2))</code></pre><img src="/2018/06/24/fen-bu-yi-zhi-xing-suan-fa-xue-hua-suan-fa/image-20201130222356449.png" alt="" style="zoom:50%;" loading="lazy">]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ModelViewSet</title>
      <link href="2018/06/18/modelviewset/"/>
      <url>2018/06/18/modelviewset/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>ModelViewSet是封装度最高的DRF的视图类。包含了怎删改查中的所有接口操作。</p></blockquote><blockquote><p>它继承自<code>GenericViewSet</code>、ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin。</p><p><strong>！！！！！注意，因为继承关系，必须在内部定义属性，queryset和serializer_class，因此，ModelViewSet通常结合ModelSerializer使用</strong></p></blockquote><blockquote><p>所以，在使用ModelViewSet定义API时，我们只需要套用模板即可</p></blockquote><p>使用视图集，可以将一系列逻辑相关的动作放到一个类中：</p><ul><li>list() 提供一组数据</li><li>retrieve() 提供单个数据</li><li>create() 创建数据</li><li>update() 更新数据</li><li>destory() 删除数据</li></ul><blockquote><p>视图集类不再实现get()、post()、put()、delete()方法，而是实现动作 <strong>action</strong>。 如 list()、retrieve()、create()、update()、destory()</p></blockquote><table><thead><tr><th>请求</th><th>url</th><th>对应方法</th><th>备注</th></tr></thead><tbody><tr><td>get</td><td>127.0.0.1:8000/app01/book/</td><td>list</td><td>ListModelMixin</td></tr><tr><td>get</td><td>127.0.0.1:8000/app01/book/{1{/</td><td>retrieve</td><td>….Mixin</td></tr><tr><td>post</td><td>127.0.0.1:8000/app01/book/</td><td>create</td><td>….Mixin</td></tr><tr><td>put</td><td>127.0.0.1:8000/app01/book/{1{/</td><td>update</td><td>….Mixin</td></tr><tr><td>detete</td><td>127.0.0.1:8000/app01/book/{1{/</td><td>destroy</td><td>….Mixin</td></tr><tr><td>get</td><td>127.0.0.1:8000/app01/book/ user_action</td><td>useraction</td><td>自定义</td></tr><tr><td>post</td><td>127.0.0.1:8000/app01/book/ user_action</td><td>useraction</td><td>自定义</td></tr></tbody></table><pre class="language-python" data-language="python"><code class="language-python">#views中class BookInfoViewSet(ModelViewSet):    """增删改查图书信息"""    # 指定查询集    queryset = BookInfo.objects.all()    # 指定序列化器    serializer_class = BookInfoModelSerializer</code></pre><blockquote><p>定义好了API视图后，需要在路由中，将请求方法与action进行绑定</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from django.conf.urls import urlfrom django.urls import path,includefrom . import views#导入路由控制类from rest_framework.routers import SimpleRouter,DefaultRouter#实例化路由控制对象router = DefaultRouter()#注册router.register(r'book',views.BookInfoViewSet)#编写路由，固定写法，不清楚是否还有其他写法urlpatterns = [    url(r'',include(router.urls)),]</code></pre><h3 id="action-自定义方法"><a href="#action-自定义方法" class="headerlink" title="action(自定义方法)"></a>action(自定义方法)</h3><blockquote><p>DRF框架提供的action根本不能满足某些无良老板的奇葩需求,这时候，就需要自定义<code>action</code></p></blockquote><blockquote><p>只需要在ModelViewSet定义的api类中，自定action函数后，再将自定义的函数在路由中绑定即可</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">def 函数名(self, request):        '''        自定义action        return: JSON数据        '''        pass#示例：def latest(self, request):    '''获取最后一条记录'''    # 获取模型数据    book = BookInfo.objects.latest('id')    # 获取序列化器对象    s = BookInfoModelSerializer(instance=book)    return Response(s.data)</code></pre><pre class="language-python" data-language="python"><code class="language-python">#路由urlpatterns = [    url(r'^books/$', views.BookInfoViewSet.as_view({'get':'action函数名'{)),    #示例：url(r'^books/$', views.BookInfoViewSet.as_view({'get':'latest'{)),]</code></pre><blockquote><p>之后，使用<code>http://127.0.0.1:8000/app01/books/</code>进行测试</p></blockquote><p>或者使用装饰器方法：</p><pre class="language-python" data-language="python"><code class="language-python">from rest_framework.decorators import action@action(methods=['get'],detail=False,url_path='bookw')def use(self,request):    return Response({'name':'天听'{)'''http://127.0.0.1:8000/app01/book/bookw/如果不加url_path，路由就成了http://127.0.0.1:8000/app01/book/use/'''</code></pre><blockquote><p>注意，此写法不需要再注册路由，需要在装饰器内部进行定义<br><code>url_path</code><br>如果不定义<code>url_path</code>，路由默认为函数名</p><p><code>detail=False</code>表示不需要匹配主键的正则，函数不需要传入主键就设为False</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库自定义字段</title>
      <link href="2018/04/26/shu-ju-ku-zi-ding-yi-zi-duan/"/>
      <url>2018/04/26/shu-ju-ku-zi-ding-yi-zi-duan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在以往的数据库使用中，我们通常在一个数据库里操作某些表，如果有很多字段不同但目的相同的表，则需要建立很多的表来完成需求，这时候，可以通过在一个字段里添加多个数据来实现</p></blockquote><blockquote><p>比如，工单的创建，假如有请假，外购两个工单，请假需要的字段为请假时间，请假理由，而外购的工单需要价格，理由，而两个工单的审批人也都不同，但是，要求两张工单都在同一张表里</p><p>相信很多入门的程序猿到这里已经要提刀砍人了，难道要把两个工单的全部字段建出来，然后根据不同的工单来添加哪些数据，不添加哪些数据吗？</p></blockquote><p>是的，上面的也是一个办法，但是，这样除了效率和辨识度的问题，还有一个最重要的问题就是，low</p><p>简单的来画个图吧</p><p><img src="/2018/04/26/shu-ju-ku-zi-ding-yi-zi-duan/sss.png" loading="lazy"></p><p>建立这样一张表，的确能够满足需求，只需要在创建外购的时候，请假的两个字段不填就好了(请忽略这张比较low的表)</p><p>而如果使用了自定义字段，就会是这样</p><p><img src="/2018/04/26/shu-ju-ku-zi-ding-yi-zi-duan/image-20201115215841546.png" loading="lazy"></p><p>怎么样，是不是简便的多了，只需要在取出该条数据的时候，多一个自定义字段的解析罢了，而且还节省空间和性能(请再次忽略这张low图)</p><p>推荐使用json数据类型储存自定义字段，这样无论是使用哪种语言来实现这项需求，都非常的简单</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRF基本操作</title>
      <link href="2018/04/07/drf-ji-ben-cao-zuo/"/>
      <url>2018/04/07/drf-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>DRF作为django的伴生框架，也封装了很多及其好用的东西</p><p>1.认证 2.权限 3.限流 4.序列化 5.分页 </p></blockquote><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><blockquote><p>Drf内置的四种API认证方式：</p><p><strong>认证方式说明：</strong></p><p>**<a href="https://www.django-rest-framework.org/api-guide/authentication/#basicauthentication">BasicAuthentication</a>**每次提交请求的时候附加用户名和密码来进行认证</p><p>**<a href="https://www.django-rest-framework.org/api-guide/authentication/#tokenauthentication">TokenAuthentication</a>**每次提交请求的时候在HTTP headers里附加Token进行认证</p><p>**<a href="https://www.django-rest-framework.org/api-guide/authentication/#sessionauthentication">SessionAuthentication</a>**用户登录之后系统在cookies存入sessionid进行认证</p><p>**<a href="https://www.django-rest-framework.org/api-guide/authentication/#remoteuserauthentication">RemoteUserAuthentication</a>**通过web服务器认证(apache/nginx这些)</p><p>我选择的是基于Token的认证，客户端登录之后维护一个token，每次请求附加到HTTP headers，还算是方便。</p><p>Drf还可以自定义认证方式，只要继承<code>authentication.BaseAuthentication</code>这个类然后重写<code>authenticate</code>方法就好了。</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">class MyAuthentication(BaseAuthentication):def authenticate(self, request):# 认证逻辑，如果认证通过，返回两个值# 如果认证失败，抛出Authentication异常token = request.GET.get('token')if token:user_token = UserToken.objects.filter(token=token).first()# 认证通过if user_token:return user_token.user,tokenelse:raise AuthenticationFailed('认证失败')else:raise AuthenticationFailed('请求地址中需要携带token')</code></pre><p>然后在视图中使用即可</p><pre class="language-python" data-language="python"><code class="language-python">class StudentViewSet(viewsets.ModelViewSet):authentication_classes = [SessionAuthentication, BasicAuthentication,MyAuthentication]permission_classes = [IsAuthenticated]queryset = Student.objects.all()    serializer_class = StudentSerializer</code></pre><ul><li>创建认证类：继承<code>BaseAuthentication</code>、重写<code>authenticate</code>方法</li><li><code>authenticate()</code>返回值</li></ul><ol><li><code>None</code>：当前认证不管，等下一个认证来执行</li><li><code>raise exceptions.AuthenticationFailed('用户认证失败')</code></li><li>有返回值元组形式：（元素1，元素2）元素1复制给<code>request.user</code>、元素2复制给<code>request.auth</code></li></ol><p>在<code>settings.py</code>中可以配置默认的认证方式，这里我添加了三个：</p><pre class="language-text" data-language="text"><code class="language-text">REST_FRAMEWORK = {    # 身份验证    'DEFAULT_AUTHENTICATION_CLASSES': (        'rest_framework.authentication.BasicAuthentication',        'rest_framework.authentication.TokenAuthentication',        'rest_framework.authentication.SessionAuthentication',    )}</code></pre><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="API授权"><a href="#API授权" class="headerlink" title="API授权"></a><strong>API授权</strong></h3><p>Drf的接口权限有以下几种：</p><ul><li>**<a href="https://www.django-rest-framework.org/api-guide/permissions/#allowany">AllowAny</a>**：允许所有，登不登录无所谓</li><li>**<a href="https://www.django-rest-framework.org/api-guide/permissions/#isauthenticated">IsAuthenticated</a>**：登录了才能访问</li><li>**<a href="https://www.django-rest-framework.org/api-guide/permissions/#isadminuser">IsAdminUser</a>**：管理员才能访问</li><li>**<a href="https://www.django-rest-framework.org/api-guide/permissions/#isauthenticatedorreadonly">IsAuthenticatedOrReadOnly</a>**：顾名思义，不登录只读，登录才能写入</li><li>**<a href="https://www.django-rest-framework.org/api-guide/permissions/#djangomodelpermissions">DjangoModelPermissions</a>**：根据Django Auth的配置（权限细化到每个model）</li><li><strong><a href="https://www.django-rest-framework.org/api-guide/permissions/#djangomodelpermissionsoranonreadonly">DjangoModelPermissionsOrAnonReadOnly</a></strong></li><li>**<a href="https://www.django-rest-framework.org/api-guide/permissions/#djangoobjectpermissions">DjangoObjectPermissions</a>**：配合第三方权限控制，细化到每个对象</li></ul><p>一般来说小网站用到<code>DjangoModelPermissions</code>就是够用的，或者干脆简单一点，用<code>IsAuthenticated</code>和<code>queryset</code>限定请求的数据即可。</p><p>介绍完了基本概念，来看看代码中是如何操作的。</p><p>对于操作用户信息的viewset，我只用了<code>permissions.IsAuthenticated</code>这个权限，然后覆盖了<code>ReadOnlyModelViewSet</code>的<code>get_queryset</code>方法，把queryset变成只包括当前用户，这样就保证了一个用户只能操作自己的信息。</p><pre class="language-python" data-language="python"><code class="language-python">from rest_framework import authentication, permissions, viewsetsclass UserViewSet(viewsets.ReadOnlyModelViewSet):    permission_classes = [permissions.IsAuthenticated]    serializer_class = UserSerializer    def get_queryset(self):        return User.objects.filter(pk=self.request.user.pk)</code></pre><p>viewset的action同样可以使用权限，加在装饰器的参数上即可：</p><pre class="language-python" data-language="python"><code class="language-python">@action(detail=True, methods=['GET'], permission_classes=[permissions.IsAuthenticated])def some_actions(self, request, pk=None):    dosomething    return Response(SomeSerializer(some_data, many=True).data)</code></pre><p>这里提一下装饰器的detail参数，这个代表了是对列表操作还是对单个对象操作，True就是对单个对象。</p><blockquote><p>ApiView和ViewSet同样通过在类字段中加入<code>authentication_classes</code>和<code>permission_classes</code>实现认证和授权。</p></blockquote><h2 id="分页-PAGINATION"><a href="#分页-PAGINATION" class="headerlink" title="分页 PAGINATION"></a>分页 PAGINATION</h2><p>Drf和Django一样自带分页功能，很好用（当然也支持使用第三方的分页功能）。</p><p>首先进行配置（不配置的话使用默认配置），这里我设置每页显示十条记录：</p><pre class="language-text" data-language="text"><code class="language-text">REST_FRAMEWORK = {    # 设置分页    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',    'PAGE_SIZE': 10,}</code></pre><p>使用得最多的<code>ModelViewSet</code>已经自带分页了，这个我们不用操心，不过如果自己定义了action来返回列表数据的话，就没有分页，这时候要用<code>paginate_queryset</code>方法来处理。</p><p>代码如下：</p><pre class="language-text" data-language="text"><code class="language-text">@action(detail=False)def tag(self, request):    queryset = SomeModel.objects.all().order_by('-add_time')    page = self.paginate_queryset(queryset)    if page is not None:    return self.get_paginated_response(self.get_serializer(page, many=True).data)    return Response(self.get_serializer(queryset, many=True).data)</code></pre><p>可以看出Drf自动处理了不同页面的请求，不用像Django一样自己从GET或者POST数据里读取page，分页相关的方法直接在viewset对象里面，非常方便。</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>其实就是一个自定义的认证过程。</p><p>Drf内置有<code>BaseThrottle</code>、<code>SimpleRateThrottle</code>，后者是前者的之类。</p><ul><li><code>BaseThrottle</code> 需要自己写<code>allow_request</code>和<code>wait</code>方法，控制粒度更细</li><li><code>SimpleRateThrottle</code>重写<code>get_cache_key</code>和设置<code>scope</code>名称就可以，更简单</li></ul><h3 id="实现1分钟内只能访问3次的限流"><a href="#实现1分钟内只能访问3次的限流" class="headerlink" title="实现1分钟内只能访问3次的限流"></a><strong>实现1分钟内只能访问3次的限流</strong></h3><p><code>SimpleRateThrottle</code>代码如下：</p><pre class="language-python3" data-language="python3"><code class="language-python3">from rest_framework.throttling import SimpleRateThrottleclass VisitThrottle(SimpleRateThrottle):    '''匿名用户60s只能访问三次（根据ip）'''    scope = 'throttle'   #这里面的值，自己随便定义，settings里面根据这个值配置throttle    def get_cache_key(self, request, view):        #通过ip限制节流        return self.get_ident(request)class UserThrottle(SimpleRateThrottle):    '''登录用户60s可以访问10次'''    scope = 'userThrottle'    #这里面的值，自己随便定义，settings里面根据这个值配置userThrottle    def get_cache_key(self, request, view):        return request.user.user_id</code></pre><p><code>BaseThrottle</code> 代码如下：</p><pre class="language-python3" data-language="python3"><code class="language-python3">from rest_framework.throttling import BaseThrottleimport timeVISIT_RECORD = {}   #保存访问记录class VisitThrottle(BaseThrottle):    '''60s内只能访问3次'''    def __init__(self):        self.history = None   #初始化访问记录    def allow_request(self,request,view):        #获取用户ip (get_ident)        remote_addr = self.get_ident(request)        ctime = time.time()        #如果当前IP不在访问记录里面，就添加到记录        if remote_addr not in VISIT_RECORD:            VISIT_RECORD[remote_addr] = [ctime,]     #键值对的形式保存            return True    #True表示可以访问        #获取当前ip的历史访问记录        history = VISIT_RECORD.get(remote_addr)        #初始化访问记录        self.history = history        #如果有历史访问记录，并且最早一次的访问记录离当前时间超过60s，就删除最早的那个访问记录，        #只要为True，就一直循环删除最早的一次访问记录        while history and history[-1] &lt; ctime - 60:            history.pop()        #如果访问记录不超过三次，就把当前的访问记录插到第一个位置（pop删除最后一个）        if len(history) &lt; 3:            history.insert(0,ctime)            return True    def wait(self):        '''还需要等多久才能访问'''        ctime = time.time()        return 60 - (ctime - self.history[-1])</code></pre><h3 id="配置节流"><a href="#配置节流" class="headerlink" title="配置节流"></a><strong>配置节流</strong></h3><pre class="language-text" data-language="text"><code class="language-text">#全局REST_FRAMEWORK = {    # 设置全局节流    "DEFAULT_THROTTLE_CLASSES":['api.utils.throttle.UserThrottle'],   #全局配置，登录用户节流限制（10/m）    # 设置访问频率    "DEFAULT_THROTTLE_RATES":{        'throttle':'3/m',         #没登录用户3/m，throttle就是scope定义的值,通过IP地址        'userThrottle':'10/m',    #登录用户10/m，userThrottle就是scope定义的值， 通过user_id    }}# 局部：在类视图中添加throttle_classes = [VisitThrottle,]</code></pre><p><a href="https://zhuanlan.zhihu.com/p/113367282">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊天室</title>
      <link href="2018/04/02/liao-tian-shi/"/>
      <url>2018/04/02/liao-tian-shi/</url>
      
        <content type="html"><![CDATA[<p>最近，在写一个简单的基于websocket和django的聊天室，来分享一下我这个过程</p><ul><li><p>首先是思路，聊天室说起来简单，但实际操作起来完全不是那么回事了，除了简单的连接之外，完全没有一点头绪</p><blockquote><p>把聊天室的功能梳理了一下，然后拆开，分成了前端连接，前端发送，后端连接，实时推送消息，记录保存这五个方面</p></blockquote></li><li><p>先来说一说前端连接的问题，其实也就是一个简单的<code>websocket</code>连接，不过是增加了一个断开重连</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">websocketlink</span><span class="token punctuation">(</span><span class="token parameter">uid</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">'WebSocket'</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment">//  生成websocket链接</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'支持'</span><span class="token punctuation">)</span>      <span class="token keyword">var</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">'ws://192.168.1.157:8000/chat_room_websocket/?uid='</span><span class="token operator">+</span>uid<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// var ws = new WebSocket('ws://192.168.1.157:8000/chat_room_websocket/');</span>      <span class="token comment">// 连接成功</span>      ws<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">{</span>      <span class="token comment">// 收到数据</span>      ws<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        <span class="token comment">// 将获取信息打印</span>        <span class="token keyword">var</span> received_msg <span class="token operator">=</span> evt<span class="token punctuation">.</span>data        <span class="token keyword">this</span><span class="token punctuation">.</span>msglist<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>received_msg<span class="token punctuation">)</span><span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>evt<span class="token punctuation">)</span>              <span class="token comment">// 连接关闭</span>      ws<span class="token punctuation">.</span><span class="token function-variable function">onclose</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'链接已关闭'</span><span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">websocketlink</span><span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'uid'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>      <span class="token comment">// 连接报错</span>      ws<span class="token punctuation">.</span><span class="token function-variable function">error</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">websocketlink</span><span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'uid'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span></code></pre><blockquote><p>这里，我把连接封装起来，在报错或者关闭时，重新连接</p></blockquote></li><li><p>页面操作上，点击按钮，发送消息，这都是简单的请求<code>API</code>接口的操作，这里就不多详述了</p></li><li><p>后端连接，也是一个简单的<code>dwebsocket</code>连接</p><pre class="language-python" data-language="python"><code class="language-python">clients = {{# 链接websocket接口@accept_websocketdef chat_room_websocket(request):    if request.is_websocket():        while True:            message = request.websocket.wait()            if not message:                break            else:                # 连接的用户的id                uid = message.decode()                # 加入到字典中                clients[uid] = request.websocket</code></pre><blockquote><p>和之前一样，定义公共变量，将连接的id和连接对象放进去</p></blockquote></li><li><p>存储，发送消息不难，存储其实也不难，无论是存到mysql还是redis还是文件都可以自行选择，这里，我存的是自己的文件，根据用户的id生成文件，时间戳+消息追加性的存储</p><pre class="language-python" data-language="python"><code class="language-python"># 时间戳，毫秒，为了之后取消息记录，做一下准备t = time.time()timestamp1 = int(round(t * 1000))# 加个换行，直接存s = str(timestamp1)+ ':' + msg + '\n'with open('chat_record/%s.txt' % uid, 'a', encoding='utf-8') as f:                f.write(s)</code></pre></li><li><p>实时推送消息，如果有人在聊天室发了消息，却看不到，这就非常的伤脑筋，为了实现简单的推送消息，将公共变量中的所有连接，遍历一下，然后发送给所有人</p><pre class="language-python" data-language="python"><code class="language-python"># 遍历所有的连接用户for client in clients:    # 构造返回数据，需要编一下码message = json.dumps({'username':username,'msg':msg{,ensure_ascii=False)    # 发送消息    clients[client].send(message.encode('utf-8'))</code></pre></li><li><p>后端推送，这里我是传了图片，为了更加的人性化。只发文字不发图片的聊天室是没有灵魂的</p><blockquote><p>另外，我做了一个<code>redis</code>限流，这个可以忽略不计</p><p>另外的另外， 因为我前端稀碎， 有些多余的代码可以自行过滤一下</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">class SendMessage(APIView):    def post(self,request):                # 传图片和发送消息是两个接口，所以，获取用户id的方法也不一样，这里写的多余了                msg = request.data.get('msg')        uid = request.data.get('uid')        image = request.FILES.get('file')        if image:            uid = request.GET.get('uid')      # redis限流        redis_client = get_redis_connection('chat_room')        try:            redis_client.get(uid)        except Exception as e:            print(e)            return Response({'code': 1001, 'msg': '发送频繁'{)        redis_client.hincrby(uid,'num')        redis_client.expire(uid, 5)                # 这里的名字是根据连接查了一下数据库，可以忽略        username = User.objects.filter(id=uid).first().username        # 如果要获取两个人的聊天记录，在创建文件时，可以用两个人的id来组成文件名                # 构造时间戳        t = time.time()        timestamp1 = int(round(t * 1000))        # 如果传的是消息，发送消息顺便存储到本地        if msg:            for client in clients:                message = json.dumps({'username':username,'msg':msg{,ensure_ascii=False)                clients[client].send(message.encode('utf-8'))                s = str(timestamp1)+ ':' + msg + '\n'                with open('chat_record/%s.txt' % uid, 'a', encoding='utf-8') as f:                    f.write(s)        # 写图片文件,如果传了文件，则写入到文件中，然后拼接一个url返回        elif image:            with open(os.path.join(CHAT_RECORD_ROOT, '', image.name), 'wb') as f:                for chunk in image.chunks():                    f.write(chunk)                message = json.dumps({'username': username, 'msg':('http://192.168.1.157:8000/static/chat_record/'+image.name){, ensure_ascii=False)                for client in clients:                    clients[client].send(message.encode('utf-8'))            s = str(timestamp1)+':'+'http://192.168.1.157:8000/static/chat_record/'+str(image.name) + '\n'            with open('chat_record/%s.txt' % uid, 'a', encoding='utf-8') as f:                f.write(s)        return Response({'message': 'ok'{)</code></pre></li><li><p>发送与渲染</p><blockquote><p>判断：indexOf() —&gt;判断是否有某个元素，格式为 <strong>字符串&amp;&amp;字符串.indexOf(‘子串’)</strong></p><p>如果不存在，则返回一个**-1**</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>a<span class="token operator">-</span>modal v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">'show'</span> @ok<span class="token operator">=</span><span class="token string">"myok"</span><span class="token operator">&gt;</span>          <span class="token operator">&lt;</span>span v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"i in msglist"</span> <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">"i.username"</span><span class="token operator">&gt;</span>          <span class="token operator">&lt;</span>p v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">'i.msg &amp;&amp; i.msg.indexOf(".jpg")!=-1'</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>i<span class="token punctuation">.</span>username<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">:</span><span class="token operator">&lt;</span>a<span class="token operator">-</span>avatar <span class="token operator">:</span>size<span class="token operator">=</span><span class="token string">"44"</span> <span class="token operator">:</span>src<span class="token operator">=</span>i<span class="token punctuation">.</span>msg style<span class="token operator">=</span><span class="token string">'margin-left: 20px'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">-</span>avatar<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>          <span class="token operator">&lt;</span>p v<span class="token operator">-</span><span class="token keyword">else</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>i<span class="token punctuation">.</span>username<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span>i<span class="token punctuation">.</span>msg<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>          <span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>          <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>          <span class="token operator">&lt;</span>a<span class="token operator">-</span>form<span class="token operator">-</span>item label<span class="token operator">=</span><span class="token string">"发送消息"</span> v<span class="token operator">-</span>bind<span class="token operator">=</span><span class="token string">"formlayout"</span> <span class="token operator">&gt;</span>              <span class="token operator">&lt;</span>a<span class="token operator">-</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"msg"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>          <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">-</span>form<span class="token operator">-</span>item<span class="token operator">&gt;</span>                    <span class="token operator">&lt;</span>a<span class="token operator">-</span>form<span class="token operator">-</span>item v<span class="token operator">-</span>bind<span class="token operator">=</span><span class="token string">"buttonlayout"</span><span class="token operator">&gt;</span>              <span class="token operator">&lt;</span>a<span class="token operator">-</span>button type<span class="token operator">=</span><span class="token string">'primary'</span> @click<span class="token operator">=</span><span class="token string">"send_msg"</span><span class="token operator">&gt;</span>发送消息<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">-</span>button<span class="token operator">&gt;</span>              <span class="token operator">&lt;</span>a<span class="token operator">-</span>upload              name<span class="token operator">=</span><span class="token string">"file"</span>              <span class="token operator">:</span>multiple<span class="token operator">=</span><span class="token string">"true"</span>              <span class="token operator">:</span>action<span class="token operator">=</span>uid              <span class="token operator">:</span>headers<span class="token operator">=</span><span class="token string">"headers"</span>              @change<span class="token operator">=</span><span class="token string">"handleChange"</span>              <span class="token operator">&gt;</span>                <span class="token operator">&lt;</span>a<span class="token operator">-</span>button<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>a<span class="token operator">-</span>icon type<span class="token operator">=</span><span class="token string">"upload"</span> <span class="token operator">/</span><span class="token operator">&gt;</span> 发送文件 <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">-</span>button<span class="token operator">&gt;</span>            <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">-</span>upload<span class="token operator">&gt;</span>                      <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">-</span>form<span class="token operator">-</span>item<span class="token operator">&gt;</span>          <span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">-</span>modal<span class="token operator">&gt;</span></code></pre><p>一个简单的聊天室就做好啦</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Celery</title>
      <link href="2018/02/13/celery/"/>
      <url>2018/02/13/celery/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><h3 id="1-1-celery应用举例"><a href="#1-1-celery应用举例" class="headerlink" title="1.1 celery应用举例"></a>1.1 celery应用举例</h3><ul><li><p>Celery 是一个 基于python开发的分布式异步消息任务队列，通过它可以轻松的实现任务的异步处理，如果你的业务场景中需要用到异步任务，就可以考虑使用celery</p></li><li><p>你想对100台机器执行一条批量命令，可能会花很长时间 ，但你不想让你的程序等着结果返回，而是给你返回 一个任务ID,你过一段时间只需要拿着这个任务id就可以拿到任务执行结果， 在任务执行ing进行时，你可以继续做其它的事情</p></li><li><p>Celery 在执行任务时需要通过一个消息中间件来接收和发送任务消息，以及存储任务结果， 一般使用rabbitMQ or Redis</p></li></ul><h3 id="1-2-Celery有以下优点"><a href="#1-2-Celery有以下优点" class="headerlink" title="1.2 Celery有以下优点"></a>1.2 Celery有以下优点</h3><ul><li>简单：一单熟悉了celery的工作流程后，配置和使用还是比较简单的</li><li>高可用：当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务</li><li>快速：一个单进程的celery每分钟可处理上百万个任务</li><li>灵活： 几乎celery的各个组件都可以被扩展及自定制</li></ul><h3 id="1-3-Celery-特性"><a href="#1-3-Celery-特性" class="headerlink" title="1.3 Celery 特性"></a>1.3 Celery 特性</h3><ul><li>方便查看定时任务的执行情况, 如 是否成功, 当前状态, 执行任务花费的时间等.</li><li>可选 多进程, Eventlet 和 Gevent 三种模型并发执行.</li><li>Celery 是语言无关的.它提供了python 等常见语言的接口支持.</li></ul><h2 id="Celery组件"><a href="#Celery组件" class="headerlink" title="Celery组件"></a>Celery组件</h2><h3 id="2-1-Celery-扮演生产者和消费者的角色"><a href="#2-1-Celery-扮演生产者和消费者的角色" class="headerlink" title="2.1 Celery 扮演生产者和消费者的角色"></a>2.1 Celery 扮演生产者和消费者的角色</h3><ul><li><p><strong>Celery Beat :</strong> 任务调度器. Beat 进程会读取配置文件的内容, 周期性的将配置中到期需要执行的任务发送给任务队列.</p></li><li><p><strong>Celery Worker :</strong> 执行任务的消费者, 通常会在多台服务器运行多个消费者, 提高运行效率.</p></li><li><p><strong>Broker :</strong> 消息代理, 队列本身. 也称为消息中间件. 接受任务生产者发送过来的任务消息, 存进队列再按序分发给任务消费方(通常是消息队列或者数据库).</p></li><li><p><strong>Producer :</strong> 任务生产者. 调用 Celery API , 函数或者装饰器, 而产生任务并交给任务队列处理的都是任务生产者.</p></li><li><p><strong>Result Backend :</strong> 任务处理完成之后保存状态信息和结果, 以供查询.</p></li></ul><h3 id="2-2-celery架构图"><a href="#2-2-celery架构图" class="headerlink" title="2.2 celery架构图"></a>2.2 celery架构图</h3><p><img src="/2018/02/13/celery/602127040446.png" loading="lazy"> </p><h3 id="2-3-产生任务的方式"><a href="#2-3-产生任务的方式" class="headerlink" title="2.3 产生任务的方式"></a>2.3 产生任务的方式</h3><ul><li><p>发布者发布任务(WEB 应用)</p></li><li><p>任务调度按期发布任务(定时任务)</p></li></ul><h3 id="2-4-celery-依赖三个库-这三个库-都由-Celery-的开发者开发和维护"><a href="#2-4-celery-依赖三个库-这三个库-都由-Celery-的开发者开发和维护" class="headerlink" title="2.4 celery 依赖三个库: 这三个库, 都由 Celery 的开发者开发和维护."></a>2.4 celery 依赖三个库: 这三个库, 都由 Celery 的开发者开发和维护.</h3><ul><li><code>billiard :</code> 基于 Python2.7 的 multisuprocessing 而改进的库, 主要用来提高性能和稳定性.</li><li><code>librabbitmp : </code>C 语言实现的 Python 客户端</li><li><code>kombu :</code> Celery 自带的用来收发消息的库, 提供了符合 Python 语言习惯的, 使用 AMQP 协议的高级借口.</li></ul><h2 id="配置Celery"><a href="#配置Celery" class="headerlink" title="配置Celery"></a>配置Celery</h2><h3 id="安装celery"><a href="#安装celery" class="headerlink" title="安装celery"></a>安装celery</h3><pre class="language-python" data-language="python"><code class="language-python">pip install celery @ https://github.com/celery/celery/tarball/master</code></pre><h3 id="新建celery-main-py配置celery"><a href="#新建celery-main-py配置celery" class="headerlink" title="新建celery/main.py配置celery"></a>新建<code>celery/main.py</code>配置celery</h3><pre class="language-python" data-language="python"><code class="language-python"># celery_task/main.pyimport osfrom celery import Celery# 定义celery实例, 需要的参数, 1, 实例名, 2, 任务发布位置, 3, 结果保存位置app = Celery('mycelery',             broker='redis://127.0.0.1:6379/14',  # 任务存放的地方              backend='redis://127.0.0.1:6379/15')  # 结果存放的地方@app.taskdef add(x, y):    return x + y</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="启动celery"><a href="#启动celery" class="headerlink" title="启动celery"></a>启动celery</h3><pre class="language-python" data-language="python"><code class="language-python">'''1.启动celery'''#1.1 单进程启动celerycelery -A main worker -l INFO#1.2 celery管理celery multi start celery_test -A celery_test -l debug --autoscale=50,5        # celery并发数：最多50个，最少5个ps auxww|grep "celery worker"|grep -v grep|awk '{print $2{'|xargs kill -9       # 关闭所有celery进程</code></pre><h2 id="1-使用celery异步发送短信"><a href="#1-使用celery异步发送短信" class="headerlink" title="1.使用celery异步发送短信"></a>1.使用celery异步发送短信</h2><h3 id="1-1-在celery-task-mian-py中添加发送短信函数"><a href="#1-1-在celery-task-mian-py中添加发送短信函数" class="headerlink" title="1.1 在celery_task/mian.py中添加发送短信函数"></a>1.1 在<code>celery_task/mian.py</code>中添加发送短信函数</h3><pre class="language-python" data-language="python"><code class="language-python"># celery项目中的所有导包地址, 都是以CELERY_BASE_DIR为基准设定.# 执行celery命令时, 也需要进入CELERY_BASE_DIR目录执行.CELERY_BASE_DIR = os.path.dirname(os.path.abspath(__file__))@app.task(bind=True)def send_sms_code(self, mobile, datas):    sys.path.insert(0, os.path.join(CELERY_BASE_DIR, '../syl'))    # 在方法中导包    from libs.rl_sms import send_message    # time.sleep(5)    try:        # 用 res 接收发送结果, 成功是:０，　失败是：－１        res = send_message(mobile, datas)    except Exception as e:        res = '-1'    if res == '-1':        # 如果发送结果是 -1  就重试.        self.retry(countdown=5, max_retries=3, exc=Exception('短信发送失败'))</code></pre><h3 id="1-2-在verifications-views-py中添加celery发送短信视图函数"><a href="#1-2-在verifications-views-py中添加celery发送短信视图函数" class="headerlink" title="1.2 在verifications/views.py中添加celery发送短信视图函数"></a>1.2 在<code>verifications/views.py</code>中添加celery发送短信视图函数</h3><pre class="language-python" data-language="python"><code class="language-python">class SmsCodeView(APIView):    """使用apiview的限流"""    # 1. 所有人可以访问    permission_classes = (AllowAny,)    def post(self, request):        # 1. 获取参数        phone = request.data.get('phone')  # 手机号        image_code = request.data.get('image_code')  # 图片验证码        image_code_uuid = request.data.get('image_code_uuid')  # 前端生成的uuid        # 2. 检查参数        if not all([phone, image_code, image_code_uuid]):            return Response({"code": 999, "msg": "参数不全"{)        if not re.match(r'^1[3456789]\d{9{$', phone):            return Response({"code": 999, "msg": "手机号码不正确"{)        # 3. 检查是否发送        redis_client = get_redis_connection('img_code')        phone_exists = redis_client.get(phone)        if phone_exists:            return Response({"code": 999, "msg": "频繁发送, 请稍后再试"{)        # 验证图形验证码        redis_image_code = redis_client.get(image_code_uuid)  # bytes        if redis_image_code:            # bytes 转成 string            redis_image_code = redis_image_code.decode()        # 比较用户提供的图片内容是否和redis中保存的一致        if image_code.upper() != redis_image_code:            return Response({'code': 999, 'msg': '图片验证码不正确'{)        # 4. 发送        code = '%06d' % random.randint(0, 999999)  # 随机6位验证码        from syl.settings import BASE_DIR        sys.path.insert(0, os.path.join(BASE_DIR, '../celery_task'))        from main import send_sms_code  # 必须这么写, 从main中导包        send_sms_code.delay(phone, (code, "5"))        print(code)        # 5.使用 pipeline 批量操作        pl = redis_client.pipeline()    # 实例化pipeline对象        pl.setex(phone, 60 * 5, code)   # 存储phone:code, 5分钟有效期        pl.delete(image_code_uuid)      # 从redis中删除这个图片验证码, 以防再次被使用        pl.execute()        # 6. 返回结果        return Response({"code": 0, "msg": "短信发送成功"{)</code></pre><h3 id="1-3-添加路由"><a href="#1-3-添加路由" class="headerlink" title="1.3 添加路由"></a>1.3 添加路由</h3><pre class="language-python" data-language="python"><code class="language-python">urlpatterns = [    path('sms_codes/', views.SmsCodeView.as_view()),]</code></pre><h2 id="2-测试接口"><a href="#2-测试接口" class="headerlink" title="2.测试接口"></a>2.测试接口</h2><ul><li>接口URL</li></ul><pre class="language-none"><code class="language-none">http://192.168.56.100:8888/user/sms_codes/</code></pre><ul><li>请求携带参数</li></ul><pre class="language-python" data-language="python"><code class="language-python">{    "phone": 18538752511,    "image_code":"aed3",                                         # 前端生成的 图形验证码    "image_code_uuid":"de8edce2-fc9f-11ea-9325-005056c00008"     # 前端生成的uuid{</code></pre><h2 id="django添加检查用户名和手机号数量接口"><a href="#django添加检查用户名和手机号数量接口" class="headerlink" title="django添加检查用户名和手机号数量接口"></a>django添加检查用户名和手机号数量接口</h2><h3 id="1-1-在user-urls-py中添加"><a href="#1-1-在user-urls-py中添加" class="headerlink" title="1.1 在user/urls.py中添加"></a>1.1 在<code>user/urls.py</code>中添加</h3><pre class="language-python" data-language="python"><code class="language-python">urlpatterns = [    path('count/', views.RegCountView.as_view()),  # 查询用户名手机号使用量的视图,  /user/count/]</code></pre><h3 id="1-2-在user-views-py中添加视图函数"><a href="#1-2-在user-views-py中添加视图函数" class="headerlink" title="1.2 在user/views.py中添加视图函数"></a>1.2 在<code>user/views.py</code>中添加视图函数</h3><pre class="language-python" data-language="python"><code class="language-python"># 查询用户数量接口class RegCountView(APIView):    # 注册时需要验证的用户名和手机号是否使用    # 自定义权限类    permission_classes = (AllowAny,)    def post(self, request):        # 接收参数:  验证的内容type: username/phone,  data: '用户名' 或者 '手机号',        datatype = request.data.get('type')        data = request.data.get('data')        if not all([data, datatype]):            return Response({'code': 999, 'msg': '参数不完整'{)        if datatype == 'username':            count = User.objects.filter(username=data).count()        if datatype == 'phone':            count = User.objects.filter(phone=data).count()        return Response({'code': 0, 'msg': '查询成功', 'data': {'type': datatype, 'count': count{{)</code></pre><h2 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h2><ul><li>测试接口URL</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript">http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">192.168</span><span class="token number">.56</span><span class="token number">.100</span><span class="token operator">:</span><span class="token number">8888</span><span class="token operator">/</span>user<span class="token operator">/</span>count<span class="token operator">/</span></code></pre><h2 id="完善注册接口"><a href="#完善注册接口" class="headerlink" title="完善注册接口"></a>完善注册接口</h2><h3 id="修改user-views-py中完善视图函数"><a href="#修改user-views-py中完善视图函数" class="headerlink" title="修改user/views.py中完善视图函数"></a>修改<code>user/views.py</code>中完善视图函数</h3><pre class="language-python" data-language="python"><code class="language-python"># 注册接口class RegisterView(APIView):    """    用户注册, 权限是: 匿名用户可访问    """    # 自定义权限类    permission_classes = (AllowAny,)    def post(self, request):        """        接收用户名,密码,手机号和验证码, 前端校验两遍一致性, 注册成功后返回成功, 然后用户自行登录获取token        1. 用户名        2. 密码        3. 手机号        4. 验证码        :param request:        :return:  {'code':0,'msg':'注册成功'{        code: "260361"        password: "123123"        phone: "13303479527"        username: "liangxuepeng"        """        username = request.data.get('username')        phone = request.data.get('phone')        code = request.data.get('code')        passwrod = request.data.get('password')        if all([username, passwrod, phone, code]):            pass        else:            return Response({'code': 999, 'msg': '参数不全'{)        # rand_name = self.randomUsername()        # 验证手机验证码        redis_client = get_redis_connection('verify_code')        code_redis = redis_client.get(phone)        if code_redis:            code_redis = code_redis.decode()        if not code == code_redis:            return Response({'code': 999, 'msg': '手机验证码错误'{)        user = User(username=username, phone=phone)        user.set_password(passwrod)        user.save()        return Response({'code': 0, 'msg': '注册成功'{)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> Celery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的垃圾回收机制</title>
      <link href="2018/02/02/python-de-la-ji-hui-shou-ji-zhi/"/>
      <url>2018/02/02/python-de-la-ji-hui-shou-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="浅谈一下python的内存管理机制"><a href="#浅谈一下python的内存管理机制" class="headerlink" title="浅谈一下python的内存管理机制"></a>浅谈一下python的内存管理机制</h2><blockquote><p>python采用的是<strong>引用计数</strong>机制为主，<strong>标记-清除</strong>和<strong>分代回收</strong>两种机制为辅的策略</p></blockquote><p>在python中，每一个对象的核心就是一个结构体，它的内部有一个引用计数器，程序运行过程中会实时的更新ob_refcnt的值，来反映引用当前对象的名称数量，当某个对象的引用计数为0，那么它的内存就会被立即释放掉</p><h2 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h2><blockquote><p>在Python中万物皆对象</p><p>不存在基本数据类型，<code>0, 1.2, True, False, "abc"</code>等，这些全都是对象</p><p>所有对象, 都会在内存中开辟一块空间进行存储</p></blockquote><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><blockquote><p>分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为三代，分别为年轻代(0代)，中年代(1代)，老年代(2代)，他们对应的是三个链表，它们的垃圾收集频率与对象的存活时间的增大而减小</p><p>新创建的对象都会分配在<strong>年轻代</strong>，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，以此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。</p><p>同时，分代回收是建立在标记清除技术基础之上。作为Python的辅助垃圾收集技术处理那些容器对象</p></blockquote><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>有三种情况会触发垃圾回收：</p><ol><li>调用<code>gc.collect()</code>,需要先导入<code>gc</code>模块。</li><li>当<code>gc</code>模块的计数器达到阀值的时候。</li><li>程序退出的时候。</li></ol><h4 id="gc模块"><a href="#gc模块" class="headerlink" title="gc模块"></a><code>gc</code>模块</h4><p><code>gc</code>模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而<code>gc</code>模块的一个主要功能就是解决循环引用的问题。</p><h2 id="多次赋值"><a href="#多次赋值" class="headerlink" title="多次赋值"></a>多次赋值</h2><blockquote><p>对于整数和短小的字符，Python会进行缓存，不会创建多个相同对象</p><p>此时，被多次赋值，只会有多份引用</p></blockquote><h2 id="id和hex"><a href="#id和hex" class="headerlink" title="id和hex"></a>id和hex</h2><p>在python的内置函数中，可以通过id获取内存地址(10进制)，通过hex()可以查看16进制地址</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo解决引用本地图片无法显示</title>
      <link href="2018/01/24/hexo-jie-jue-yin-yong-ben-di-tu-pian-wu-fa-xian-shi/"/>
      <url>2018/01/24/hexo-jie-jue-yin-yong-ben-di-tu-pian-wu-fa-xian-shi/</url>
      
        <content type="html"><![CDATA[<p>最近用起hexo，但是发现文章中引用本地图片时总是显示不出来</p><p>花费了许久时间才解决了这个问题，因此将一些解决经验整理出来，希望能帮助到大家</p><h3 id="一、插件安装与配置"><a href="#一、插件安装与配置" class="headerlink" title="一、插件安装与配置"></a>一、插件安装与配置</h3><p>首先我们需要安装一个图片路径转换的插件，这个插件名字是<strong>hexo-asset-image</strong></p><pre class="language-none"><code class="language-none">npm install https://github.com/CodeFalling/hexo-asset-image --save</code></pre><p>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">'use strict'</span><span class="token punctuation">;</span><span class="token keyword">var</span> cheerio <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cheerio'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><span class="token keyword">function</span> <span class="token function">getPosition</span><span class="token punctuation">(</span><span class="token parameter">str<span class="token punctuation">,</span> m<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> version <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>hexo<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hexo<span class="token punctuation">.</span>extend<span class="token punctuation">.</span>filter<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'after_post_render'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> config <span class="token operator">=</span> hexo<span class="token punctuation">.</span>config<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>post_asset_folder<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> link <span class="token operator">=</span> data<span class="token punctuation">.</span>permalink<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>version<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">Number</span><span class="token punctuation">(</span>version<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span>   <span class="token keyword">var</span> beginPos <span class="token operator">=</span> <span class="token function">getPosition</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">else</span>   <span class="token keyword">var</span> beginPos <span class="token operator">=</span> <span class="token function">getPosition</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span><span class="token keyword">var</span> endPos <span class="token operator">=</span> link<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    link <span class="token operator">=</span> link<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>beginPos<span class="token punctuation">,</span> endPos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> toprocess <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'excerpt'</span><span class="token punctuation">,</span> <span class="token string">'more'</span><span class="token punctuation">,</span> <span class="token string">'content'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> toprocess<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">var</span> key <span class="token operator">=</span> toprocess<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">var</span> $ <span class="token operator">=</span> cheerio<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>        ignoreWhitespace<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        xmlMode<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        lowerCaseTags<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        decodeEntities<span class="token operator">:</span> <span class="token boolean">false</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// For windows style path, we replace '\' to '/'.</span><span class="token keyword">var</span> src <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'\\'</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">http[s]*.*|\/\/.*</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>   <span class="token operator">!</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\s*\/</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// For "about" page, the first part of "src" can't be removed.</span>  <span class="token comment">// In addition, to support multi-level local directory.</span>  <span class="token keyword">var</span> linkArray <span class="token operator">=</span> link<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">elem</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> elem <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> srcArray <span class="token operator">=</span> src<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">elem</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> elem <span class="token operator">!=</span> <span class="token string">''</span> <span class="token operator">&amp;&amp;</span> elem <span class="token operator">!=</span> <span class="token string">'.'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>srcArray<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>srcArray<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  src <span class="token operator">=</span> srcArray<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>root <span class="token operator">+</span> link <span class="token operator">+</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span>info<span class="token operator">&amp;&amp;</span>console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"update link as:--&gt;"</span><span class="token operator">+</span>config<span class="token punctuation">.</span>root <span class="token operator">+</span> link <span class="token operator">+</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span>info<span class="token operator">&amp;&amp;</span>console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"no src attr, skipped..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span>info<span class="token operator">&amp;&amp;</span>console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>打开_config.yml文件，修改下述内容</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">post_asset_folder<span class="token operator">:</span> <span class="token boolean">true</span></code></pre><hr><p>然后，无论是自己创建MarkDown文件还是使用命令创建，如果传了图片，图片一定要保存到跟MarkDown文件名一致的文件夹中，然后在Markdown中通过相对路径来进行引用</p><p>好啦，问题解决的简单粗暴，希望大家能够相互帮助，在码农的世界里一起成长</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搜索功能</title>
      <link href="2018/01/24/hexo-sou-suo-gong-neng/"/>
      <url>2018/01/24/hexo-sou-suo-gong-neng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Hexo提供了一个插件来实现搜索的功能，但是，不知道什么原因，按照以下步骤操作，我的搜索功能还是没能实现</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript">npm install hexo<span class="token operator">-</span>generator<span class="token operator">-</span>search <span class="token operator">--</span>save</code></pre><p>然后在hexo根目录的<code>_config.yml</code>下添加：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">search<span class="token operator">:</span>  path<span class="token operator">:</span> search<span class="token punctuation">.</span>xml  field<span class="token operator">:</span> post  format<span class="token operator">:</span> html  limit<span class="token operator">:</span> <span class="token number">100</span></code></pre><p>在你的主题themes目录下找到<code>_config.yml</code>，然后添加:</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">local_search<span class="token operator">:</span>  enable<span class="token operator">:</span> <span class="token boolean">true</span>  trigger<span class="token operator">:</span> auto  top_n_per_article<span class="token operator">:</span> <span class="token number">1</span></code></pre><p>一般来说，这时候就已经可以实现搜索功能了，但是我遇到的错误比较奇怪，之后，经过一系列的试验，终于找到了解决办法</p><p>遇到难点的朋友们，可以尝试一下</p><p>找到你博客主题的<code>search.ejs</code>模板文件，注意是<code>ejs</code>,修改下面代码</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">&gt;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">searchFunc</span><span class="token punctuation">(</span><span class="token string">"&lt;%= config.root %&gt;"</span> <span class="token operator">+</span> <span class="token string">"search.xml"</span><span class="token punctuation">,</span> <span class="token string">'searchInput'</span><span class="token punctuation">,</span> <span class="token string">'searchResult'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></code></pre><p>也是改为json格式的文件</p><blockquote><p>现在的网上，基本上遇到一个问题，几乎回答全是千篇一律，毫无营养可言，只要一条路走不通，就走不通了，非常的让人抓狂，但是，还有不少真正的大神在认真的在为小白解答，遇到这种情况，希望不要浮躁，慢慢的寻找解决办法</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastAPI学习之路-2 SQLAlchemy</title>
      <link href="2018/01/15/fastapi-xue-xi-zhi-lu-2-sqlalchemy/"/>
      <url>2018/01/15/fastapi-xue-xi-zhi-lu-2-sqlalchemy/</url>
      
        <content type="html"><![CDATA[<h3 id="SQLAlchemy简介"><a href="#SQLAlchemy简介" class="headerlink" title="SQLAlchemy简介"></a>SQLAlchemy简介</h3><blockquote><p>它是一个ORM(Object-Relational Mapping)框架，是python最好的ORM工具之一，为高效和高性能的数据库访问设计，实现了完整的企业级持久模型</p><p>提示一点：ORM并非是非用不可，但是，为了代码的健壮性，我们最好还是使用ORM，一方面，为了提高开发效率，另一方面，为了使别人能够看懂代码。</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装sqlalchemy：</p><pre class="language-python" data-language="python"><code class="language-python">pip install sqlalchemy</code></pre><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><blockquote><p>所有的关系型数据库，都可以通过这样连接</p><pre class="language-none"><code class="language-none">'数据库类型+数据库驱动名称://用户名:密码@机器地址:端口号/数据库名'</code></pre><p>我们就拿mysql打个比方：</p></blockquote><blockquote><p>需要安装pymysql，因为引擎基于pymysql</p><p><code>pip install pymysql</code></p></blockquote><pre class="language-python" data-language="python"><code class="language-python"># 首先，导包from sqlalchemy import create_engine# 创建数据库连接connect = create_engine('mysql+pymysql://root:mySQL@localhost:3306/test01')# 可以顺便指定一下编码方式# create_engine('mysql+pymysql://root:mySQL@localhost:3306/test01?charset=utf8')</code></pre><p>这样，我们就能连接上数据库了</p><h4 id="描述表结构-模型"><a href="#描述表结构-模型" class="headerlink" title="描述表结构(模型)"></a>描述表结构(模型)</h4><blockquote><p>要使用 ORM, 我们需要将数据表的结构用 ORM 的语言描述出来。SQLAlchmey 提供了一套 Declarative 系统来完成这个任务。我们以创建一个 <code>user</code> 表为例，看看它是怎么用 SQLAlchemy 的语言来描述的</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">from sqlalchemy.ext.declarative import declarative_baseModelBase = declarative_base() #&lt;-元类class User(ModelBase):    # 定义表名    __tablename__ = "user"    # 声明字段    id = Column(Integer, primary_key=True)    username = Column(String(length=255))    password = Column(String(length=255))</code></pre><blockquote><p>这个模型，是对数据表结构的映射，无论是进行迁移文件还是操作数据库，都需要使用到它</p></blockquote><h4 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h4><blockquote><p>一对多，也就是我们所谓的外键，假如，有个user表，要求每个user都要有一个角色，我们就需要另外建立一张角色表，来通过外键连接角色表，用来实现关联，一个角色可以被多个user关联，一个user只能有一个角色，这，就是一对多的关系</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">class User(ModelBase):    # 定义表名    __tablename__ = "user"    # 声明字段    id = Column(Integer, primary_key=True)    username = Column(String(length=255))    password = Column(String(length=255))    role = Column(Integer,ForeignKey('role.id'))    class Role(ModelBase):    __tablename__ = 'role'    id = Column(Integer, primary_key=True)    name = Column(String(length=255))    isnn = relationship('User')</code></pre><blockquote><p>可以看到，我们定义了ForeignKey来指定关联哪张表，连接哪个字段</p><p>而“一”这里，提供了一个relationship方法来表明两个模型中的关系</p><p>而relationship有一个<code>backref</code>，来指定反向访问的属性名称，在我们的这个例子中，就是用来反向访问，都有哪些用户是这个角色</p></blockquote><hr><h4 id="添加数据（Create）"><a href="#添加数据（Create）" class="headerlink" title="添加数据（Create）"></a>添加数据（Create）</h4><p>我们依赖上方的代码来进行添加</p><pre class="language-python" data-language="python"><code class="language-python">from sqlalchemy.orm import sessionmaker# 创建DBSession类型DBSession = sessionmaker(bind=connect)# 创建session对象session = DBSession()# 创建新User对象(我们要添加的数据)new_user = User(id=1,username='Bob',password='123')# 添加到sessionsession.add(new_user)# 提交即保存到数据库session.commit()# 关闭sessionsession.close()</code></pre><blockquote><p>ok，执行一下，可以看到我们的数据库中已经有了这条数据</p></blockquote><img src="/2018/01/15/fastapi-xue-xi-zhi-lu-2-sqlalchemy/sss.png" alt="" style="zoom:70%;" loading="lazy">可见，关键是获取session，然后把对象添加到session，最后提交并关闭。`DBSession`对象可视为当前数据库连接。<hr><h4 id="查找数据（Retrieve）"><a href="#查找数据（Retrieve）" class="headerlink" title="查找数据（Retrieve）"></a>查找数据（Retrieve）</h4><blockquote><p>重新得到数据</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">user = session.query(User).filter(User.id==5).one()print(type(user))print('name',user.username)</code></pre><blockquote><p>这只是查找第一条</p><p>如果要获取多条，那么就可以将one换成all</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">user = session.query(User).filter(User.id==5).all()print(type(user))for i in user:    print(i.username)</code></pre><p>注意，因为获取多条，他的类型是列表，所以，我们需要处理一下</p><hr><h4 id="更新数据（Update）"><a href="#更新数据（Update）" class="headerlink" title="更新数据（Update）"></a>更新数据（Update）</h4><blockquote><p>首先呢，我们需要找出需要修改的数据，然后直接进行update修改</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">session.query(User).filter(User.id==1).update({'username':'haoye'{)session.commit()</code></pre><hr><h4 id="删除数据（delete）"><a href="#删除数据（delete）" class="headerlink" title="删除数据（delete）"></a>删除数据（delete）</h4><blockquote><p>操作和update一致，只是最后换成dalete</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">session.query(User).filter(User.id==1).delete()session.commit()</code></pre><hr><p>总结：最为简单的CRUD操作并没有什么难度，只是需要注意的是，为了节约内存资源，最好是做完操作之后，将session进行关闭</p><p>如果我们要学习除了django之外的web框架，几乎都离不开sqlachemy，所以，将sqlachemy学好收益还是非常大的</p>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastAPI </tag>
            
            <tag> SQLAchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastAPI学习之路-1</title>
      <link href="2018/01/05/fastapi-xue-xi-zhi-lu-1/"/>
      <url>2018/01/05/fastapi-xue-xi-zhi-lu-1/</url>
      
        <content type="html"><![CDATA[<h2 id="FastAPI框架"><a href="#FastAPI框架" class="headerlink" title="FastAPI框架"></a>FastAPI框架</h2><blockquote><p>FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，天生的支持异步(async)</p></blockquote><p>它的主要优势在于，高效，几乎可与NodeJS和Go比肩的极高性能，自动生成交互式的文档，省去了开发之后写文档的步骤</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>好了话不多说，我们从头开始，边学边补充吧，争取细到不能再细</p><p>首先是安装，安装非常的简单</p><pre class="language-python" data-language="python"><code class="language-python">pip install fastapipip install uvicorn</code></pre><p>好啦，完成之后，做一个基础的API吧</p><p> 创建py文件</p><pre class="language-python" data-language="python"><code class="language-python">from fastapi import FastAPI    app = FastAPI()    @app.get("/")async def root():    return {"message": "Hello World"}</code></pre><ul><li><p><code>from fastapi import FastAPI</code>这是一个python类，提供了<code>API</code>的所有功能</p></li><li><p><code>app=FastAPI()</code>将该类实例化</p></li><li><p><code>@app.get('/')</code>定义路径操作装饰器，告诉<code>FastAPI</code>是正下方的功能负责处理该请求,可用的其他方式：</p><pre class="language-python" data-language="python"><code class="language-python"> @app:get()@app.post()@app:put()@app:delete()@app.options()@app:head()@app:patch()@app:trace()</code></pre></li><li><p><code>async def root():</code>定义路径操作功能，带有<code>async</code>功能的函数</p></li><li><p><code>return {"message": "Hello World"{</code>返回内容，默认是一个<code>json</code>格式，还可以返回<code>dict、list、str、int</code>等类型，还可以返回<code>Pydantic</code>模型</p></li></ul><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><blockquote><p>在终端中输入<code>uvicorn main:app --reload</code></p><p>``main：main.py<code>文件 </code>app<code>：</code>app = FastAPI()<code>实例化的</code>FastAPI<code>对象 </code>–reload`:在代码更改后重新启动服务器</p></blockquote><p>第二种方法:</p><p>程序入口直接运行:</p><pre class="language-python" data-language="python"><code class="language-python">import uvicornif __name__ == '__main__':    uvicorn.run(app=app)    #还可以指定host，port等</code></pre><hr><h2 id="声明类型"><a href="#声明类型" class="headerlink" title="声明类型"></a>声明类型</h2><blockquote><p>FastAPI的类型声明使用的是  :</p></blockquote><p>做个例子:</p><pre class="language-python" data-language="python"><code class="language-python">from typing import strdef get_full_name(first_name,last_name):    full_name = first_name.title() + " " + last_name.title()    return full_name# 上面这是没加类型提示的def get_full_name(first_name: str, last_name: str):# 这事加了类型提示的，添加了这个类型提示不会改变原来的运行结果</code></pre><blockquote><p>这个呢，大家把它当做习惯就好了，无论是否使用这个框架的人 ，都能看懂传参需要什么类型</p><p>Optional:可选类型，例：q:Optional[str] = None<br>q类型可以为str也可以为None</p></blockquote><p>不只是str，能够声明所有标准python类型</p><p>比如：int float bool bytes</p><p>或者是：dict list set tuple</p><p>统统可以使用typing库来声明</p><pre class="language-python" data-language="python"><code class="language-python">from typing import List</code></pre><p>而，在List这些嵌套类型中，也可以声明其元素的类型，比如：</p><pre class="language-python" data-language="python"><code class="language-python">def process_items(items:List[str]):</code></pre><blockquote><p>Dict的key和value都可以各自声明</p></blockquote><blockquote><p>Optional:可选类型，例：q:Optional[str] = None<br>q类型可以为str也可以为None</p></blockquote><p>哦对，差点忘了，类，也是可以作为类型传递的</p><pre class="language-python" data-language="python"><code class="language-python">class Person:    def __init__(selfm,name:str):        self.name = namedef get_person_name(one:Person):    return one_person.name</code></pre><hr><h2 id="交互式文档"><a href="#交互式文档" class="headerlink" title="交互式文档"></a>交互式文档</h2><blockquote><p>交互式文档，在你启动的项目路径的docs下</p><p><code>127.0.0.1:8000/docs</code></p></blockquote><img src="/2018/01/05/fastapi-xue-xi-zhi-lu-1/image-20201125153555784.png" alt="" style="zoom:50%;" loading="lazy"><p>在网页：</p><img src="/2018/01/05/fastapi-xue-xi-zhi-lu-1/image-20201125153634050.png" alt="" style="zoom:50%;" loading="lazy"><p>这就是交互式文档的所在了，注意交互二字</p><img src="/2018/01/05/fastapi-xue-xi-zhi-lu-1/image-20201125153754643.png" alt="" style="zoom:50%;" loading="lazy"><blockquote><p>可以清楚的看到，传参，传的什么参，是否路径参数，一目了然</p></blockquote><p>也可以进入redoc来进入标准的API文档</p><img src="/2018/01/05/fastapi-xue-xi-zhi-lu-1/image-20201125153956180.png" alt="" style="zoom:50%;" loading="lazy"><hr><h2 id="查询参数和字符串验证"><a href="#查询参数和字符串验证" class="headerlink" title="查询参数和字符串验证"></a>查询参数和字符串验证</h2><p>要注意，到目前，我们在函数参数中传的，都只是params，也就是路径上的那种</p><blockquote><p>Query(查询参数)<br>Query第一个参数用来定义默认值</p></blockquote><blockquote><p>可用于限制长度或者正则表达式</p></blockquote><p>举个栗子:</p><pre class="language-python" data-language="python"><code class="language-python">#q参数必须为字符串，默认值为None，如果为...,则这个参数必须给值，最小长度3，最大长度50async def reds(q:str = Query(None,min_length=3,max+length=50)</code></pre><blockquote><p>注意!!!!此处只是参数，如果路径与参数一致，则不会生效</p></blockquote><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><blockquote><p>添加<code>regex</code>参数</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">async def reds(q:str = Query(None,min_length=3,max+length=50,regex='^nice'))</code></pre><h4 id="别名-alias"><a href="#别名-alias" class="headerlink" title="别名(alias)"></a>别名(alias)</h4><pre class="language-python" data-language="python"><code class="language-python">async def reds(q:str = Query(None,alias = 'asd'))</code></pre><blockquote><p>此时，参数名不再是q，而是<code>asd</code>，函数内部仍使用q</p></blockquote><h4 id="弃用参数-deprecated"><a href="#弃用参数-deprecated" class="headerlink" title="弃用参数(deprecated)"></a>弃用参数(deprecated)</h4><pre class="language-python" data-language="python"><code class="language-python"># 我自己测试得出结论，只是提醒作用，并不是不可写入# 写入Query中，可以改为弃用参数    deprecated = True</code></pre><h4 id="路径参数-path"><a href="#路径参数-path" class="headerlink" title="路径参数(path)"></a>路径参数(path)</h4><pre class="language-python" data-language="python"><code class="language-python">首先导入pathfrom fastapi import path#和Query使用方法类似，在参数定义之后添加@app.get("/items/{item_id}")async def read_items(item_id: int = Path(..., title="The ID of the item to get"))#注意，由于是路径参数，所以不能为空，所以，应该用...声明</code></pre><pre class="language-python" data-language="python"><code class="language-python">ge代表大于等于，le代表小于等于，gt代表大于，lt代表小于#将*作为函数第一个参数的话，那么这个函数内所有参数都是关键字参数kwargs，即便没有默认值举个例子，参数q不带默认值，而it参数带了pathasync def re(*,q:str,it:int = path(..., title="The ID of the item to get"))</code></pre><p>传递 <code>*</code> 作为函数的第一个参数。</p><p>Python 不会对该 <code>*</code> 做任何事情，但是它将知道之后的所有参数都应作为关键字参数（键值对），也被称为 <code>kwargs</code>，来调用。即使它们没有默认值。</p><hr><h2 id="pydantic"><a href="#pydantic" class="headerlink" title="pydantic"></a><code>pydantic</code></h2><p><code>FastAPI</code>内置的数据模型</p><pre class="language-python" data-language="python"><code class="language-python">from pydantic import BaseModelclass Item(BaseModel):    name:str    price:float    tax:float = Nonefrom pydantic import EmailStr#还提供了EmailStr类型，邮件地址类型</code></pre><p>类似Django内的<code>Model</code></p><h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><blockquote><p>参数中，如果参数=body(…)，则这个参数不会在<code>url</code>中，而是会出现在请求体中</p></blockquote><p>栗子：</p><pre class="language-python" data-language="python"><code class="language-python">class Item(BaseModel):    name:str    age:int    price:float@app.post("/items/ss")async  def root(a:Item=Body(...,embed=True)):         return {'item':a{</code></pre><pre class="language-python" data-language="python"><code class="language-python">嵌套请求体参数embed=True参数A=body(...,embed=True)则可以将参数A当做一个字典的键嵌套进请求体中，例：    A = body(...,embed=True)    {        A:{            q:1            w:2            e:3        {    {    不加embed效果:    {        q:1        w:2        e:3    {</code></pre><hr><h2 id="响应模型"><a href="#响应模型" class="headerlink" title="响应模型"></a>响应模型</h2><blockquote><p>response_model=<strong>**参数，此参数写在</strong>路径<strong>中，而不是</strong>函数**</p></blockquote><blockquote><p><code>response_model_exclude_unset = True</code>，返回数据模型中有的字段，没有的字段不返回</p><p><code>response_model_exclude = {某字段{</code>，返回时排除了某个字段</p><p><code>response_model_include = [某字段1,某字段2]</code>,返回时只包含其中的某字段</p></blockquote><p><code>**</code>是解包的意思<br>    假如有多个<code>BaseModel</code>，数据类型有相同的情况下，可以使用<code>.dict</code>形式相互传输数据<br>但是，前边加了<code>**</code></p><h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><pre class="language-python" data-language="python"><code class="language-python">from fastapi import status#如果报错的话，则使用starlette引入from starlette import status#可使用HTTP状态码#错误处理：from fastapi import HTTPException#在路径中@post(/itmes/, status_code=***)</code></pre>]]></content>
      
      
      <categories>
          
          <category> FastAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastAPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="2017/12/31/git-ji-ben-cao-zuo/"/>
      <url>2017/12/31/git-ji-ben-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="配置全局："><a href="#配置全局：" class="headerlink" title="配置全局："></a>配置全局：</h2><pre class="language-python" data-language="python"><code class="language-python">git config --global user.name "xxx"git config --global user.email "7618733+god_hearing@user.noreply.gitee.com"</code></pre><h2 id="上传到仓库："><a href="#上传到仓库：" class="headerlink" title="上传到仓库："></a>上传到仓库：</h2><ol><li><p>在码云或者<code>github</code>上创建仓库</p></li><li><p>仓库初始化(在本地)<br><code>git init</code></p></li><li><p>新建<code>readme.md</code>文件:<br><code>touch README.md</code></p></li><li><p>添加到本地缓冲区(.代表全部)<br><code>git add .</code></p></li><li><p>此时，也可以查看缓冲区状态<br><code>git status</code></p></li><li><p>添加注释<br><code>git commit -m'注释信息'</code></p><blockquote><p>一般，注释会使用<code>+ - * </code>等符号作为前缀，代表增加，删除，改动</p></blockquote></li><li><p>添加远程仓库地址<br><code>git remote add 自定义缓存名(origin) 码云地址</code></p></li><li><p>提交代码到远程仓库<br><code>git push origin master</code></p><blockquote><p>如果提示报错，不妨先试验一下<br><code>git push -u origin master -f</code></p></blockquote></li></ol><h2 id="克隆到本地："><a href="#克隆到本地：" class="headerlink" title="克隆到本地："></a>克隆到本地：</h2><p><code>git clone 地址</code></p><h2 id="Git分支命令"><a href="#Git分支命令" class="headerlink" title="Git分支命令"></a>Git分支命令</h2><blockquote><p>在一个庞大的项目中，只依靠自己，是写不完所有的命令的，这时候，就需要集合众人之力，东拼西凑，将项目做出来，如果所有人都将自己的想法给上传到线上，那么，很大的几率会发生冲突，因为一个人一个想法，不可能全部都一致，这时候，就需要分支站出来了</p><p>所谓的分支，就像是支线任务，你需要将所有的支线的全部做完，然后汇总到主线任务，才叫完成。 假若每个人都在自己做自己的支线任务，互不影响，最后再汇总，这样不仅会减少错误，还会很方便的分工合作。</p></blockquote><p>Git的分支，无论是在github还是gitee，使用方式是一样的</p><ul><li><code>git pull</code>：将所有的更新拉到本地仓库</li><li><code>git branch -r</code>：查看所有远程分支</li><li><code>git checkout</code> 分支名：切换分支</li><li><code>git branch</code>：查看当前在哪个分支</li><li><code>git merge</code> 分支名：本地合并</li></ul><blockquote><p>需要注意的是，在本地合并，一定要先确认在哪个分支下，merge后的分支名，是将哪个分支合并过来，一般会在主分支下，逐一合并子分支。</p><p>所以，首要任务，就是要保证子分支的代码没有任何的错误，然后再合并</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="2017/11/24/di-gui/"/>
      <url>2017/11/24/di-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><blockquote><p>递归，简单来说，就是自己调用自己，指在函数的定义中调用函数自身的方法</p><p>调用分为<strong>直接调用</strong>和<strong>间接调用</strong>，直接调用是指在函数体中调用自身，间接调用是调用别的函数，而这些别的函数又调用函数本身。它主要是把大问题变成小问题，使得代码更加简洁。理解递归需要有一定的抽象能力。</p><p>使用递归时，需要注意的是：</p><ul><li>递归就是在过程或函数里调用自身</li><li>必须有一个明确的递归结束条件，称为递归出口</li></ul><p><strong>切勿忘记递归的出口，否则就是无限循环</strong></p><p>著名的德罗斯特效应就是递归的一种视觉形式</p></blockquote><img src="/2017/11/24/di-gui/image-20201124201411737.png" alt=" " style="zoom:90%;" loading="lazy"><p>递归的过程分为，递归前进段，递归边界条件，递归返回段</p><p>递归的最大层次限制是998次，但是可以通过<code>sys</code>(System)模块下的<code>setrecursionlimit</code>方法来进行递归层次的扩大</p><p>递归函数的优点是定义简单，逻辑清晰，但是，过深的调用会导致栈溢出</p><h2 id="递归实现高斯求和"><a href="#递归实现高斯求和" class="headerlink" title="递归实现高斯求和"></a>递归实现高斯求和</h2><blockquote><p>代码实现高斯求和，如果是按照正常方式实现，那么就是这样的</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">def sum_number(n):    total = 0    for i in range(1,n+1):        total += i    return total</code></pre><blockquote><p>非常的简单，但是这样做，流程是这样的，假设我们传参5</p></blockquote><img src="/2017/11/24/di-gui/image-20201124203210068.png" style="zoom:67%;" loading="lazy"><p>同样是计算5，我们用递归实现：</p><pre class="language-python" data-language="python"><code class="language-python">def sum_numbers(n):    if n &lt;= 0:        return 0    return n+sum_numbers(n-1)</code></pre><blockquote><p>可以看到，我们并不是从1开始加到5，而是逆向的思维，从5开始，逐渐的递减，直到边界条件触发，也就是，如果为0，则停止递归</p></blockquote><img src="/2017/11/24/di-gui/image-20201124203529172.png" alt=" " style="zoom:67%;" loading="lazy"><hr><blockquote><p>但是，这样会造成一个后果，就是内存的耗费问题，因为递归需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）</p></blockquote><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><blockquote><p>对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。</p><p>如果按照上方的递归，计算需要保存n个调用记录，复杂度为O(n)</p></blockquote><p>也就是：</p><pre class="language-python" data-language="python"><code class="language-python">5 + sum_numbers(4)5 + (4 + sum_numbers(3))5 + (4 (3 + sum_numbers(2))5 + (4 (3 (2 + sum_numbers(1))</code></pre><p>在内存中，需要存储5次，非常的耗费</p><p>让我们用尾递归来实现一下，看一下有什么不同</p><pre class="language-python" data-language="python"><code class="language-python">def tail_sum(n,result=0):    if n &lt;= 0:        return result    else:        tail_sum(n-1,result+n)</code></pre><blockquote><p>我们给定义了一个最终数<code>result</code>，每次调用，不再存储到内存中，而是将结果存到<code>result</code>中，这样，只在运行结束的瞬间，存储一次，其他时间，只是存储了状态，如下：</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">tail_sum(5,0)tail_sum(4,5)tail_sum(3,9)tail_sum(2,12)tail_sum(1,14)tail_sum(0,15)</code></pre><p>再实现一下斐波那契</p><pre class="language-python" data-language="python"><code class="language-python">def feibonacci(n):    if n &lt;= 2:        return 1    else:        return feibonacci(n-1) + feibonacci(n-2)</code></pre><p>总结一下， 递归最核心的思想是：<strong>每一次递归，整体问题都要比原来减小，并且递归到一定层次时，要能直接给出结果！</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成器和迭代器</title>
      <link href="2017/11/20/sheng-cheng-qi-he-die-dai-qi/"/>
      <url>2017/11/20/sheng-cheng-qi-he-die-dai-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote><p>迭代，是访问集合内元素的一种方式。要理解迭代器，首先要理解可迭代对象，所谓可迭代对象，通俗的 说就是可以被for循环遍历的对象就是可迭代对象</p><p>任何内置了<code>iter</code>方法的，都是可迭代的对象，例如，<code>list</code>、<code>set</code>、<code>dict</code>、<code>tuple</code>等都是可迭代对象</p></blockquote><h4 id="迭代的概念"><a href="#迭代的概念" class="headerlink" title="迭代的概念"></a>迭代的概念</h4><blockquote><p>相信大家都玩过游戏，每一次游戏更新迭代，都是新增了一些功能，调整了什么，迭代就是这个概念，在python中，上一次输出的结果为下一次输入的初始值，重复的过程就称为迭代。</p><p>就好像我们游戏更新一样，都是继上一次的版本为初始的情况下，增加一些新的东西，同理，每次迭代的结果是下一次迭代的初始值。</p></blockquote><p>那么，问题来了，为什么要有迭代器，因为，对于没有索引的数据类型，必须提供一种不依赖索引的迭代方式，这个方式就是迭代器。</p><h4 id="迭代器定义"><a href="#迭代器定义" class="headerlink" title="迭代器定义"></a>迭代器定义</h4><p>迭代器，就是<strong>可迭代对象</strong>执行<code>iter</code>方法，得到的结果就是<strong>迭代器</strong>，迭代器对象有<code>next</code>方法。它是一个状态的对象，它能在你调用你next()方法的时候返回容器中的下一个值，如果容器中没有更多的元素了，则会抛出<code>StopIteration</code>(停止迭代异常)</p><p>我们常用的for循环，其实它的本质就是：</p><ol><li>利用iter函数得到函数</li><li>利用next函数依次取值</li><li>捕获异常</li></ol><p>手写一个迭代器</p><pre class="language-python" data-language="python"><code class="language-python">class Csmt:def __init__(self):# 初始化可迭代对象和numself.name = []self.num = 0def add(self,na):# 添加元素self.name.append(na)def __iter__(self):# 调用iter方法，返回自身return selfdef __next__(self):# 如果 num小于name的长度if self.num &lt; len(self.name):# 从0开始，取出可迭代对象中的元素ret = self.name[self.num]# 同时，往后移一位self.num += 1# 返回return retelse:# 没有元素，抛出异常raise StopIterationc = Csmt()c.add('AAA')c.add('BBB')c.add('CCC')for i in c:print(i)</code></pre><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote><p>生成器是一个特殊的迭代器，它的实现更简单，<strong>yield</strong>，就是生成器实现next()方法的关键，它作为生成器执行的暂停恢复点，可以对<strong>yield</strong>表达式进行赋值，也可以将yield表达式的值返回</p><p>也就是说，yield是一个语法糖，内部实现了支持迭代器协议，同时yield内部是一个状态机，维护着挂起和继续的状态</p><p> 也就是说，一边循环，一边计算的机制，就是生成器。</p></blockquote><h4 id="为什么要有生成器"><a href="#为什么要有生成器" class="headerlink" title="为什么要有生成器"></a>为什么要有生成器</h4><p>假如你有一个海量的列表，你要读取中间的某些元素，那后面的绝大多数元素占用的空间都白白浪费了，如果使用生成器，在得到你需要的数据之后就停止，就没有必要创建完整的list，从而节省大量的空间。</p><h4 id="生成器如何定义"><a href="#生成器如何定义" class="headerlink" title="生成器如何定义"></a>生成器如何定义</h4><p>第一种方式</p><ul><li>在函数中添加yield关键字，这个函数就是生成器</li></ul><p>第二种方式</p><ul><li>将列表推导式的[ ] 变成 ( )</li></ul><h4 id="获取生成器的数据"><a href="#获取生成器的数据" class="headerlink" title="获取生成器的数据"></a>获取生成器的数据</h4><ol><li>利用for循环获取迭代器数据</li><li>利用while和异常捕获</li><li>利用list、tuple类型转换</li></ol><h4 id="生成器唤醒方式"><a href="#生成器唤醒方式" class="headerlink" title="生成器唤醒方式"></a>生成器唤醒方式</h4><blockquote><p>由于生成器是函数暂停执行实现的，那么，我们唤醒生成器就需要使用next()来取值</p><p>或者使用<code>__next__</code>魔法方法</p><p>还可以使用<code>send()</code>函数，它可以将数据作为参数传递到生成器内部，需要<strong>注意</strong>的一点是，<code>send</code>不能作为第一次唤醒时使用</p></blockquote><h4 id="实现生成器"><a href="#实现生成器" class="headerlink" title="实现生成器"></a>实现生成器</h4><pre class="language-python" data-language="python"><code class="language-python">a = (i for i in range(1,11))print(a)for i in a:print(i)'''&lt;generator object &lt;genexpr&gt; at 0x000001BEBA62E448&gt;1，2，3，4，5，6，7，8，9，10'''</code></pre><p>好啦，分享到此结束</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis中pipline的使用</title>
      <link href="2017/11/03/redis-de-pipline-shi-yong/"/>
      <url>2017/11/03/redis-de-pipline-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>redis<strong>发送数据原理</strong></p><ul><li><p>Redis是建立在TCP协议基础上的CS架构，客户端client对redis server采取请求响应的方式交互。</p></li><li><p>一般来说客户端从提交请求到得到服务器相应，需要传送两个tcp报文。</p></li><li><p>设想这样的一个场景，你要批量的执行一系列redis命令，例如执行100次get key，这时你要向redis</p><p>请求100次+获取响应100次。如果能一次性将100个请求提交给redis server，执行完成之后批量的获</p><p>取相应，只需要向redis请求1次，然后批量执行完命令，一次性结果，性能是不是会好很多呢？</p></li></ul><p><strong>未使用</strong>pipeline<strong>执行</strong>N<strong>条命令</strong></p><p><img src="/2017/11/03/redis-de-pipline-shi-yong/20201008110134859.png" loading="lazy"></p><p><strong>使用了</strong>pipeline<strong>执行</strong>N<strong>条命令</strong></p><p><img src="/2017/11/03/redis-de-pipline-shi-yong/20201008110151342.png" loading="lazy"></p><p>pipeline<strong>性能代码展示</strong></p><pre class="language-python" data-language="python"><code class="language-python">from django_redis import get_redis_connectionredis_client = get_redis_connection('default')'''普通方法执行'''for i in range(99999):    redis_client.set(i,i)    '''使用pipeline执行'''    p1 = redis_client.pipeline()# 实例化一个pipeline对象for i in range(99999):    p1.set(i,i)p1.execute()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django配置</title>
      <link href="2017/11/01/django-pei-zhi/"/>
      <url>2017/11/01/django-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>django作为python中的重型web框架，在开始学习django的时候，一定是非常痛苦的，连文件配置都搞不清，更不要提写功能了，今天这篇文章主要讲解一下django的配置问题</p></blockquote><h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><blockquote><p>settings作为django的配置文件，其中的东西可以说是面面俱到的影响着整个项目，这个文件不需要创建，在你创建项目的时候，他自然会被创建，那让我们来看一下，这个settings中，可以配置什么</p></blockquote><ul><li><p><code>SECRET_KEY</code>，每个django项目都会有自己的密钥，方便了使用jwt加密等</p></li><li><p><code>DEBUG</code>，这个呢，是开发人员的DEBUG模式，也就是开发模式，正常情况下，在项目上线之前，要把这个改为False，否则一旦你网站全部的url泄露出去，那后果可是不堪设想</p></li><li><p><code>ALLOWED_HOSTS</code>，这个是为了限定请求中的host值，以防止黑客构造包来发送请求，只有在列表中的host才能访问</p><blockquote><p>注意，本人在这里强烈建议不要使用<code>*</code>通配符去配置，另外当DEBUG设置为False的时候，必须配置这个配置，否则会抛出异常。</p><p>后面所跟的属性值是一个<strong>字符串列表值</strong>，这个字符串列表值表示当下这个Django站点可以提供的<code>host/domain</code>(主机/域名)。这是一种安全措施，<strong>通过使用伪造的HTTP主机标头提交请求来防止攻击者中毒缓存并触发带有恶意主机链接的密码重置电子邮件</strong>，即使在许多看似安全的Web服务器配置下也是如此</p></blockquote></li><li><p><code>INSTALLED_APPS</code>，一般就是存放app和一些django的插件，比如跨域或者DRF</p></li><li><p><code>MIDDLEWARE</code>：听名字就知道，这是中间件层，一些自定义的中间件也要在这里注册</p></li><li><p><code>ROOT_URLCONF</code>,URL是Web服务的入口，用户通过浏览器发送过来的任何请求，都是发送到一个指定的URL地址，然后被响应，决定哟啊使用的根URLconf模块，通常，这是ROOT_URLFONF设置的值，但是如果传入的HttpRequest对象具有urlconf属性(由中间件设置),则其值将被用于代替ROOT_URLCONF设置，<strong>通俗的讲</strong>，就是你可以自定义项目入口url是哪个文件</p></li><li><p><code>TEMPLATES</code>：模板，在做一些前后端不分离的项目时，会使用到。</p></li><li><p><code>WSGI_APPLICATION</code>：wsgi的配置，一般不需要动</p></li><li><p><code>DATABASES</code>:数据库，这里可以连接关系型数据库，例如Mysql，PosrgrelSQL</p></li><li><p><code>AUTH_PASSWORD_VALIDATORS</code>：弱密码校验，这里会有四个自带的校验器，当然也可以自己写校验器，只需要按照下述格式添加进去就可以做统一校验</p></li><li><p>然后剩下的这些，都是本地化的一些配置</p><pre class="language-python" data-language="python"><code class="language-python">LANGUAGE_CODE = 'zh-hans'  # 语言，这里改为了中文TIME_ZONE = 'Asia/Shanghai' # 时区，改为亚洲上海即可USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False  # 弃用格林威治时间</code></pre></li><li><p>STATIC_ROOT，新增的，该目录下面的文件会被当成静态文件处理，与STATIC_ROOT搭配使用的还有STATIC_URL，一般默认采用<code>/static/</code>，用于你指定静态目录的URL。</p></li><li><p>STATICFILES_DIRS，制定了一个工程里面哪个目录存放了与这个工程相关的静态文件，这是一个列表</p><pre class="language-python" data-language="python"><code class="language-python">STATIC_URL = '/static/'STATICFILES_DIRS=[     os.path.join(BASE_DIR,'static')]</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRF操作</title>
      <link href="2017/11/01/drf-cao-zuo/"/>
      <url>2017/11/01/drf-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h3 id="1-DRF初始化"><a href="#1-DRF初始化" class="headerlink" title="1.DRF初始化"></a>1.DRF初始化</h3><p>DRF六中常用操作</p><pre class="language-python" data-language="python"><code class="language-python">1.认证2.权限3.限流4.序列化5.分页6.版本</code></pre><h4 id="1-1安装DjangoRestFramework"><a href="#1-1安装DjangoRestFramework" class="headerlink" title="1.1安装DjangoRestFramework"></a>1.1安装DjangoRestFramework</h4><pre class="language-python" data-language="python"><code class="language-python">pip install djangorestframework==3.11.1pip install django-filter==2.3.8  #过滤器pip install markdown # markdown support for the browsable API123</code></pre><h4 id="1-2在syl-settings-py中注册"><a href="#1-2在syl-settings-py中注册" class="headerlink" title="1.2在syl/settings.py中注册"></a>1.2在syl/settings.py中注册</h4><pre class="language-python" data-language="python"><code class="language-python">INSTALLED_APPS = ['django_filters','rest_framework']1234</code></pre><h3 id="1-3-在settings-py中配置"><a href="#1-3-在settings-py中配置" class="headerlink" title="1.3 在settings.py中配置"></a>1.3 在settings.py中配置</h3><pre class="language-python" data-language="python"><code class="language-python"># 过滤器# 1,安装 django-filter# 2,注册应用# 3,配置settings, 在view里配置可过滤的字段# 4,使用 查询字符串携带过滤信息REST_FRAMEWORK = {    # 文档报错： AttributeError: ‘AutoSchema’ object has no attribute ‘get_link’    # 用下面的设置可以解决    'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.AutoSchema',    # 默认设置是:    # 'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.openapi.AutoSchema',    # 异常处理器    # 'EXCEPTION_HANDLER': 'user.utils.exception_handler',    # Base API policies    'DEFAULT_RENDERER_CLASSES': [        'rest_framework.renderers.JSONRenderer',        'rest_framework.renderers.BrowsableAPIRenderer',    ],    'DEFAULT_PARSER_CLASSES': [        'rest_framework.parsers.JSONParser',        'rest_framework.parsers.FormParser',        'rest_framework.parsers.MultiPartParser'    ],    # 1.认证器（全局）    'DEFAULT_AUTHENTICATION_CLASSES': [        'rest_framework.authentication.SessionAuthentication',  # 使用session时的认证器        'rest_framework.authentication.BasicAuthentication'     # 提交表单时的认证器    ],    #2.权限配置（全局）： 顺序靠上的严格    'DEFAULT_PERMISSION_CLASSES': [        # 'rest_framework.permissions.IsAdminUser',  # 管理员可以访问        # 'rest_framework.permissions.IsAuthenticated',  # 认证用户可以访问        # 'rest_framework.permissions.IsAuthenticatedOrReadOnly',  # 认证用户可以访问, 否则只能读取        # 'rest_framework.permissions.AllowAny',  # 所有用户都可以访问    ],    #3.限流（防爬虫）    'DEFAULT_THROTTLE_CLASSES': [        'rest_framework.throttling.AnonRateThrottle',        'rest_framework.throttling.UserRateThrottle',    ],    #3.1限流策略    'DEFAULT_THROTTLE_RATES': {        'user': '100/hour',    # 认证用户每小时100次        'anon': '3/day',       # 未认证用户每天能访问3次    {,    'DEFAULT_CONTENT_NEGOTIATION_CLASS': 'rest_framework.negotiation.DefaultContentNegotiation',    'DEFAULT_METADATA_CLASS': 'rest_framework.metadata.SimpleMetadata',    'DEFAULT_VERSIONING_CLASS': None,    #4.分页（全局）：全局分页器, 例如 省市区的数据自定义分页器, 不需要分页    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',    # 每页返回数量    'PAGE_SIZE': 10,  # 默认 None    #5.过滤器后端    'DEFAULT_FILTER_BACKENDS': [        'django_filters.rest_framework.DjangoFilterBackend',        # 'django_filters.rest_framework.backends.DjangoFilterBackend', 包路径有变化    ],    #5.1过滤排序（全局）：Filtering 过滤排序    'SEARCH_PARAM': 'search',    'ORDERING_PARAM': 'ordering',    'NUM_PROXIES': None,    #6.版本控制：Versioning  接口版本控制    'DEFAULT_VERSION': None,    'ALLOWED_VERSIONS': None,    'VERSION_PARAM': 'version',    # Authentication  认证    # 未认证用户使用的用户类型    'UNAUTHENTICATED_USER': 'django.contrib.auth.models.AnonymousUser',    # 未认证用户使用的Token值    'UNAUTHENTICATED_TOKEN': None,    # View configuration    'VIEW_NAME_FUNCTION': 'rest_framework.views.get_view_name',    'VIEW_DESCRIPTION_FUNCTION': 'rest_framework.views.get_view_description',    'NON_FIELD_ERRORS_KEY': 'non_field_errors',    # Testing    'TEST_REQUEST_RENDERER_CLASSES': [        'rest_framework.renderers.MultiPartRenderer',        'rest_framework.renderers.JSONRenderer'    ],    'TEST_REQUEST_DEFAULT_FORMAT': 'multipart',    # Hyperlink settings    'URL_FORMAT_OVERRIDE': 'format',    'FORMAT_SUFFIX_KWARG': 'format',    'URL_FIELD_NAME': 'url',    # Encoding    'UNICODE_JSON': True,    'COMPACT_JSON': True,    'STRICT_JSON': True,    'COERCE_DECIMAL_TO_STRING': True,    'UPLOADED_FILES_USE_URL': True,    # Browseable API    'HTML_SELECT_CUTOFF': 1000,    'HTML_SELECT_CUTOFF_TEXT': "More than {count{ items...",    # Schemas    'SCHEMA_COERCE_PATH_PK': True,    'SCHEMA_COERCE_METHOD_NAMES': {        'retrieve': 'read',        'destroy': 'delete'    {,{</code></pre><h4 id="1-4创建user-serializer-py写序列化器"><a href="#1-4创建user-serializer-py写序列化器" class="headerlink" title="1.4创建user/serializer.py写序列化器"></a>1.4创建user/serializer.py写序列化器</h4><pre class="language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-from rest_framework import serializersfrom user.models import Userdef address_validate(data):    # 独立校验器    # raise serializer.ValidationError(‘请填写实际地址’) # 有错就抛出异常    # 没错就返回数据    return dataclass UserSerializer (serializers.ModelSerializer):    # 1.独立校验器：重新设定字段，替掉模型中的设定，重新设定地址的长度最小为5    address = serializers.CharField(max_length=255,min_length=5,validators=[address_validate])    #2.单一字段验证，验证地址    def validate_address(self,data):        if data == '测试':            raise serializers.ValidationError('请填写实际地址') # 有错就抛出异常        return data # 没错返回结果    def validate_phone(self,data):        # 不符合手机号格式        # raise serializer.ValidationError("手机号格式不正确")            model  =self.root.Meta.model            num = model.object.filter(phone=data).count()            if num &gt; 0:                raise  serializers.ValidationError('手机好已存在')            return data    # 3. 所以属性验证器    def validate(self,attrs):        # attrs:{“user”:“zhangsan”,"phone":"17563734847",...{        # 所有属性验证器        # self.context中有request和view上下午        # attrs 是需要序列化的数据        # raise serializer.ValidationsError('xxx.错误') # 有问题报错        return attrs # 没问题返回数据    class Meta:        model = User        # fields = ('id') # 临时添加字段也需要写在这里        fields = '__all__' # 所有字段        # exclude = ['id'] # 排除id字段        read_only_fields = ('',) # 指定字段为 read_only,        # 扩展address：extra_kwargs = {{ # 局部替换某些字段，或者新增设定        extra_kwargs = {            'address':{                'min_length' :5 ,# 给地址增加最小长度限制                'default' :'默认测试地址', # 增加默认值            {        {</code></pre><h4 id="2-DRF认证、权限、限流、分页、过滤、序列化-排序"><a href="#2-DRF认证、权限、限流、分页、过滤、序列化-排序" class="headerlink" title="2.DRF认证、权限、限流、分页、过滤、序列化 排序"></a>2.DRF认证、权限、限流、分页、过滤、序列化 排序</h4><pre class="language-python" data-language="python"><code class="language-python"># -*- coding: utf-8 -*-from django.urls import include,pathfrom user import viewsfrom rest_framework.routers import SimpleRouter,DefaultRouter# 自动生产路由方法，必须使用视图集# router = SimpleRouter（） # 没有跟根路由 /user/ 无法识别router = DefaultRouter() # 有跟路由router.register(r'user',views.UserViewSet) # 配置路由urlpatterns = [    path('index/',views.index),    path('api-auth/',include('rest_framework.urls',namespace='res_framework'))  # 认证地址]urlpatterns+= router.urls # 模块地址</code></pre><h4 id="2-2-编写user-views-py"><a href="#2-2-编写user-views-py" class="headerlink" title="2.2 编写user/views.py"></a>2.2 编写user/views.py</h4><pre class="language-python" data-language="python"><code class="language-python">from django.shortcuts import renderfrom django.http import HttpResponsefrom django_filters.rest_framework import DjangoFilterBackendfrom rest_framework import viewsetsfrom rest_framework.authentication import BasicAuthentication,SessionAuthenticationfrom rest_framework.decorators import actionfrom rest_framework.filters import OrderingFilterfrom rest_framework.permissions import AllowAny,IsAdminUser,IsAuthenticated,IsAuthenticatedOrReadOnlyfrom rest_framework.response import Responsefrom rest_framework.throttling import UserRateThrottlefrom rest_framework.pagination import PageNumberPaginationfrom rest_framework.views import APIViewfrom rest_framework.permissions import BasePermission,SAFE_METHODSfrom user.models import Userfrom user.serializer import UserSerializer# Create your views here.def index(request):    #需要认证才能访问的视图    return HttpResponse('HELLO')# 分页（局部）: 自定义分液器，局部class PageNum(PageNumberPagination):    # 查询字符串中代表每页返回数据量的参数名，默认值：None    page_size_query_param =  'page_size'    # 查询字符串中代表页码的参数名，有默认值：page    # page_query_param = 'page'    # 一页中最多的结果条数    max_page_size = 2# 自定义权限(局部）class MyPermission(BasePermission):    def has_permission(self, request, view):        print(view.kwargs.get('pk'),request.user.id)        '''判断用户对模型有没有访问权限'''        # 任何用户对使用此类权限的视图都有访问权限        print(request)        if request.user.is_superuser:            # 管理员对用户模型有访问权限            return True        elif view.kwargs.get('pk') == str(request.user.id):            # 携带的id和用户的id相同时有访问权限            return True        return False        def has_object_permission(self, request, view, obj):        '''获取单个数据时，判断用户对某个数据对象时否有访问权限'''        if request.user.id == obj.id:            return True        return Falseclass UserViewSet(viewsets.ModelViewSet):    """    完成产品的增删改查    """    queryset = User.objects.all()    serializer_class = UserSerializer # 优先使用 get_serializer_class 返回的序列化器        # # 1.认证： 自定义认证类，自定义会覆盖全局配置    # authentication_classes = (BasicAuthentication,SessionAuthentication)    # # 2.权限认证： 自定义权限类    # permission_classes = (MyPermission)        #3.分页： 自定义分页器  覆盖全局配置    pagination_class = PageNum        # 4.限流：自定义限流类    parser_classes = [UserRateThrottle]        #5. 过滤： 指定过滤方法类，拍下方法类，一个或多个    filter_backends =  (DjangoFilterBackend,OrderingFilter)  # 同时支持过滤和排序    # 5.1 指定排序字段，不设置，排序功能不起效    ordering_fileds = ('date_joined','id')  # ?ordering = -id    # 5.2指定过过滤字段，不设置，过滤功能不起效    filter_fields = ('username','phone','is_active') #?username = tom&amp;phone=is_active=tur        # # 根据不同的请求，获得不同的序列化器    # def get_serializer_class(self):    #     if self.action == 'unactived':    #         return UserUnActiveSerializer    #     else:    #         return UserSerializer</code></pre>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>倒排索引与全文检索</title>
      <link href="2017/10/30/dao-pai-suo-yin-yu-quan-wen-jian-suo/"/>
      <url>2017/10/30/dao-pai-suo-yin-yu-quan-wen-jian-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><hr><blockquote><p>一个未经处理的数据库中，一般是以文档ID作为索引，文档内容作为记录</p><p>而倒排索引指的是，将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过索引来查找到其所在的文档</p></blockquote><p>例如：</p><p><img src="/2017/10/30/dao-pai-suo-yin-yu-quan-wen-jian-suo/image-20201016112650646.png" loading="lazy"></p><ul><li>简单来说，普通的查询检索是通过文档查找关键词，而倒排索引就是通过关键词找到文档</li></ul><h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><p>将数据库中的<strong>结构化数据</strong>数据转换为<strong>非结构化</strong>数据</p><p>然后将<strong>非结构化数据</strong>转化为分词结构</p><hr><h1 id="Django使用haystack"><a href="#Django使用haystack" class="headerlink" title="Django使用haystack"></a><code>Django</code>使用haystack</h1><ul><li><p>haystack是<code>django</code>的开源搜索框架，该框架支持 <code>Solr,Elasticsearch,Whoosh, Xapian</code>搜索引擎，不用更改代码，直接切换引擎，减少代码量。</p></li><li><p>搜索引擎使用Whoosh，这是一个由纯Python实现的全文搜索引擎，没有二进制文件等，比较小</p><p>巧，配置比较简单，当然性能自然略低。</p></li><li><p>中文分词<code>Jieba</code>，由于Whoosh自带的是英文分词，对中文的分词支持不是太好，故用jieba替换</p><p>whoosh的分词组件。</p></li></ul><h4 id="配置与使用："><a href="#配置与使用：" class="headerlink" title="配置与使用："></a>配置与使用：</h4><p><code>syl/settings.py</code> <strong>全文检索配置</strong> </p><pre class="language-python" data-language="python"><code class="language-python">'''1.注册app ''' INSTALLED_APPS = [     'haystack', # haystack要放在应用的上面 ]'''2.模板路径 '''TEMPLATES = [    {        'DIRS':[os.path.join(BASE_DIR,'templates')],    {]'''3.全文检索配置'''HAYSTACK_SEARCH_RESULTS_PER_PAGE = 15 # 搜索出多条数据时需要分页HAYSTACK_CONNECTIONS = {    'default': {        'ENGINE': 'course.whoosh_cn_backend.MyWhooshEngine',        'PATH': os.path.join(BASE_DIR, 'whoosh_index'), # 指定倒排索引存放位置    {{# # ES引擎 # HAYSTACK_CONNECTIONS = { # 'default': {# 'ENGINE': 'haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine',     # 'URL': 'http://10.211.55.15:9200/',  # Elasticsearch服务器ip地址，端口号固 定为9200         # 'INDEX_NAME': 'syl', # Elasticsearch建立的反向索引库的名称         # {, # { # 添加此项，当数据库改变时，会自动更新索引，非常方便 HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor'</code></pre><ul><li><strong>子应用下创建索引文件<code>apps/course/search_indexes.py</code></strong></li></ul><pre class="language-python" data-language="python"><code class="language-python"># apps/course/search_indexes.py# 文件名必须是 search_indexes.pyfrom haystack import indexesfrom .models import Course# 修改此处，类名为模型类的名称+Index，比如模型类为GoodsInfo,则这里类名为GoodsInfoIndex(其 实可以随便写)class CourseIndex(indexes.SearchIndex, indexes.Indexable):    """ Course索引类 """    # text为索引字段 # document = True，这代表haystack和搜索引擎将使用此字段的内容作为索引进行检索    # use_template=True 指定根据表中的那些字段建立索引文件的说明放在一个文件中    text = indexes.CharField(document=True, use_template=True)    # 对那张表进行查询    def get_model(self): # 重载get_model方法，必须要有        """返回建立索引的模型类"""        return Course   # 返回这个model    # 建立索引的数据    def index_queryset(self, using=None):        """返回要建立索引的数据查询集"""        # 这个方法返回什么内容，最终就会对那些方法建立索引，这里是对所有字段建立索引        return self.get_model().objects.all()</code></pre><ul><li><strong>指定索引模板文件</strong></li></ul><p><code>templates/search/indexes/course/course_text.txt </code></p><p><code>创建文件路径命名必须这个规范：templates/search/indexes/应用名称/模型类名称 text.txt</code></p><pre class="language-python" data-language="python"><code class="language-python">{{object.id{{ {{object.title{{ {{object.desc{{</code></pre><ul><li><strong>修改为<code>jieba</code>分词中的中文分析器</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python"># apps/course/whoosh_cn_backend.py# 更换 text 字段的 分析方式, 变为jieba分词中的中文分析器from haystack.backends.whoosh_backend import WhooshEngine, WhooshSearchBackendfrom whoosh.fields import TEXTfrom jieba.analyse import ChineseAnalyzerclass MyWhooshSearchBackend(WhooshSearchBackend):    def build_schema(self, fields):        (content_field_name, schema) = super().build_schema(fields)        # 指定whoosh使用jieba进行分词        schema._fields['text'] = TEXT(stored=True,                                      analyzer=ChineseAnalyzer(),                                      field_boost=fields.get('text').boost,                                      sortable=True)        return (content_field_name, schema)class MyWhooshEngine(WhooshEngine):    backend = MyWhooshSearchBackend</code></pre><ul><li><strong>课程全文检索接口视图函数</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python"># course/views.pyfrom syl import settings from django.core.paginator import InvalidPage, Paginator from haystack.forms import ModelSearchForm from django.http import JsonResponse# 如果settings.py中配置就是用settings中配置的，否则就每页15条RESULTS_PER_PAGE = getattr(settings, 'HAYSTACK_SEARCH_RESULTS_PER_PAGE', 15)def course_index_search(request):    query = request.GET.get('q', None)    page = int(request.GET.get('page', 1))# 第几页    page_size = int(request.GET.get('page_size', RESULTS_PER_PAGE))# 每页多少条    if query:        form = ModelSearchForm(request.GET, load_all=True) # 将查询条件传递给查询对 象        if form.is_valid():            results = form.search() # 查询出来的最终数据        else:            results = []    else:        return JsonResponse({"code": 404, "msg": 'No file found！', "data": []{)    # 对结果集进行分页    paginator = Paginator(results, page_size)    try:        page = paginator.page(page) # 从分好的页中拿第几页    except InvalidPage: # 如果分页出错        return JsonResponse({"code": 404, "msg": 'No file found！', "data": []{)    jsondata = []    for result in page.object_list: # 分页后的课程查询结果        data = {            'id': result.object.id,            'title': result.object.title,            'desc': result.object.desc,            'img':                request.scheme + '://' + request.META['HTTP_HOST'] + result.object.img.url,            # 'follower': result.object.follower,            'learner': result.object.learner,            'status': result.object.status,            'course_type': result.object.course_type.id        {        jsondata.append(data)    result = {        "code": 200,        "msg": 'Search successfully！',        "data": {"count": page.paginator.count, "results": jsondata{    {    return JsonResponse(result)</code></pre><ul><li><strong><code>syl/urls.py</code>添加路由</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python">urlpatterns = [     path('search/', course_index_search), ]</code></pre><ul><li><strong>命令创建倒排索引</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python">python manage.py rebuild_index</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Django </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈进程和线程</title>
      <link href="2017/09/15/qian-tan-jin-cheng-he-xian-cheng/"/>
      <url>2017/09/15/qian-tan-jin-cheng-he-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>相信大家在刚开始接触三程的时候会懵逼，进程和线程是操作系统的基本概念，但是他们比较抽象，不容易掌握。今天来细细的解释一下进程和线程，关于协程之后有时间会独自出一篇。</p></blockquote><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><blockquote><p>在谈到进程的时候，大家总说的一句话就是，进程是操作系统分配资源的最小单位，这句话理论上没有什么问题，但是对新手不友好。</p><p>首先我们一点点的说，从什么是进程开始吧</p></blockquote><p>进程呢，就是一个将一个程序放入到内存中，从CPU和内存中申请进程资源，从而运行起来，这个运行起来的程序，就是进程，举个例子，进程就好像一座超市，而CPU呢，就好像给超市供电的发电站，假设发电站电力有限，只能供给一座超市，当一个超市正常运行时，其他的超市就得停，就是说，单个CPU只能一次执行一个任务。而一个CPU想要执行多个进程，就需要时间片轮询，什么意思呢，系统会分给每个进程一个时间片，在这个时间片内，是轮到这个进程执行的，然后多个进程轮流执行，由于轮的很快，人的肉眼根本分辨不出来，所以，他们看起来是一起执行的，但是实际上，同一时间只有一个进程在执行。这也就是我们常说的<strong>并发</strong>，同一时间点，只有一个进程在运行，他们只是因为快速的切换达到多任务的效果</p><p>每家超市的货物库存都是<strong>独立</strong>的，也就是说，每个进程的资源不是共享的。</p><hr><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><blockquote><p>线程是系统调度的最小单位，他运行在进程中，就拿上边的例子来举例，每个超市中的收银台，就好像一个个的线程，每个线程都是共享进程的资源的。</p><p>并且，他们是一起执行的，并不是轮流执行，这也就是所谓的<strong>并行</strong>。</p></blockquote><p>谈到线程，就不得不说子线程，子线程就好像超市排队结账的人，他们都是要通过主线程。</p><p>如果你没有对线程进行阻塞，就会造成，你排着排着队，超市下班点到了，所有人都走了，你排队的人一脸懵逼，这时候，就需要守护线程登场，在主线程要结束的时候，先看看超市中还有没有人，等到没人了，主线程才结束。</p><p>由于系统中，线程的启动成本是比较高的，因为他涉及到与操作系统的交互，在这种情况下，使用线程池可以很好的提升性能，在系统启动时创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它，当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。</p><p>此外，使用线程池可以有效的控制系统中并发线程的数量，当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至可能会导致python解释器崩溃。</p><blockquote><p>还有一点是，线程的执行是有顺序的，但是，它可以被其他线程抢占，当多个线程对同一个数据做修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对资源加锁。</p></blockquote><p>补充，python解释器默认是<code>Cpython</code>，它上面有一个全局解释器锁GIL，它的作用是，限制多线程同时执行，保证同一时间内只有一个线程在执行，GIL并不是python的特性，注意，python和python解释器是两个概念。</p><p>所以python也被人诟病是伪多线程，而解决这个问题，可以使用协程或者多进程，也可以换其他解释器，比如<code>PyPy</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 多任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 多任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful风格接口</title>
      <link href="2017/08/02/restful-feng-ge-jie-kou/"/>
      <url>2017/08/02/restful-feng-ge-jie-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是restful风格API"><a href="#什么是restful风格API" class="headerlink" title="什么是restful风格API"></a>什么是restful风格API</h2><blockquote><p>网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现<code>API First</code>的设计思想。<code>RESTful API</code>是目前比较成熟的一套互联网应用程序的API设计理论。</p></blockquote><hr><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>API与用户的通信协议，总是使用<strong>HTTPS</strong>协议</p><hr><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>应该尽量将API部署在专用域名之下，如何确定API很简单，不会有进一步扩展，可以考虑在主域名下</p><hr><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>应该将API的版本号放在URL中，另一个做法是，将版本号放在http头信息中，但不如放在url方便和直观</p><hr><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>路径又称为终点，代表了API的具体网址，每个网址代表一种资源，所以网址中不能有动词，只能有名词，而且所用的名词往往和数据库的表格名相互对应，一般来说，每个数据库中的表都是同种记录的集合，所以API中的名词也要使用复数</p><p>举个栗子：</p><pre class="language-python" data-language="python"><code class="language-python">#  有一个API提供商品信息https://api.example.com/v1/goodshttps://api.example.com/v1/categorys</code></pre><hr><h4 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h4><p>对于资源的具体操作类型， 由HTTP动词表示</p><pre class="language-python" data-language="python"><code class="language-python">GET(SELECT):从服务器中取出资源(一项或多项)POST(CREATE):在服务器新建一个资源PUT(UPDATE):在服务器更新资源(客户端提供改变后的完整资源)PATCH(UPDATE):在服务器更新资源(客户端提供改变的属性)DELETE(DELETE):从服务器删除资源HEAD:获取资源的元数据    OPTIONS:获取信息，关于资源的哪些属性是客户端可以改变的</code></pre><p>拿上边的商品信息举例子</p><pre class="language-python" data-language="python"><code class="language-python">GET /goods:列出所有商品POST /goods:新建商品GET /goods/ID:获取某个指定商品的信息PUT /goods/ID:更新某个指定商品的信息(全部信息)PATCH /goods/ID:更新某个商品的信息(部分信息)DELETE /goods/ID:删除某个商品GET /categorys/ID/good:列出商品类ID下所有商品DELETE /categorys/ID/good/ID:删除某个指定商品类下的某个指定商品</code></pre><hr><h4 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h4><p>如果记录数量很多，服务器不可能都将它们返回给用户，API应该提供参数，过滤返回结果</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">?</span>limit<span class="token operator">=</span><span class="token number">10</span>：指定返回记录的数量<span class="token operator">?</span>offset<span class="token operator">=</span><span class="token number">10</span>：指定返回记录的开始位置。<span class="token operator">?</span>page<span class="token operator">=</span><span class="token number">2</span><span class="token operator">&amp;</span>per_page<span class="token operator">=</span><span class="token number">100</span>：指定第几页，以及每页的记录数。<span class="token operator">?</span>sortby<span class="token operator">=</span>name<span class="token operator">&amp;</span>order<span class="token operator">=</span>asc：指定返回结果按照哪个属性排序，以及排序顺序。<span class="token operator">?</span>animal_type_id<span class="token operator">=</span><span class="token number">1</span>：指定筛选条件</code></pre><blockquote><p>参数的设计允许存在冗余，即允许<code>API</code>路径和URL参数偶尔有重复。比如，<code>GET /categorys/ID/goods</code> 与 <code>GET /goods?categorys_id=ID</code> 的含义是相同的。</p></blockquote><hr><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><blockquote><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）</p></blockquote><pre class="language-python" data-language="python"><code class="language-python">200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</code></pre><hr><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果状态码是<code>4xx</code>，就应该向用户返回出错信息，一般来说，返回的信息中将error作为键名，出错信息作为键值即可</p><pre class="language-json" data-language="json"><code class="language-json">{    "error":"Invalid API key"{</code></pre><hr><h4 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h4><p>针对不同操作，服务器向用户返回的结果应该符合以下规范</p><pre class="language-python" data-language="python"><code class="language-python">GET /collection：返回资源对象的列表（数组）GET /collection/resource：返回单个资源对象POST /collection：返回新生成的资源对象PUT /collection/resource：返回完整的资源对象PATCH /collection/resource：返回完整的资源对象DELETE /collection/resource：返回一个空文档</code></pre><hr><h4 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h4><p>RESTful API最好做到面向文档，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么，比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><pre class="language-python" data-language="python"><code class="language-python">{"link": {  "rel":   "collection https://www.example.com/goods",  "href":  "https://api.example.com/goods",  "title": "List of goods",  "type":  "application/vnd.yourformat+json"{{上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</code></pre><hr><p>所以，API有四个级别，分别为：</p><pre class="language-python" data-language="python"><code class="language-python">level 0 ：面向过程，只是把HTTP当做一个传输的通道，没有把HTTP当做一种传输协议level 1：面向资源，通过参数判断level 2：面向标签，真正将HTTP作为了一种传输协议，最直观的一点就是Level2使用了HTTP动词，GET/PUT/POST/DELETE/PATCH....,这些都是HTTP的规范level 3：面向文档,使用者只需要知道如何获取资源的入口，之后的每个URI都可以通过请求获得，无法获得就说明无法执行那个请求</code></pre><p>所以，我们写API时，要朝着最高级别迈进，才能逐渐的成长起来</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
