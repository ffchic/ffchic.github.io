<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#ff8c00"><meta name="author" content="蓝 桉"><meta name="copyright" content="蓝 桉"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>Go语言基础 | Salmon</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.22/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/themes/prism-solarizedlight.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/themes/prism-solarizedlight.css" media="(prefers-color-scheme: dark)"><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#ff8c00"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"godhearing.cn","root":"/","title":["蓝","桉","の","blog"],"version":"1.4.0","mode":"time","copycode":true,"page":{"isPost":true},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"/data/sentences.json"},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["255, 222, 173","255, 250, 240","240, 255, 255\t"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="Salmon" type="application/atom+xml"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap"><meta name="description" content="前言 在一次偶然中，接触到了Go语言，这门语言是一个非常强大的编译型语言，从我接触起，便一直在记录，但愿这些能够帮助到想学习Go语言的人。  博客 文档 Go语言圣经  1.编译使用go build ​    1.在项目目录下执行go build ​    2.在其他路径下执行go build，需要在后面加上项目的路径(项目路径从GOPATH&#x2F;src后开始写起，编译之后的可执行文件就保存在当前目录">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言基础">
<meta property="og:url" content="https://godhearing.cn/2021/01/22/go/index.html">
<meta property="og:site_name" content="Salmon">
<meta property="og:description" content="前言 在一次偶然中，接触到了Go语言，这门语言是一个非常强大的编译型语言，从我接触起，便一直在记录，但愿这些能够帮助到想学习Go语言的人。  博客 文档 Go语言圣经  1.编译使用go build ​    1.在项目目录下执行go build ​    2.在其他路径下执行go build，需要在后面加上项目的路径(项目路径从GOPATH&#x2F;src后开始写起，编译之后的可执行文件就保存在当前目录">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-01-21T16:00:00.000Z">
<meta property="article:modified_time" content="2021-01-21T16:00:00.000Z">
<meta property="article:author" content="蓝 桉">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script>
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-solarizedlight.css" type="text/css"></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><canvas id="trianglifyContainer"></canvas><script defer src="https://cdn.jsdelivr.net/npm/trianglify@4/dist/trianglify.bundle.js"></script><script>document.addEventListener("DOMContentLoaded", () => {
  const pattern = trianglify({
    width: 800,
    height: 600,
    cellSize: 65,
    palette: ["YlGnBu", "GnBu", "Purples", "Blues","Reds","Oranges"],
  });
  const canvasOpts = {
    applyCssScaling: false
  }
  document.body.appendChild(pattern.toCanvas(trianglifyContainer, canvasOpts));
});</script><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="蓝 桉"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="蓝 桉"></a><div class="site-author-name"><a href="/about/">蓝 桉</a></div><a class="site-name" href="/about/site.html">Salmon</a><sub class="site-subtitle">蓝桉的小窝</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">122</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">24</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">39</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://www.baidu.com/" title="通向一个万事都能解决的地方"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/God-hearing2020" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=247102977" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/godhearing1" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://haoye0822@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/girls/" title="我最喜欢的明星" style="color:hotpink"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-women-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BC%96%E8%AF%91"><span class="toc-number">2.</span> <span class="toc-text">1.编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#go-run"><span class="toc-number">2.1.</span> <span class="toc-text">go run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go-install"><span class="toc-number">2.2.</span> <span class="toc-text">go install</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91"><span class="toc-number">2.2.1.</span> <span class="toc-text">交叉编译</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">2.变量和常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.0.1.</span> <span class="toc-text">标识符与关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.0.2.</span> <span class="toc-text">关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">3.1.1.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">3.1.2.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.3.</span> <span class="toc-text">变量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">3.1.4.</span> <span class="toc-text">类型推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">3.1.5.</span> <span class="toc-text">短变量声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.6.</span> <span class="toc-text">匿名变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F-const"><span class="toc-number">3.2.</span> <span class="toc-text">常量 const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iota"><span class="toc-number">3.2.1.</span> <span class="toc-text">iota</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">3.数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">4.0.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%95%B4%E5%9E%8B"><span class="toc-number">4.0.2.</span> <span class="toc-text">特殊整型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">4.0.3.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94"><span class="toc-number">4.0.4.</span> <span class="toc-text">布尔</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.0.5.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">4.0.5.1.</span> <span class="toc-text">字符串操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.0.6.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.0.6.1.</span> <span class="toc-text">数组的初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.0.6.2.</span> <span class="toc-text">数组的遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.0.6.3.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.0.6.4.</span> <span class="toc-text">多维数组的遍历</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-if%E4%B8%8Efor"><span class="toc-number">5.</span> <span class="toc-text">4.if与for</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if%E5%88%A4%E6%96%AD"><span class="toc-number">5.0.1.</span> <span class="toc-text">if判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.0.2.</span> <span class="toc-text">for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch"><span class="toc-number">5.0.3.</span> <span class="toc-text">switch</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">5.运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.0.1.</span> <span class="toc-text">算数运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.0.2.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.0.3.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.0.4.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.0.5.</span> <span class="toc-text">赋值运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%88%87%E7%89%87"><span class="toc-number">7.</span> <span class="toc-text">6.切片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%87%E7%89%87"><span class="toc-number">7.0.1.</span> <span class="toc-text">自定义切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B1%E6%95%B0%E7%BB%84%E5%BE%97%E5%88%B0%E5%88%87%E7%89%87"><span class="toc-number">7.0.2.</span> <span class="toc-text">由数组得到切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#make%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87"><span class="toc-number">7.0.3.</span> <span class="toc-text">make函数创建切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#append%E5%87%BD%E6%95%B0%E6%B7%BB%E5%8A%A0"><span class="toc-number">7.0.4.</span> <span class="toc-text">append函数添加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5"><span class="toc-number">7.0.5.</span> <span class="toc-text">切片的扩容策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy"><span class="toc-number">7.0.6.</span> <span class="toc-text">copy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%88%87%E7%89%87%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">7.0.7.</span> <span class="toc-text">从切片中删除元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">7.指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">new函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">make函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-map"><span class="toc-number">9.</span> <span class="toc-text">8.map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">9.1.</span> <span class="toc-text">map的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">9.2.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">9.函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#defer%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.1.</span> <span class="toc-text">defer语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">10.3.</span> <span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">11.</span> <span class="toc-text">10.作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">11.内置函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#panic-recover"><span class="toc-number">12.1.</span> <span class="toc-text">panic&#x2F;recover</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">13.</span> <span class="toc-text">12.自定义类型和类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.0.1.</span> <span class="toc-text">自定义类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">13.0.2.</span> <span class="toc-text">类型别名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">14.</span> <span class="toc-text">13.结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">14.0.1.</span> <span class="toc-text">匿名结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-number">14.0.2.</span> <span class="toc-text">结构体指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">14.0.3.</span> <span class="toc-text">结构体初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">14.0.4.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">14.0.5.</span> <span class="toc-text">方法和接收者</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">14.0.5.1.</span> <span class="toc-text">接收者</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">14.0.6.</span> <span class="toc-text">匿名字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">14.0.7.</span> <span class="toc-text">嵌套结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">14.0.8.</span> <span class="toc-text">匿名嵌套结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%A8%A1%E6%8B%9F%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D"><span class="toc-number">14.0.9.</span> <span class="toc-text">结构体模拟“继承”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8EJSON"><span class="toc-number">14.0.10.</span> <span class="toc-text">结构体与JSON</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.</span> <span class="toc-text">14.接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.0.1.</span> <span class="toc-text">空接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">15.0.2.</span> <span class="toc-text">类型断言</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%8C%85"><span class="toc-number">16.</span> <span class="toc-text">15.包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%BC%E5%85%A5%E5%8C%85"><span class="toc-number">16.0.1.</span> <span class="toc-text">匿名导入包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">16.0.2.</span> <span class="toc-text">init初始化函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">17.</span> <span class="toc-text">16.文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">17.1.</span> <span class="toc-text">读取文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#file-Read"><span class="toc-number">17.1.1.</span> <span class="toc-text">file.Read()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bufio"><span class="toc-number">17.1.2.</span> <span class="toc-text">bufio</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ioutil"><span class="toc-number">17.1.3.</span> <span class="toc-text">ioutil</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="toc-number">17.2.</span> <span class="toc-text">文件写入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Write"><span class="toc-number">17.2.1.</span> <span class="toc-text">Write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WriteString"><span class="toc-number">17.2.2.</span> <span class="toc-text">WriteString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bufio-NewWriter"><span class="toc-number">17.2.3.</span> <span class="toc-text">bufio.NewWriter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ioutil-WriteFile"><span class="toc-number">17.2.4.</span> <span class="toc-text">ioutil.WriteFile</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97"><span class="toc-number">18.</span> <span class="toc-text">17.时间模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#time%E5%8C%85"><span class="toc-number">18.0.1.</span> <span class="toc-text">time包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">18.0.2.</span> <span class="toc-text">时间戳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94"><span class="toc-number">18.0.3.</span> <span class="toc-text">时间间隔</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">18.0.4.</span> <span class="toc-text">时间操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">18.0.5.</span> <span class="toc-text">时间格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parse"><span class="toc-number">18.0.6.</span> <span class="toc-text">Parse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">18.0.7.</span> <span class="toc-text">定时器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-log%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1"><span class="toc-number">19.</span> <span class="toc-text">18.log日志服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%8F%8D%E5%B0%84"><span class="toc-number">20.</span> <span class="toc-text">19.反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reflect"><span class="toc-number">20.0.1.</span> <span class="toc-text">reflect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#type-name-%E5%92%8C-type-kind"><span class="toc-number">20.0.2.</span> <span class="toc-text">type name 和 type kind</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="toc-number">21.</span> <span class="toc-text">20.高并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Goroutine"><span class="toc-number">21.0.1.</span> <span class="toc-text">Goroutine</span></a></li></ol></li></ol></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/Book/" style="font-size: 21px; color: #80b45d">Book</a> <a href="/tags/Casbin/" style="font-size: 12px; color: #ffc20e">Casbin</a> <a href="/tags/Celery/" style="font-size: 16.5px; color: #bfbb36">Celery</a> <a href="/tags/Django/" style="font-size: 30px; color: #00a6ac">Django</a> <a href="/tags/Docker/" style="font-size: 25.5px; color: #40ad85">Docker</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://godhearing.cn/2021/01/22/go/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="蓝 桉"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Salmon"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Go语言基础</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-01-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-22T00:00:00+08:00">2021-01-22</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/Golang/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Golang</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/Golang/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Golang</span></a></span></div><div class="post-author"><span class="author-name">天听</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#ff8c00;"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>在一次偶然中，接触到了Go语言，这门语言是一个非常强大的编译型语言，从我接触起，便一直在记录，但愿这些能够帮助到想学习Go语言的人。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.liwenzhou.com/">博客</a></p>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/pkgdoc">文档</a></p>
<p><a target="_blank" rel="noopener" href="http://shouce.jb51.net/gopl-zh/ch1/ch1-01.html">Go语言圣经</a></p>
<hr>
<h2 id="1-编译"><a href="#1-编译" class="headerlink" title="1.编译"></a>1.编译</h2><p>使用<code>go build</code></p>
<p>​    1.在项目目录下执行<code>go build</code></p>
<p>​    2.在其他路径下执行<code>go build</code>，需要在后面加上项目的路径(项目路径从GOPATH/src后开始写起，编译之后的可执行文件就保存在当前目录下)</p>
<p>​    3.<code>go build -o ***.exe</code>生成编译文件时执行名字</p>
<h3 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h3><p>像执行脚本文件一样执行go代码</p>
<h3 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h3><p><code>go install</code>分为两步：</p>
<p>​    1.先编译得到一个可执行文件</p>
<p>​    2.将可执行文件拷贝到GOPATH/bin</p>
<hr>
<h4 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h4><p>Go支持跨平台编译</p>
<p>例如：在windows平添编译一个能在linux平台执行的可执行文件</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">SET CGO_ENABLED=0 //禁用CGO
SET GOOS=linux //目标平台是linux
SET GOARCH=amd64 //目标处理器架构是amd64</code></pre>

<p>如果要编译可执行文件，必须要有main包和main函数(入口函数，无参数无返回值)</p>
<hr>
<h2 id="2-变量和常量"><a href="#2-变量和常量" class="headerlink" title="2.变量和常量"></a>2.变量和常量</h2><pre class="language-go" data-language="go"><code class="language-go">package main

//导入语句
import "fmt"

//函数外只能放标识符(变量，常量，函数，类型)的声明


//程序的入口函数
func main() {
	fmt.Println("hello world")
}</code></pre>

<h4 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h4><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p>
<blockquote>
<p>如果标识符的首字母是大写的，就表示对外部可见,可以通过包导入</p>
</blockquote>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><pre class="language-go" data-language="go"><code class="language-go">break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var</code></pre>

<p><code>nil</code>类似python的<code>null</code></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Go语言中的变量必须先声明再使用</p>
<p>注意，函数外的每个语句都必须以关键字开始(var，const，func等)</p>
<p>声明的变量必须使用，不使用就无法编译</p>
<p>同一个作用域中，不能重复声明同一个变量</p>
<p><code>var s1 string</code> ：声明了一个s1变量为字符串类型</p>
<p>批量声明:</p>
<pre class="language-go" data-language="go"><code class="language-go">var(
    a string
    b int
    c bool
)</code></pre>

<hr>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p><code>fmt.Scan()</code>代表用户输入,输入需要传指针来修改内存地址上的数据</p>
<pre class="language-go" data-language="go"><code class="language-go">var s string
fmt.Scan(&amp;s)
fmt.Println("用户输入的内容：", s)</code></pre>

<p><code>fmt.Sanf</code>格式化输入</p>
<pre class="language-go" data-language="go"><code class="language-go">var s string
var d string
fmt.Scanf(&amp;s &amp;d)
fmt.Println("用户输入的内容：", s d)</code></pre>



<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Printf(“name:%v”, “天听”)无论是什么类型，都能用%v来打印数值</p>
<pre class="language-go" data-language="go"><code class="language-go">func main() {
	fmt.Print("AAA")   //输出打印内容
	fmt.Println("BBB") //打印完内容之后会加一个换行符
    
	fmt.Printf("name:%s", "天听") //%s:占位符，等于格式化输出
}</code></pre>

<hr>
<h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>占位符%T可以查看类型</p>
<pre class="language-go" data-language="go"><code class="language-go">fmt.Printf("%T\n", 111)

fmt.Printf("%d\n", i1)
	fmt.Printf("%b\n", i1) //转换为二进制
	fmt.Printf("%o\n", i1) // 转换为八进制
	fmt.Printf("%x\n", i1) //转换为十六进制</code></pre>

<pre class="language-go" data-language="go"><code class="language-go">// %d 十进制
// %c 字符
// %s 字符串
// %p 指针
// %v 值
// %f 浮点数
// %t 布尔值
</code></pre>

<blockquote>
<p>%%代表的才是%，不能用\转义</p>
</blockquote>
<hr>
<h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化</p>
<pre class="language-go" data-language="go"><code class="language-go">var name = "Q1mi"
var age = 18 //根据值判断该变量是什么类型</code></pre>

<hr>
<h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p>
<pre class="language-go" data-language="go"><code class="language-go">package main

import (
	"fmt"
)
// 全局变量m
var m = 100

func main() {
	n := 10
	m := 200 // 此处声明局部变量m
	fmt.Println(m, n)
}</code></pre>

<hr>
<h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，(<code>_</code>多用于占位，表示忽略值。)例如：</p>
<pre class="language-go" data-language="go"><code class="language-go">func foo() (int, string) {
	return 10, "Q1mi"
}
func main() {
	x, _ := foo()
	_, y := foo()
	fmt.Println("x=", x)
	fmt.Println("y=", y)
}</code></pre>

<hr>
<h3 id="常量-const"><a href="#常量-const" class="headerlink" title="常量 const"></a>常量 const</h3><p>声明常量的关键字const</p>
<pre class="language-go" data-language="go"><code class="language-go">const PI = 3.1415926</code></pre>

<p>也可以批量声明常量，和批量声明变量一致，只不过关键字从var变为const</p>
<p>批量声明常量时，如果某一行声明后没有赋值，默认就和上一行一样</p>
<pre class="language-go" data-language="go"><code class="language-go">const(
	n1 = 100
    n2
    n3
)</code></pre>

<hr>
<h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p>
<p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用</p>
<pre class="language-go" data-language="go"><code class="language-go">const (
		n1 = iota //0
		n2        //1
		n3        //2
		n4        //3
	)</code></pre>

<p>使用<code>_</code>跳过某些值</p>
<pre class="language-go" data-language="go"><code class="language-go">const (
		n1 = iota //0
		n2        //1
		_
		n4        //3
	)</code></pre>

<p><code>iota</code>声明中间插队</p>
<pre class="language-go" data-language="go"><code class="language-go">const (
		n1 = iota //0
		n2 = 100  //100
		n3 = iota //2
		n4        //3
	)
	const n5 = iota //0</code></pre>

<p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p>
<pre class="language-go" data-language="go"><code class="language-go">const (
		_  = iota
		KB = 1 &lt;&lt; (10 * iota)
		MB = 1 &lt;&lt; (10 * iota)
		GB = 1 &lt;&lt; (10 * iota)
		TB = 1 &lt;&lt; (10 * iota)
		PB = 1 &lt;&lt; (10 * iota)
	)</code></pre>

<p>多个<code>iota</code>定义在一行</p>
<pre class="language-go" data-language="go"><code class="language-go">const (
		a, b = iota + 1, iota + 2 //1,2
		c, d                      //2,3
		e, f                      //3,4
	)</code></pre>

<hr>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p>
<p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint8</td>
<td align="center">无符号 8位整型 (0 到 255)</td>
</tr>
<tr>
<td align="center">uint16</td>
<td align="center">无符号 16位整型 (0 到 65535)</td>
</tr>
<tr>
<td align="center">uint32</td>
<td align="center">无符号 32位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td align="center">uint64</td>
<td align="center">无符号 64位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td align="center">int8</td>
<td align="center">有符号 8位整型 (-128 到 127)</td>
</tr>
<tr>
<td align="center">int16</td>
<td align="center">有符号 16位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td align="center">int32</td>
<td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td align="center">int64</td>
<td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<h4 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h4><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint</td>
<td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td>
</tr>
<tr>
<td align="center">uintptr</td>
<td align="center">无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p>
<p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code></p>
<p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p>
<pre class="language-go" data-language="go"><code class="language-go">package main
import (
        "fmt"
        "math"
)
func main() {
        fmt.Printf("%f\n", math.Pi)
        fmt.Printf("%.2f\n", math.Pi)
}</code></pre>

<h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p>
<p><strong>注意：</strong></p>
<ol>
<li>布尔类型变量的默认值为<code>false</code>。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li>
</ol>
<hr>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Go语言中字符串是用<strong>双引号</strong>包裹的</p>
<p>单引号包裹的是字符，字符是单独的字母、汉字、符号</p>
<h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5><p>转义：</p>
<p>\代表转义，如果单纯的想打印一个\，需要在前面再加一个\</p>
<table>
<thead>
<tr>
<th align="center">转义符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\r</code></td>
<td align="center">回车符（返回行首）</td>
</tr>
<tr>
<td align="center"><code>\n</code></td>
<td align="center">换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td align="center"><code>\t</code></td>
<td align="center">制表符</td>
</tr>
<tr>
<td align="center"><code>\'</code></td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center"><code>\"</code></td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center"><code>\\</code></td>
<td align="center">反斜杠</td>
</tr>
</tbody></table>
<p>多行字符串:    `，使用此符号时，无需用\转义</p>
<pre class="language-go" data-language="go"><code class="language-go">s1 := `
	aaa
	bbb
	ccc
`</code></pre>



<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">len(str)</td>
<td align="center">求长度</td>
</tr>
<tr>
<td align="center">+或fmt.Sprintf</td>
<td align="center">拼接字符串</td>
</tr>
<tr>
<td align="center">strings.Split</td>
<td align="center">分割</td>
</tr>
<tr>
<td align="center">strings.contains</td>
<td align="center">判断是否包含</td>
</tr>
<tr>
<td align="center">strings.HasPrefix,strings.HasSuffix</td>
<td align="center">前缀/后缀判断</td>
</tr>
<tr>
<td align="center">strings.Index(),strings.LastIndex()</td>
<td align="center">子串出现的位置(下标)</td>
</tr>
<tr>
<td align="center">strings.Join(a[]string, sep string)</td>
<td align="center">join操作</td>
</tr>
</tbody></table>
<p> byte和rune类型</p>
<p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p>
<pre class="language-go" data-language="go"><code class="language-go">var a := '中'
var b := 'x'</code></pre>

<p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code></p>
<p>修改字符串：</p>
<p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<pre class="language-go" data-language="go"><code class="language-go">func changeString() {
	s1 := "big"
	// 强制类型转换
	byteS1 := []byte(s1)
	byteS1[0] = 'p'
	fmt.Println(string(byteS1))

	s2 := "白萝卜"
	runeS2 := []rune(s2)
	runeS2[0] = '红'
	fmt.Println(string(runeS2))
}</code></pre>

<p>类型转换：</p>
<p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p>
<p>强制类型转换的基本语法如下：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">T(表达式)</code></pre>

<p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组的长度是数组类型的一部分，例如<code>var al [3]bool</code>，代表了al是一个长度为3元素类型为布尔的数组</p>
<h5 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h5><pre class="language-go" data-language="go"><code class="language-go">var a1 [3]bool
//初始化
a1 = [3]bool{true, true, false}

//根据初始值自动推断数组的长度是多少
a2 := [...]int{1, 2, 3, 4, 5, 6, 7}
	fmt.Println(a2)

//根据索引初始化
a3 := [5]int{0:2,4:3}
fmt.Println(a3)</code></pre>

<h5 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h5><pre class="language-go" data-language="go"><code class="language-go">citys := [...]string{"北京", "上海", "深圳"}
	for i := 0; i &lt; len(citys); i++ {
		fmt.Println(citys[i])
	}</code></pre>

<pre class="language-go" data-language="go"><code class="language-go">//range遍历
for i, v := range citys {
		fmt.Println(i, v)
	}</code></pre>



<h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><blockquote>
<p>多维数组就是数组的嵌套，如[[1,2],[2,3],[3,4]]</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">var a4 [3][2]int
	//[3]是外层数组，[2]int是该数组的数据类型，元素为两个int
	a4 = [3][2]int{
		[2]int{1, 2},
		[2]int{3, 4},
		[2]int{5, 6},
	}
	fmt.Println(a4)</code></pre>

<h5 id="多维数组的遍历"><a href="#多维数组的遍历" class="headerlink" title="多维数组的遍历"></a>多维数组的遍历</h5><pre class="language-go" data-language="go"><code class="language-go">var a4 [3][2]int

	a4 = [3][2]int{
		[2]int{1, 2},
		[2]int{3, 4},
		[2]int{5, 6},
	}
	for _, v := range a4 {
		for _, i := range v {
			fmt.Println(i)
		}
	}</code></pre>

<hr>
<h2 id="4-if与for"><a href="#4-if与for" class="headerlink" title="4.if与for"></a>4.if与for</h2><h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><pre class="language-go" data-language="go"><code class="language-go">age := 16
	if age &gt;= 18 {
		fmt.Println("成年")
	} else {
		fmt.Println("未成年")
	}</code></pre>

<p>也可以将变量定义到if的作用域中,这样，该变量只会在if作用域中</p>
<pre class="language-go" data-language="go"><code class="language-go">if age := 16; age &gt;= 18 {
		fmt.Println("成年")
	} else {
		fmt.Println("未成年")
	}</code></pre>

<p>else if</p>
<pre class="language-go" data-language="go"><code class="language-go">if age := 16; age &gt;= 18 {
		fmt.Println("成年")
	} else if age &gt;= 16 {
		fmt.Println("小成年")
	} else {
		fmt.Println("未成年")
	}</code></pre>

<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>基本格式</p>
<p>for 初始语句;条件;结束语句{}</p>
<pre class="language-go" data-language="go"><code class="language-go">for i := 0; i &lt; 10; i++ {
		fmt.Println(i)
	}</code></pre>

<p>省略初始语句的写法 **;**不能少</p>
<pre class="language-go" data-language="go"><code class="language-go">var i=5
for ;i&lt;10;i++{
    fmt.Println(i)
}</code></pre>

<p>省略结束语句的写法,如果不加条件，则是无限循环，由于go语言运行速度极快，不要轻易尝试</p>
<pre class="language-go" data-language="go"><code class="language-go">var i=5
for ;i&lt;10;{
    fmt.Println(i)
    i++
}</code></pre>

<p>for range循环，有两个变量接收，第一个是索引，第二个是值</p>
<pre class="language-go" data-language="go"><code class="language-go">s:= "hello天听"
for i,v := range s{
    fmt.Printf("%d,%c\n",i,v)
}</code></pre>

<p>break：跳出for循环</p>
<p>contiune：跳过本次循环，继续下一次</p>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>简化大量的判断</p>
<pre class="language-go" data-language="go"><code class="language-go">var a = 3
	switch a {
	case 1:
		fmt.Println("1")
	case 2:
		fmt.Println("2")
	case 3:
		fmt.Println("3")
	case 4:
		fmt.Println("4")
    default:
        fmt.Println("无效") 
	}
</code></pre>

<hr>
<h2 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5.运算符"></a>5.运算符</h2><p>Go语言是<code>强类型</code>,相同类型的变量才能比较</p>
<h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">相加</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">相减</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">相乘</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">相除</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">求余</td>
</tr>
</tbody></table>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">==</td>
<td align="center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody></table>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">||</td>
<td align="center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td align="center">&amp;&amp;</td>
<td align="center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td align="center">!</td>
<td align="center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody></table>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符对整数在内存中的<code>二进制</code>位进行操作。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td>
</tr>
</tbody></table>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><table>
<thead>
<tr>
<th>=</th>
<th>简单的赋值运算符，将一个表达式的值赋给一个左值</th>
</tr>
</thead>
<tbody><tr>
<td>+=</td>
<td>相加后再赋值</td>
</tr>
<tr>
<td>-=</td>
<td>相减后再赋值</td>
</tr>
<tr>
<td>*=</td>
<td>相乘后再赋值</td>
</tr>
<tr>
<td>/=</td>
<td>相除后再赋值</td>
</tr>
<tr>
<td>%=</td>
<td>求余后再赋值</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移后赋值</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移后赋值</td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与后赋值</td>
</tr>
<tr>
<td>|=</td>
<td>按位或后赋值</td>
</tr>
<tr>
<td>^=</td>
<td>按位异或后赋值</td>
</tr>
</tbody></table>
<hr>
<h2 id="6-切片"><a href="#6-切片" class="headerlink" title="6.切片"></a>6.切片</h2><p><code>len</code>代表长度</p>
<p><code>cap</code>代表容量</p>
<blockquote>
<p>切片必须初始化分配内存</p>
<p>切片不存值，指向同一个底层数组，所以，怎样赋值切片之后改变，都会使同样的底层数组发生改变，类似浅拷贝</p>
</blockquote>
<h4 id="自定义切片"><a href="#自定义切片" class="headerlink" title="自定义切片"></a>自定义切片</h4><pre class="language-go" data-language="go"><code class="language-go">var s1 []int //定义一个存放int类型元素的切片

//初始化
s1 = []int{1,2,3}</code></pre>

<h4 id="由数组得到切片"><a href="#由数组得到切片" class="headerlink" title="由数组得到切片"></a>由数组得到切片</h4><pre class="language-go" data-language="go"><code class="language-go">a1 :=[...]int{1,2,3,4,5}
s3 := a1[0:4]</code></pre>

<h4 id="make函数创建切片"><a href="#make函数创建切片" class="headerlink" title="make函数创建切片"></a>make函数创建切片</h4><blockquote>
<p>make([]int,元素数量,容量)</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">s1 := make([]int, 5,10)
fmt.Printf("s1=%v len(s1)=%d cap(s1)=%d\n", s1, len(s1), cap(s1))</code></pre>

<p>切片的本质就是一个框，框住了一块连续的内存，属于引用类型，真正的数据都保存在底层数组里</p>
<p>切片不能<strong>直接比较</strong>，只能和<strong>nil</strong>比较</p>
<p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p>
<h4 id="append函数添加"><a href="#append函数添加" class="headerlink" title="append函数添加"></a>append函数添加</h4><blockquote>
<p>调用append函数必须使用原来的切片变量接收返回值</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">s1 := []string{"龙潭", "四海门", "空境"}
	s1 = append(s1, "洞天")
	fmt.Println(s1)

//多个元素添加，用...进行拆开
s1 := []string{"龙潭", "四海门", "空境"}
	s2 := []string{"望苍城", "天下城", "万象城"}
	s1 = append(s1, s2...)
	fmt.Println(s1)</code></pre>

<h4 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h4><pre class="language-go" data-language="go"><code class="language-go">首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。

否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），

否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）

如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</code></pre>

<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><pre class="language-go" data-language="go"><code class="language-go">//此处，将s1的值拷贝给了s3，深拷贝，此时s1如何修改都与s3无关
s1 := []string{"龙潭", "四海门", "空境"}
s2 := s1
var s3 = make([]string, 3, 3)
fmt.Println(s1, s2, s3)
copy(s3, s1)
fmt.Println(s1, s2, s3)</code></pre>

<h4 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h4><pre class="language-go" data-language="go"><code class="language-go">// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]</code></pre>

<h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7.指针"></a>7.指针</h2><p>在Go语言中对于引用类型的变量，在使用的时候不仅要声明它，还要为它分配内存空间，否则值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。Go语言中new和make是内建的两个函数，主要用来分配内存。</p>
<blockquote>
<p>go语言中不存在指针操作，只需要记住两个符号</p>
<p><code>&amp;</code>：取地址</p>
<p><code>*</code>：根据地址取值</p>
</blockquote>
<ul>
<li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针地址。</li>
<li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li>
</ul>
<pre class="language-go" data-language="go"><code class="language-go">//&amp;
a := 20
	fmt.Println(&amp;a)
//*
	p := &amp;a
	m := *p
	fmt.Println(m)</code></pre>

<h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h3><p>new函数是一个内置的函数，可以申请一个内存地址</p>
<p>new很少用，一般用来给基本数据类型申请内存，int/string等</p>
<pre class="language-go" data-language="go"><code class="language-go">var a *int  //声明一个变量
fmt.Println(a)
var a2 = new(int) // new函数申请内存地址
fmt.Println(*a2)
*a2 = 100 //重新赋值
fmt.Println(*a2)</code></pre>

<blockquote>
<p>返回的是指针</p>
</blockquote>
<h3 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h3><blockquote>
<p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针。</p>
</blockquote>
<hr>
<h2 id="8-map"><a href="#8-map" class="headerlink" title="8.map"></a>8.<strong><code>map</code></strong></h2><blockquote>
<p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p>
</blockquote>
<blockquote>
<p>map是一种<strong>无序</strong>的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p>
</blockquote>
<p>map[键类型]值类型</p>
<pre class="language-go" data-language="go"><code class="language-go">var a map[string]int // 声明一个map
a = make(map[string]int, 10) //初始化
a["天听"] = 20//添加数据
a["并轩"] = 30
a["冰冰"] = 16
fmt.Println(a)

v, ok := a["冰冰"]  //返回两个值，一个是数据，一个是布尔值，约定成俗是ok
if !ok { //如果ok为false，则查找不到
	fmt.Println("查无此人")
} else {
	fmt.Println(v)
}</code></pre>

<h3 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h3><pre class="language-go" data-language="go"><code class="language-go">for k, v := range a {
		fmt.Println(k, v)
	}</code></pre>

<p>如果只用一个参数接收，默认接收k</p>
<pre class="language-go" data-language="go"><code class="language-go">for k := range a {
		fmt.Println(k)
	}</code></pre>



<p>如果只是单纯的想拿到值，可以用_接收k</p>
<pre class="language-go" data-language="go"><code class="language-go">for _, v := range a {
		fmt.Println(v)
	}</code></pre>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote>
<p>用delete删除</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">delete(a,键)</code></pre>

<h2 id="9-函数"><a href="#9-函数" class="headerlink" title="9.函数"></a>9.函数</h2><p>函数是一段代码的<strong>封装</strong></p>
<blockquote>
<p>在go语言中，函数格式为<code>func 函数名(参数)(返回值){}</code></p>
<p>并且要指定参数类型和返回值类型</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func sum(x int, y int) (ret int) {
	return x * y
}

func main() {
	a := sum(2, 55)
	fmt.Println(a)
}</code></pre>

<blockquote>
<p>无参数有返回值</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func a1() string {
	return "jajajaj"
}</code></pre>

<blockquote>
<p>返回值可以命名也可以不命名，但是，需要声明返回值</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func a2(x int,y int)(ret int){ //声明ret
    ret = x+y //直接可以使用
}
//也可以不命名返回值
func a2(x int,y int) int{
    ret := x+y //声明
    return ret //使用
}</code></pre>

<blockquote>
<p>返回值可以有多个，需要用()括起来</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func a2(x int,y int)(int,string){
    return 1,"天听"
}</code></pre>

<blockquote>
<p>参数类型简写</p>
<p>当参数中，连续两个参数类型一致，可以将前边的参数类型省略</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func a2(x,y int)(ret int){
    ret = x+y
}</code></pre>

<blockquote>
<p>可变长参数</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func a2(x string,y ...int){ //...int，可变长，但是，都得是int类型
    fmt.Println(x)
    fmt.Println(y)
}</code></pre>

<blockquote>
<p>注意，go语言中函数传参永远是深拷贝</p>
</blockquote>
<h3 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h3><blockquote>
<p><code>defer</code>语句会将其后边跟随的语句进行延迟处理，在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行</p>
<p>也就是说，有多个<code>defer</code>语句时，最先写的<code>defer</code>最后被执行，最后写的<code>defer</code>最先被执行</p>
</blockquote>
<blockquote>
<p>defer多用于函数结束之前释放资源</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func deferDemo() {	
	fmt.Println("start")
	defer fmt.Println("AAA")
	defer fmt.Println("BBB")
	defer fmt.Println("CCC")
	fmt.Println("end")
}
/*
执行结果为
start
end
CCC
BBB
AAA
*/</code></pre>

<p>Go语言中的<strong>return</strong>不是原子操作，在底层是分为两步来执行</p>
<blockquote>
<p>第一步：返回值赋值</p>
<p>第二步：真正的RET返回</p>
<p>函数中如果存在defer，那么defer执行的时机是在第一步和第二步之间</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func f1() (x int) {
    x = 5   //返回值赋值
	defer func() {
		x++  //执行defer
	}()
	return x //RET返回
}</code></pre>

<pre class="language-go" data-language="go"><code class="language-go">func f1() int {   //此时的返回值没有命名
	x := 5
	defer func() {  //defer修改的是x而不是返回值
		x++
	}()
	return x  
}</code></pre>

<blockquote>
<p>函数也可以作为参数和返回值</p>
<p>只要是满足参数和返回值的类型要求</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func f1(){ //类型为func()
    
}

func f2() int{  // 类型为func()int
    return 100
}

func f3(x func()){ //此处可以将类型为func()的函数传进来
    
}

func f4(x func()int){//此处可以将类型为func()int的函数传进来
    
}</code></pre>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><blockquote>
<p>因为函数内部无法声明有名字的函数，所以，在匿名函数多用于在函数内部</p>
</blockquote>
<p>匿名函数定义：<code>func(){}</code></p>
<pre class="language-go" data-language="go"><code class="language-go">func main(){
    func(x,y int){
        fmt.Println(x+y)
    }(1,2)//如果只是调用一次的函数，可以简写成立即执行函数，加个括号
}</code></pre>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>闭包的本质就是一个函数，函数可以作为返回值，因为函数内部查找变量的顺序是由内而外，所以，在自己内部找不到变量就得去外层找，包含了一个外部作用域变量的特殊函数</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func f1(a int) (func(int) int, func(int) int) {
//声明一个函数，有参数a，两个有参有返的函数返回值
	add := func(i int) int {
		a += i
		return a
	}
    //内部声明匿名函数

	sub := func(i int) int {
		a -= i
		return a
	}
    //内部声明匿名函数

	return add, sub
    //满足了条件

}

func main() {
	q1, q2 := f1(10) //  q1,q2的类型为func(int) int
	// 参数a是10
	fmt.Println(q1(1), q2(2)) //11 9
}
</code></pre>

<blockquote>
<p>上面的例子中为什么不是8而是9，因为传的参数a并不是内部匿名函数的参数，所以，按照返回值的顺序，先执行了add，再执行sub</p>
</blockquote>
<h2 id="10-作用域"><a href="#10-作用域" class="headerlink" title="10.作用域"></a>10.作用域</h2><blockquote>
<p>和python相同点，全局作用域和局部作用域</p>
<p>不同点为，Go语言的if…else，switch..case等都会产生<strong>语句块作用域</strong></p>
</blockquote>
<h2 id="11-内置函数"><a href="#11-内置函数" class="headerlink" title="11.内置函数"></a>11.内置函数</h2><table>
<thead>
<tr>
<th align="center">内置函数</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">close</td>
<td align="center">主要用来关闭channel</td>
</tr>
<tr>
<td align="center">len</td>
<td align="center">用来求长度，比如string、array、slice、map、channel</td>
</tr>
<tr>
<td align="center">new</td>
<td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td>
</tr>
<tr>
<td align="center">make</td>
<td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td>
</tr>
<tr>
<td align="center">append</td>
<td align="center">用来追加元素到数组、slice中</td>
</tr>
<tr>
<td align="center">panic和recover</td>
<td align="center">用来做错误处理</td>
</tr>
</tbody></table>
<h3 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a>panic/recover</h3><blockquote>
<p>Go语言中目前是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func f2() {
	defer func() {
		err := recover()
		fmt.Println(err)
		fmt.Println("关闭程序")
	}()
	fmt.Println("B")
	panic("错误")
}</code></pre>

<blockquote>
<p>注意，<code>recover</code>一定要搭配<code>defer</code>使用</p>
</blockquote>
<h2 id="12-自定义类型和类型别名"><a href="#12-自定义类型和类型别名" class="headerlink" title="12.自定义类型和类型别名"></a>12.自定义类型和类型别名</h2><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><p><code>type 自定义类型 内置类型</code></p>
<pre class="language-go" data-language="go"><code class="language-go">type ssint int</code></pre>

<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p><code>type 别名 = 内置类型</code></p>
<pre class="language-go" data-language="go"><code class="language-go">type yourInt = int</code></pre>

<h2 id="13-结构体"><a href="#13-结构体" class="headerlink" title="13.结构体"></a>13.结构体</h2><blockquote>
<p>结构体的内存地址是连续的，并不是每个字段一个内存</p>
</blockquote>
<blockquote>
<p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p>
</blockquote>
<p>Go语言中通过<code>struct</code>来实现面向对象</p>
<blockquote>
<p>使用<code>type</code>和<code>struct</code>关键字来定义结构体</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">type 类型名 struct{
    字段名 字段类型
    字段名 字段类型
}

type person struct{
    name string
    age int
    gender string
}

//实例化"对象"
var a person
a.name = "天听"
a.age = 18
a.gender = "男"</code></pre>

<h4 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h4><pre class="language-go" data-language="go"><code class="language-go">var s struct{
    name string
    age int
}</code></pre>

<blockquote>
<p>和定义结构体不同的是，匿名结构体是在声明变量，而不是声明结构体类型</p>
</blockquote>
<h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><blockquote>
<p>结构体可以当做值传进函数内，通过指针，也可以将某个值的内存地址传过去</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func f1(x person) {  //此时传的是结构体
	x.gender = "女"
}

func f2(x *person) { // 此时，传的是结构体的指针
	(*x).gender = "女"
    //x.gender = "女"   //两种写法都可以
}

func main() {
	var a person
	a.name = "天听"
	a.gender = "男"
	f1(a)
	fmt.Println(a.gender) //由于传过去的是深拷贝，所以，修改不会成功
	f2(&amp;a)
	fmt.Println(a.gender)//通过指针修改了内存地址上的值，所以，修改成功了
}</code></pre>

<h4 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h4><pre class="language-go" data-language="go"><code class="language-go">var b = persson{
		name:   "并轩",
		gender: "女",
	}
	fmt.Println(b)</code></pre>

<pre class="language-go" data-language="go"><code class="language-go">var c = persson{
		"狮子",
		"男",
	}
	fmt.Println(c)</code></pre>

<blockquote>
<p>注意，以上两种方法不能混用</p>
</blockquote>
<blockquote>
<p>当结构体比较大的时候尽量使用结构体指针，减少程序的内存开销</p>
</blockquote>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote>
<p>返回一个结构体变量的函数</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func newDog(name string) dog {
    return dog{
        name:name,
    }
}</code></pre>

<h4 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h4><blockquote>
<p>方法是作用域特定类型的函数</p>
</blockquote>
<blockquote>
<p>接收者表示的是调用该方法的具体类型变量，多用类型名首字母小写表示，写在函数名前面</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">type dog struct{
    name string
}


func (d dog)wang(){
    fmt.Printf("%s:汪汪汪~",d.name)
}

func main(){
    d1 := newDog("哈士奇")
    d1.wang()
}</code></pre>

<h5 id="接收者"><a href="#接收者" class="headerlink" title="接收者"></a>接收者</h5><pre class="language-go" data-language="go"><code class="language-go">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {
    函数体
}</code></pre>

<p>什么时候需要用指针接收者：</p>
<blockquote>
<p>需要修改接收者的值，需要用指针接收者</p>
</blockquote>
<blockquote>
<p>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者</p>
</blockquote>
<blockquote>
<p>接收者是拷贝代价比较大的大对象</p>
</blockquote>
<h4 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h4><blockquote>
<p>结构体中只有类型没有名字的字段，并且类型不能重复</p>
<p>当字段比较少也比较简单时使用</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">type person struct{
    string
    int
    //string  此时再写string就会报错，因为类型不能重复
}</code></pre>

<h4 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h4><blockquote>
<p>结构体嵌套结构体</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">type address struct{  //类型1
    name string
    age int
}

type ren struct{
    gender string
    addr address   // 嵌套了类型1
}


func main(){
    f1 := ren{
        gender:"男",
        addr:address{   //嵌套结构体构造数据
            name:"天听",
            age:20,
        }
    }
}
</code></pre>

<h4 id="匿名嵌套结构体"><a href="#匿名嵌套结构体" class="headerlink" title="匿名嵌套结构体"></a>匿名嵌套结构体</h4><pre class="language-go" data-language="go"><code class="language-go">type address struct{  
    name string
    age int
}

type ren struct{
    gender string
    address   // 匿名嵌套
}


func main(){
    f1 := ren{
        gender:"男",
        addr:address{   
            name:"天听",
            age:20,
        }
    }
    // fmt.Println(f1.addr.name)
    fmt.Println(f1.name)
}</code></pre>

<blockquote>
<p>匿名嵌套结构体的好处是可以直接调用被嵌套结构体中的字段</p>
<p>但是，如果嵌套了两个结构体，而这两个结构体中有一样的字段，这种写法会有字段冲突，解决办法就是写全</p>
</blockquote>
<h4 id="结构体模拟“继承”"><a href="#结构体模拟“继承”" class="headerlink" title="结构体模拟“继承”"></a>结构体模拟“继承”</h4><pre class="language-go" data-language="go"><code class="language-go">//动物类
type animal struct {
	name string
}

//动物的方法
func (a animal) move() {
	fmt.Printf("%s会动\n", a.name)
}

//狗类，继承动物类
type dog struct {
	id uint8
	animal
}

//狗类的方法
func (d dog) wang() {
	fmt.Printf("%s在叫", d.name)
}

func main() {
	d1 := dog{
		id:     1,
		animal: animal{name: "哈士奇"},
	}
	d1.wang()
	d1.move()  //动物类的方法，狗类同样也能使用
}</code></pre>

<h4 id="结构体与JSON"><a href="#结构体与JSON" class="headerlink" title="结构体与JSON"></a>结构体与JSON</h4><blockquote>
<p>序列化：把go语言中的结构体变量转换为json格式的字符串</p>
<p>反序列化：json格式的字符串转换为go语言中能够识别的结构体变量</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">import "encoding/json"

func main(){
    f1 := person{
        name:"天听",
        age:18,
    }
    b,err := json.Marshal(f1)
}</code></pre>

<h2 id="14-接口"><a href="#14-接口" class="headerlink" title="14.接口"></a>14.接口</h2><p>关键字：<code>interface</code></p>
<blockquote>
<p>注意：接口是一种类型,他规定了数据有哪些方法</p>
</blockquote>
<p>例如，结构体Dog可以walk和bark， 如果一个接口声明了walk和bark的方法签名，而Dog实现了walk和bark方法，那么Dog就实现了该接口。<br> 接口的主要工作是仅提供由方法名称，输入参数和返回类型组成的方法签名集合。 由类型（例如struct结构体）来声明方法并实现它们。</p>
<pre class="language-go" data-language="go"><code class="language-go">//造接口，只要是有speak方法的变量，他就是speaker类型的接口
type speaker interface {
	speak()
}

//造两个结构体
type dog struct{}
type cat struct{}


//各有一个speak方法
func (d dog) speak() {
	fmt.Println("汪汪汪")
}
func (c cat) speak() {
	fmt.Println("喵喵喵")
}

//只需要将接口传进来即可
func da(x speaker) {
	x.speak()
}

func main() {

	var c cat
	var d dog

	da(c)
	da(d)

}</code></pre>

<blockquote>
<p>一个接口中可以有多个方法，但是需要全部实现才算是这个接口类型的变量，只实现其中的某个方法不算这个接口变量.</p>
<p>同一个结构体可以实现多个接口</p>
</blockquote>
<p> 使用<strong>值接收者</strong>和<strong>指针接收者</strong>实现接口区别：</p>
<pre><code>1. 使用**值接收者**实现接口，结构体类型和结构体指针类型的变量都能存
2. **指针接收者**实现接口，只能存结构体指针类型的变量
</code></pre>
<h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><pre class="language-go" data-language="go"><code class="language-go">interface{}   // 空接口</code></pre>

<blockquote>
<p>所有的类型都实现了空接口，也就是任意类型的变量都能保存在空接口中</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func main(){
    var m1 map[string]interface{}//注意加括号，否则只是关键字
    m1 = make(map[string]interface{})
    m1["name"] = "天听"
    m1["age"] = 18
}</code></pre>

<blockquote>
<p>在上面的例子中，既可以保存字符串，又能保存整型</p>
</blockquote>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p><code>x.(T)</code> </p>
<ul>
<li>x:表示类型为<code>interface{}</code>的变量</li>
<li>T:表示断言，x可能是的类型</li>
</ul>
<pre class="language-go" data-language="go"><code class="language-go">func ss(a interface{}){
    str,ok := a.(string) //类型断言
    if !ok{
        fmt.Println("猜错了")
    }else{
        fmt.Println("字符串")
    }
}</code></pre>

<pre class="language-go" data-language="go"><code class="language-go">func ss(a interface{}){
    switch t := a.(type){
        case string:
        	fmt.Println("字符串")
        case int:
        	fmt.Println("整型")
        case bool:
        	fmt.Println("布尔")
    }
}</code></pre>

<h2 id="15-包"><a href="#15-包" class="headerlink" title="15.包"></a>15.包</h2><p>包中的<code>标识符</code>首字母大写才可以对外部可见</p>
<blockquote>
<p>根据自己的需要创建自己的包。一个包可以简单理解为一个存放<code>.go</code>文件的<strong>文件夹</strong>。 该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">package 包名   //包的定义</code></pre>

<ul>
<li>一个文件夹下面直接包含的文件只能归属一个<code>package</code>，同样一个<code>package</code>的文件不能在多个文件夹下。</li>
<li>包名可以不和文件夹的名字一样，包名不能包含 <code>-</code> 符号。</li>
<li>包名为<code>main</code>的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含<code>main</code>包的源代码则不会得到可执行文件。</li>
</ul>
<blockquote>
<p>要在代码中引用其他包的内容，需要使用<code>import</code>关键字导入使用的包</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">import "包的路径"   // 包的导入</code></pre>

<p>注意事项：</p>
<ul>
<li>import导入语句通常放在文件开头包声明语句的下面。</li>
<li>导入的包名需要使用双引号包裹起来。</li>
<li>包名是从<code>$GOPATH/src/</code>后开始计算的，使用<code>/</code>进行路径分隔。</li>
<li>Go语言中禁止循环导入包。</li>
</ul>
<h4 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a>匿名导入包</h4><blockquote>
<p>如果只希望导入包，而不使用包内部的数据时，可以使用匿名导入包</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">import _ "包的路径"</code></pre>

<blockquote>
<p>匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中</p>
</blockquote>
<h4 id="init初始化函数"><a href="#init初始化函数" class="headerlink" title="init初始化函数"></a>init初始化函数</h4><blockquote>
<p>在Go语言程序执行时导入包语句会自动触发包内部<code>init()</code>函数的调用。需要注意的是： <code>init()</code>函数没有参数也没有返回值。 <code>init()</code>函数在程序运行时自动被调用执行，不能在代码中主动调用它</p>
</blockquote>
<h2 id="16-文件操作"><a href="#16-文件操作" class="headerlink" title="16.文件操作"></a>16.文件操作</h2><blockquote>
<p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>和一个<code>err</code>。对得到的文件实例调用，<code>close()</code>方法能够关闭文件。</p>
</blockquote>
<blockquote>
<p>为了防止文件忘记关闭，通常使用defer注册文件关闭语句</p>
</blockquote>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><pre class="language-go" data-language="go"><code class="language-go">//打开文件，返回两个参数
	fileobj, err := os.Open("./main.go")
	if err != nil {
		fmt.Println("错误为:", err)
		return
	}
	defer fileobj.Close()
	var tmp = make([]byte, 128)
	//var tmp = [128]byte
	for {
		n, err := fileobj.Read(tmp[:])
		if err != nil {
			fmt.Println("读取错误为：", err)
			return
		}
		fmt.Println("读取的字节数为：", n)
		fmt.Println(string(tmp[:n]))
		if n &lt; 128 {
			return
		}
	}</code></pre>



<h4 id="file-Read"><a href="#file-Read" class="headerlink" title="file.Read()"></a>file.Read()</h4><blockquote>
<p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code></p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func (f *File) Read(b []byte) (n int, err error)
//Read方法定义</code></pre>

<h4 id="bufio"><a href="#bufio" class="headerlink" title="bufio"></a>bufio</h4><blockquote>
<p>bufio是在file的基础上封装了一层API，支持更多的功能</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">fileobj, err := os.Open("./main.go")
	if err != nil {
		fmt.Println("错误为：", err)
		return
	}
	defer fileobj.Close()

	//创建一个用来从文件中读取内容的对象
	reader := bufio.NewReader(fileobj)
	for {
		line, err := reader.ReadString('\n')
		if err == io.EOF {
			return
		}
		if err != nil {
			fmt.Println("！！！！", err)
			return
		}
		fmt.Print(line)
	}</code></pre>

<h4 id="ioutil"><a href="#ioutil" class="headerlink" title="ioutil"></a>ioutil</h4><p><code>io/ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入</p>
<pre class="language-go" data-language="go"><code class="language-go">content, err := ioutil.ReadFile("./main.go")
if err != nil {
    fmt.Println("read file failed, err:", err)
    return
}
fmt.Println(string(content))</code></pre>

<h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能</p>
<p><code>name</code>：要打开的文件名</p>
<p> <code>flag</code>：打开文件的模式：</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>os.O_WRONLY</code></td>
<td align="center">只写</td>
</tr>
<tr>
<td align="center"><code>os.O_CREATE</code></td>
<td align="center">创建文件</td>
</tr>
<tr>
<td align="center"><code>os.O_RDONLY</code></td>
<td align="center">只读</td>
</tr>
<tr>
<td align="center"><code>os.O_RDWR</code></td>
<td align="center">读写</td>
</tr>
<tr>
<td align="center"><code>os.O_TRUNC</code></td>
<td align="center">清空</td>
</tr>
<tr>
<td align="center"><code>os.O_APPEND</code></td>
<td align="center">追加</td>
</tr>
</tbody></table>
<h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><blockquote>
<p>写入字节切片数据</p>
</blockquote>
<h4 id="WriteString"><a href="#WriteString" class="headerlink" title="WriteString"></a>WriteString</h4><blockquote>
<p>直接写入字符串数据</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">fileobj, err := os.OpenFile("./ss.txt", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		fmt.Println(err)
		return
	}
	fileobj.Write([]byte("执子之魂，与子共生\n"))
	fileobj.WriteString("那些逃离死亡的人，其生命，早已停滞不前")
	defer fileobj.Close()</code></pre>

<h4 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h4><pre class="language-go" data-language="go"><code class="language-go">fileobj, err := os.OpenFile("./ss.txt", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		fmt.Println(err)
		return
	}
	wr := bufio.NewWriter(fileobj)
	//将数据先写入缓存
	wr.WriteString("明天，只是一个希望，不是一个承诺")
	//将缓存中的内容写入文件
	wr.Flush()
	defer fileobj.Close()</code></pre>

<h4 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h4><pre class="language-go" data-language="go"><code class="language-go">str := "hello 龙潭"
err := ioutil.WriteFile("./xx.txt", []byte(str), 0666)
if err != nil {
    fmt.Println("write file failed, err:", err)
    return
}</code></pre>

<h2 id="17-时间模块"><a href="#17-时间模块" class="headerlink" title="17.时间模块"></a>17.时间模块</h2><h4 id="time包"><a href="#time包" class="headerlink" title="time包"></a><code>time</code>包</h4><blockquote>
<p>time包是时间模块</p>
</blockquote>
<blockquote>
<p>当前时间</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func main(){
    now := time.Now()
    fmt.Println(now)
    fmt.Println(now.Year())
}</code></pre>

<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><blockquote>
<p><code>Unix()</code></p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func main(){
    now := time.Now()
    fmt.Println(now.Unix()) //时间戳
    fmt.Println(now.UnixNano()) //纳秒时间戳
}</code></pre>

<h4 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h4><p><code>time.Duration</code>是<code>time</code>包定义的一个类型，它代表两个时间点之间经过的时间，以<strong>纳秒</strong>为单位。</p>
<p>time包中定义的时间间隔类型的常量如下：</p>
<pre class="language-go" data-language="go"><code class="language-go">const (
    Nanosecond  Duration = 1
    Microsecond          = 1000 * Nanosecond
    Millisecond          = 1000 * Microsecond
    Second               = 1000 * Millisecond
    Minute               = 60 * Second
    Hour                 = 60 * Minute
)</code></pre>

<blockquote>
<p><code>time.Duration</code>表示1纳秒，<code>time.Second</code>表示1秒。</p>
</blockquote>
<h4 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h4><blockquote>
<p>在日常编码可能会遇到要求时间+时间间隔需求，这时，需要用到<code>Add</code></p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">fmt.Println(time.Second)
//当前时间+24小时
fmt.Println(now.Add(24*time.Hour))</code></pre>

<h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><blockquote>
<p>通俗的讲，就是把语言中的时间对象转换成字符串类型的时间</p>
</blockquote>
<blockquote>
<p>格式化时间模板不是常见的<code>Y-m-d H:M:S</code>而是使用Go的诞生时间2006年1月2号15点04分（记忆口诀为2006 1 2 3 4）</p>
</blockquote>
<p><code>now.Format</code></p>
<pre class="language-go" data-language="go"><code class="language-go">// 注意，格式化是从2006-01-02开始，这个值不可变
fmt.Println(now.Format("2006-01-02"))

fmt.Println(now.Format("2006-01-02 15:04:05"))</code></pre>

<h4 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h4><blockquote>
<p>按照对应的格式解析字符串类型的时间</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">time.Parse("2006-01-02","2020-8-20")</code></pre>

<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><blockquote>
<p>使用<code>time.Tick(时间间隔)</code>来设置定时器，定时器的本质上是一个通道（channel）</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">func tickDemo() {
	ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器
	for i := range ticker {
		fmt.Println(i)//每秒都会执行的任务
	}
}</code></pre>

<h2 id="18-log日志服务"><a href="#18-log日志服务" class="headerlink" title="18.log日志服务"></a>18.log日志服务</h2><blockquote>
<p>Go语言内置的<code>log</code>包实现了简单的日志服务。</p>
</blockquote>
<pre class="language-go" data-language="go"><code class="language-go">log.Println("打印的日志")
//输入结果
//2020/08/20 16:28:50 打印的日志</code></pre>

<p><code>log.SetOutput()</code>设置输出位置</p>
<h2 id="19-反射"><a href="#19-反射" class="headerlink" title="19.反射"></a>19.反射</h2><blockquote>
<p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p>
</blockquote>
<blockquote>
<p>反射类似于ORM</p>
</blockquote>
<h4 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h4><blockquote>
<p>在Go语言的反射机制中，任何接口值都由是<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成</p>
</blockquote>
<blockquote>
<p>在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p>
<p>注意，无论是<code>TypeOf</code>还是<code>ValueOf</code>，都有一个kind方法，要注意。</p>
</blockquote>
<h4 id="type-name-和-type-kind"><a href="#type-name-和-type-kind" class="headerlink" title="type name 和 type kind"></a>type name 和 type kind</h4><p>在反射中类型具体划分为两种，一种是类型(Type)， 一种是种类(Kind)</p>
<pre class="language-go" data-language="go"><code class="language-go">type Cat struct{
  Name string
}</code></pre>

<p>一个结构体，此时，我们如果要打印他的类型的话，他是一个Cat类型，但是，同时他也属于struct，struct就属于他的种类(Kind)，Cat就是他的类型(Type)，</p>
<h2 id="20-高并发"><a href="#20-高并发" class="headerlink" title="20.高并发"></a>20.高并发</h2><blockquote>
<p>都知道，golang天生支持高并发，语言特性使得他是一个并发的杀器。</p>
</blockquote>
<h4 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h4><p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p>
<p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p>
<p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p>
<p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p>
<p>举个例子：</p>
<pre class="language-go" data-language="go"><code class="language-go">package main

import (
	"fmt"
	"time"
)

func newTask()  {
	i := 0
	for {
		i++
		fmt.Println("newTask",i)
		time.Sleep(1 * time.Second)
	}
}


func main() {

	go newTask()

	i := 0
	for {
		i++
		fmt.Println("main", i)
		time.Sleep(1 * time.Second)
	}

}</code></pre>

<blockquote>
<p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p>
<p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是权利的游戏中的夜王，其他的<code>goroutine</code>都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p>
</blockquote>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>天听</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://godhearing.cn/2021/01/22/go/" title="Go语言基础">https://godhearing.cn/2021/01/22/go/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/01/23/axios-huo-qu-wen-jian-liu-xing-shi-ru-he-zhan-shi/" rel="prev" title="axios获取文件流并且展示为图片"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">axios获取文件流并且展示为图片</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/01/21/wei-xin-xiao-cheng-xu-yong-hu-ren-zheng-luo-ji/" rel="next" title="微信小程序用户认证逻辑"><span class="post-nav-text">微信小程序用户认证逻辑</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">冀ICP备2021002475号-1</a></div><div class="copyright"><span>&copy; 2017 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 蓝 桉</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.4.0</span></div><div class="live_time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2017-07-12T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#ff8c00" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="开始面向搜索引擎编程" value=""></div><div id="local-search-result"></div></div></div></body></html>