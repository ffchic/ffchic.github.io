---
title: 区块链技术与应用二 比特币的数据结构
date: 2026-02-04 16:53:43
tags: [区块链, web3, 比特币]
categories: [区块链, web3]
---

## 比特币的数据结构

比特币系统中主要使用了两种核心数据结构：**Hash Pointers（哈希指针）** 和 **Merkle Tree（默克尔树）**。

### Hash Pointers（哈希指针）

普通的指针通常只存储结构体在内存中的地址，而 **哈希指针（Hash Pointer）** 在此基础上，还额外存储了该结构体的 **哈希值**。

这种设计的优势在于：我们不仅能找到数据在哪里（寻找位置），还能确认该数据是否被修改过（验证防篡改）。

#### 区块链（The Blockchain）

区块链本质上就是一个由哈希指针串联起来的链表（Linked List）。它与普通链表的关键区别在于：**它使用哈希指针代替了普通指针**。

{% asset_img btc-data-structure-hash-pointer.png 哈希指针示意图 %}

如上图所示，这是一个简化的区块链结构：
- **Genesis Block（创世块）**：链条最前端的第一个区块。
- **Most Recent Block**：当前最新产生的区块。

每个区块都包含了一个指向前一区块的哈希指针。如果我们系统中保存了指向**最后一个区块**的哈希指针，就能牵一发而动全身地锁定整条链的内容。

**防篡改原理**：
如果有人恶意篡改了链中间的某个区块，那么该区块的哈希值必然发生变化；这将导致后一个区块中存储的“前驱哈希指针”失效。为了掩盖修改，攻击者必须接着修改后一个区块的内容……如此一直向后，直到修改到最后一个区块。
但也因为我们手里掌握着最后一个区块的哈希指针（锚点），攻击者的修改最终会被我们发现。因此，**只需要保存最后一个区块的哈希值，就可以验证整条链的数据完整性**。

同理，验证过程也是从后向前，利用后一个区块保存的哈希值，逐个校验前一个区块是否合规。

### Merkle Tree（默克尔树）

Merkle Tree 可以看作是哈希指针的一种高级应用（将线性的链表扩展为树状结构）。

{% asset_img merkle-tree.png 哈希树示意图 %}

- **Data Blocks（数据块）**：树的最底层（叶子节点），在比特币中对应着具体的一笔笔**交易**。
- **结构特点**：**每上一层**的节点，都包含了下层两个子节点的哈希值。
- **Root Hash（根哈希）**：通过层层向上计算，最终树的顶部会得到一个唯一的根哈希值。

**作用**：
类似于区块链，我们只需要保存树根的 **Root Hash**，就能验证整棵树中（也就是所有交易中）的任意一笔数据是否被篡改。

#### Merkle Proof（默克尔证明）

在区块链网络中，节点的存储方式主要分为两种：
1.  **全节点（Full Node）**：保存了整条区块链的所有数据，包括 Merkle Tree 的所有节点信息。
2.  **轻节点（Light Node / SPV Node）**：只保存区块头信息（Block Header），其中包含了 Merkle Root，但不保存具体的交易列表。

**场景应用**：
如果一个轻节点用户（例如手机钱包用户）想要确认“我收到的这笔交易（黄色 tx）”是否真的被打包进了某个区块中，但他手中没有完整的交易数据，该怎么办？这就需要用到 **Merkle Proof**。

{% asset_img merkle-proof.png 哈希验证示意图 %}

**验证流程**（如上图所示）：

1.  **发起请求**：轻节点向全节点发起查询请求。
2.  **获取证明**：全节点不需要发送整棵树的数据，只需要发送从这笔交易通往树根路径上**缺失的兄弟节点哈希值**（图中红色部分）。这一组哈希值序列就是 **Merkle Proof**。
3.  **本地计算**：轻节点收到证明后，会在本地进行计算。它首先计算目标交易的哈希，然后将其与红色的兄弟哈希结合，计算出上一层的父节点哈希（图中绿色部分），如此层层向上计算。
4.  **最终比对**：最终算出的根哈希值，与轻节点手中区块头里存储的 **Merkle Root**（橙色块）进行比对。
5.  **结论**：如果两者**一致**，即可数学证明该笔交易确实存在于该区块的 Merkle Tree 中。